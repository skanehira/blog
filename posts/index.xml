<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on ゴリラ@転生したら人間だった件</title><link>https://skanehira.github.io/blog/posts/</link><description>Recent content in Posts on ゴリラ@転生したら人間だった件</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 08 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://skanehira.github.io/blog/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>LinuxでもEmacs風なキーバインドを設定する</title><link>https://skanehira.github.io/blog/posts/20210308-linux-autokey/</link><pubDate>Mon, 08 Mar 2021 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20210308-linux-autokey/</guid><description>初めに 普段Macでカーソル移動をする時は方向キーを使わず、&amp;lt;C-n&amp;gt;や&amp;lt;C-f&amp;gt;、&amp;lt;C-b&amp;gt;などのEma</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>普段Macでカーソル移動をする時は方向キーを使わず、<code>&lt;C-n&gt;</code>や<code>&lt;C-f&gt;</code>、<code>&lt;C-b&gt;</code>などのEmacs風のキーバインドを使っています。
ホームポジションを崩さずにカーソルを移動できるこのキーバインドはたいへん便利ですが、Linuxではデフォルトでこのようなキーバインドを使えないです。
そのため、普段Linuxを使っているとそこが少し不便さを感じていました。</p>
<p>本記事では自分の備忘録も兼ねて、上記の問題を解消できる<a href="https://github.com/autokey/autokey">autokey</a>というのを紹介していきます。
なお、筆者の環境は以下になります。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>OS</td>
<td>Ubuntu 20.04 TLS</td>
</tr>
<tr>
<td>Desktop</td>
<td>Xorg</td>
</tr>
</tbody>
</table>
<h2 id="autokeyとは">Autokeyとは</h2>
<p>簡単に言うとキーバインドを設定できるソフトウェアになります。
ちゃんと調べていないですが、イメージとしてはX11を通してソフトウェアに送信されるキー情報を書き換えるという感じでしょうか。
これを使用することで、キーバインドを自由に設定できます。</p>
<p>Ubuntuでは、次のコマンドで導入できます。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ sudo apt install autokey-gtk
</code></pre></div><h2 id="なぜautokeyなのか">なぜAutokeyなのか</h2>
<p>Ubuntuユーザーであれば知っていると思いますが、<a href="https://itsfoss.com/gnome-tweak-tool/">Gnome Tweak Tool</a>というアプリケーションがあります。
このアプリケーションではキーバインドをEmacs風に変更できます。しかし<code>↓</code>/<code>↑</code>を<code>&lt;C-n&gt;</code>/<code>&lt;C-p&gt;</code>で代用できない、といった適用しきれていない問題があります。</p>
<p><img src="https://i.gyazo.com/0ebd07d02211b8b910bb8adf51675760.png" alt=""></p>
<p>そこでAutokeyも併用することで先程の問題を解決できます。今のところ特に問題なく使えているので設定を気を付ければ競合は起きないと思います。</p>
<h2 id="設定">設定</h2>
<p>設定は大きく分けて以下の3ステップあります。詳細を説明していきます。</p>
<ol>
<li>フォルダを作成する</li>
<li>フォルダとアプリケーションを紐付ける</li>
<li>キーバインドを設定する</li>
</ol>
<p>autokeyはアプリケーションごとにキーバインドを設定できます
。筆者は1アプリケーションに1フォルダというふうにしていますが、特にルールはなくフォルダを自由に作成でき、名前も任意に付けられます。</p>
<p><img src="https://i.gyazo.com/cf47ee01d936c2b4811c606c4fa75bf7.png" alt=""></p>
<p>フォルダとアプリケーションを紐付けるにはフォルダを選択した状態で右側にある<code>Window Filter</code>の<code>Set</code>ボタンから、<code>Detect Window Properties</code>を選択して、対象のアプリケーションにウィンドウ切り替えをすれば良いです。</p>
<p><img src="https://i.gyazo.com/f4fa7602c2fa2e710c57e0d7c6e7713e.png" alt=""></p>
<p>次にキーバインドの設定ですが、フォルダ内にスクリプトを追加していき、設定を書いていきます。
フォルダを選択した状態で新規ボタンから<code>Script</code>を選択して、任意の名前を付けます。筆者の場合はキー名（たとえば削除なら<code>delete</code>など）にしています。</p>
<p><img src="https://i.gyazo.com/501c4866cfe5ac000aca198a548386a3.png" alt=""></p>
<p>次に入力したキーとそれに対応するキーの設定をしていきます。スクリプトを選択して画面右側の<code>HotKey</code>を選択すると入力キーを設定できます。
次の画面で<code>Press to Set</code>を押してからキーを入力するとキャプチャしてくれます。</p>
<p><img src="https://i.gyazo.com/884c7eb88f6d636497297251758d24f0.png" alt=""></p>
<p>次に対応するキーはスクリプト入力部で<code>keyboard.send_keys(&quot;&lt;ctrl&gt;+f&quot;)</code>と入力します。これで<code>HotKey</code>にて設定したキーを押されたらスクリプトで設定したキーが送られます。</p>
<p><img src="https://i.gyazo.com/39560f94ee874a668368cdf98f5ecd28.png" alt=""></p>
<p>ちなみに筆者は次のように設定しています。</p>
<table>
<thead>
<tr>
<th><code>HotKey</code></th>
<th><code>SendKeys</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;super&gt;+f</code></td>
<td><code>&lt;ctrl&gt;+f</code></td>
</tr>
<tr>
<td><code>&lt;ctrl&gt;+h</code></td>
<td><code>&lt;backspace&gt;</code></td>
</tr>
<tr>
<td><code>&lt;ctrl&gt;+n</code></td>
<td><code>&lt;down&gt;</code></td>
</tr>
<tr>
<td><code>&lt;ctrl&gt;+p</code></td>
<td><code>&lt;up&gt;</code></td>
</tr>
<tr>
<td><code>&lt;ctrl&gt;+b</code></td>
<td><code>&lt;left&gt;</code></td>
</tr>
<tr>
<td><code>&lt;ctrl&gt;+f</code></td>
<td><code>&lt;right&gt;</code></td>
</tr>
</tbody>
</table>
<h2 id="参考文献">参考文献</h2>
<ul>
<li><a href="https://github.com/autokey/autokey/wiki/API-Examples#send-keys">https://github.com/autokey/autokey/wiki/API-Examples#send-keys</a></li>
<li><a href="https://autokey.github.io">https://autokey.github.io</a></li>
<li><a href="https://qiita.com/sassoon/items/ce6ae698fcfbd1fd8a42">https://qiita.com/sassoon/items/ce6ae698fcfbd1fd8a42</a></li>
</ul>
<h2 id="最後に">最後に</h2>
<p>ざっくりですが<code>AutoKey</code>について紹介しました。これでQOLがだいぶ上がったので、みなさんもぜひ試してみてください。
また、<code>AutoKey</code>の設定のより詳細な情報は参考文献を見ていただければと思います。</p>
]]></content></item><item><title>GitHubのTUIツールを作った</title><link>https://skanehira.github.io/blog/posts/20210222-go-github-tui/</link><pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20210222-go-github-tui/</guid><description>以前に VimでGitHubを操作するプラグインgh.vimの紹介 という記事を書きました。 こちらの記事で紹介したgh.vimはVim上でGit</description><content type="html"><![CDATA[<p>以前に <a href="https://skanehira.github.io/blog/posts/20201203-introduce-gh-vim/">VimでGitHubを操作するプラグインgh.vimの紹介</a> という記事を書きました。
こちらの記事で紹介した<code>gh.vim</code>はVim上でGitHubの機能を使えるようにしたVimプラグインです。仕事でがっつりGitHubを使うならとても便利なプラグインと思っています。</p>
<p>しかしVimを使っていない人もたくさんいるので、そういった人向けのツールあったほうが良いかなと思い、GitHubのTUIツール <a href="https://github.com/skanehira/github-tui">github-tui</a> を作りました。
CLIと比べ、TUIはインタラクティブに、そして直感的に操作できるというメリットがあるので便利なのではないかなと思っています。
余談ですが過去にDockerのTUIツール <a href="https://github.com/skanehira/docui">docui</a> を作ったりもしました。</p>
<p><a href="https://github.com/skanehira/github-tui">github-tui</a> は未完成ではありますが、最低限形になったし、需要があるかどうかを見たかったのでひとまず一般公開しました。
本記事は<code>github-tui</code>について、紹介と展望について書いていきますので興味ある方はぜひ最後まで読んでみてください。</p>
<h3 id="画面構成">画面構成</h3>
<p><img src="https://i.gyazo.com/ca2dc9bed29bb5b446d58d9aeae94e8c.png" alt=""></p>
<p><code>github-tui</code>では大きく分けて以下の3種類のパネルがあります。</p>
<ol>
<li>入力</li>
<li>一覧</li>
<li>プレビュー</li>
</ol>
<p>詳細は次のとおりです。</p>
<table>
<thead>
<tr>
<th>パネル</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Filters</td>
<td>画面上部のクエリを入力する部分</td>
</tr>
<tr>
<td>issues</td>
<td>issue一覧</td>
</tr>
<tr>
<td>assignees</td>
<td>選択中のissueにアサインされているユーザー覧</td>
</tr>
<tr>
<td>labels</td>
<td>選択中のissueに付けたラベル一覧</td>
</tr>
<tr>
<td>milestones</td>
<td>選択中のissueに紐付いているマイルストーン</td>
</tr>
<tr>
<td>projects</td>
<td>選択中のissueに紐付いているプロジェクト一覧</td>
</tr>
<tr>
<td>issue preview</td>
<td>選択中のissue本文のプレビュー</td>
</tr>
<tr>
<td>comments</td>
<td>選択中のissueのコメント一覧</td>
</tr>
<tr>
<td>comment preview</td>
<td>選択中のコメント本文のプレビュー</td>
</tr>
<tr>
<td>search</td>
<td>画面下部の検索キーワードを入力する部分</td>
</tr>
</tbody>
</table>
<h3 id="機能">機能</h3>
<p>現時点ではissue関連の機能が実装されています。未実装の機能は<a href="https://github.com/skanehira/github-tui#still-under-development">こちら</a>を参照ください。</p>
<ul>
<li>Issue
<ul>
<li>list</li>
<li>create</li>
<li>close</li>
<li>open</li>
<li>open browser</li>
<li>preview</li>
<li>edit</li>
</ul>
</li>
<li>Issue comment
<ul>
<li>list</li>
<li>preview</li>
<li>delete</li>
<li>edit
<ul>
<li>add</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="基本的な使い方">基本的な使い方</h4>
<p>リポジトリを指定して起動するか、指定しない場合はカレントディレクトリのリポジトリが自動で指定されます。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># current repository</span>
$ ght

<span class="c1"># specified repository</span>
$ ght owner/repo
</code></pre></div><p>起動後にissueの検索が行われ、一覧が表示されます。パネルを移動するには<code>Ctrl-N</code>/<code>Ctrl-P</code>を使います。</p>
<h4 id="検索">検索</h4>
<p><code>github-tui</code>では<a href="https://docs.github.com/en/github/searching-for-information-on-github/searching-issues-and-pull-requests#search-only-issues-or-pull-requests">search</a>のクエリを使ってissueを検索できます。現時点ではissueのみ検索可能ですが、将来的にはPRなども検索できるようにする予定です。</p>
<p>どんなクエリが使えるかは、searchのドキュメントを参照していただければと思いますが、たとえばissueのタイトルと本文に&quot;ゴリラ&quot;という文字を含んだissueを検索したい場合は次のクエリを入力してEnterを押すと検索できます。</p>
<pre><code>is:issue state:open ゴリラ in:body,title
</code></pre><p><img src="https://i.gyazo.com/9dbfc882ce9305b7a1652c5c71c00737.gif" alt=""></p>
<p>demoのように、基本的に選択しているissueが変わる度、issue本文とコメントのプレビューが変わるようになっています。
検索時にissueの本文、それに紐づくラベルやコメントなどを一斉に取得するため、タイムラグなしにプレビューできます。</p>
<p>デフォルトでは検索で取得するissueは30件までとなっていますが、<code>f</code>を使って更に検索結果を取得できます。
GitHubの仕様では1度に100件まで取得可能ですが、前述したとおりissueに関連している情報も色々取得しているため30件に制限しています。
将来的にデフォルトのlimitをconfigで変更できるようにしたいと考えています。</p>
<h4 id="キーワード検索">キーワード検索</h4>
<p>一覧とプレビューパネルでは<code>/</code>を押すとキーワードを検索できます。一覧の場合は表示されている項目、プレビューパネルの場合は表示されている中身をそれぞれ検索します。</p>
<p><img src="https://i.gyazo.com/91631e116d3349fb043cae76f5627df1.gif" alt=""></p>
<p>プレビューパネルの場合はキーワードがハイライトされ、<code>n</code>で次の、<code>N</code>で前のキーワードにジャンプできます。Vimmerならこの操作に馴染みやすいかと思います。</p>
<h4 id="プレビューパネルの拡大">プレビューパネルの拡大</h4>
<p><code>github-tui</code>はターミナルのサイズに合わせてパネルのサイズを動的に変更します。各パネルのサイズの割合は決まっています。
そのため、画面が小さいとプレビュー画面も小さくなりissueやコメントの本文が読みづらくなります。
その際は<code>o</code>でパネルを拡大でき、再度<code>o</code>を押すと元に戻ります。</p>
<p><img src="https://i.gyazo.com/6e25f0e970f0ab6ef1dbbe17b55d7ebf.gif" alt=""></p>
<h4 id="issueのopenとclose">issueのOpenとClose</h4>
<p>issue一覧パネルでは<code>Ctrl-J</code>/<code>Ctrl+K</code>を使って複数のissueにチェックを付けて、それらをまとめてOpenまたはCloseできます。
チェックしていない場合は、現在選択しているissueに作用します。issueをOpenするには<code>o</code>、Closeするには<code>c</code>を使います。</p>
<p><img src="https://i.gyazo.com/b30c8107ae75fda1c7da42c8170c871e.gif" alt=""></p>
<p>また、選択したissueを<code>Ctrl-O</code>を使ってブラウザで開くこともできます。</p>
<h4 id="issue作成">issue作成</h4>
<p>issue一覧パネルで<code>n</code>を使ってissueを新規作成できます。作成の際にフォームが表示されるので、<code>Tab</code>で各項目を切り替えながら必要な部分を埋めていく使い方になります。</p>
<p><img src="https://i.gyazo.com/fb665369057c5f096517a24e606e7884.png" alt=""></p>
<p><code>Repo</code>は<code>Filters</code>にある<code>repo:owner/repo</code>から取得するので、作成する際にはそのクエリが必須です。
<code>Assignees</code>と<code>Labels</code>、<code>Projects</code>は入力補完が可能ですので、任意のキーワードを入力すると補完候補が表示されます。ただし、複数の候補を追加したい場合は<code>,</code>で区切る必要があります。これはUIによる制限です。（ツライ）</p>
<p><code>MileStone</code>と<code>Temaplte</code>はオプションになっていて、<code>↑</code>と<code>↓</code>で選択でき、<code>Esc</code>で選択をキャンセルできます。
<code>Edit Body</code>ボタンは<code>$EDITOR</code>で設定されているエディタを使ってissue本文を編集できますが、<code>$EDITOR</code>が特に設定されていない場合は<code>Vim</code>がデフォルトで使用されます。
<code>Create</code>ボタンで<code>Enter</code>を押下するとissueが作成されます。成功するとフォームが閉じられ1秒経ってからissue一覧が更新されます。1秒待つ理由としては作成後すぐにissue一覧を取得してもすぐに反映されないためです。</p>
<p><img src="https://i.gyazo.com/c9b132ac7f44d0366dbd5d932529816d.gif" alt=""></p>
<p>注意点として、以下のデータがない場合は項目自体が表示されない様になっています。</p>
<ul>
<li><code>Labels</code></li>
<li><code>Projects</code></li>
<li><code>MileStone</code></li>
<li><code>Temaplte</code></li>
</ul>
<h3 id="今後の展望">今後の展望</h3>
<p>基本的にブラウザでやっていたことをターミナルでもできるようにするという方針です。たとえば、issueの作成、PRの作成、PRのレビューなどです。
ただし、使用しているライブラリでは実現が難しい可能性もあるので、ある程度妥協も必要かなと考えています。
直近はまずisssueとPR周りの機能を充実させていきます。やることは多いですがコツコツ作っていきます。</p>
<h3 id="最後に">最後に</h3>
<p>一通り、現時点の実装済みの機能について紹介しましたが、どうでしたか？便利そうだなと思ったらぜひ試してみてください。要望などはissueで受け付けますので、こういう機能欲しい！というのがあればぜひリクエストください。検討します。</p>
<p>そして、もし開発に興味あるなら<a href="https://twitter.com/gorilla0513">Twitter</a>で連絡をいただけるとうれしいです。</p>
]]></content></item><item><title>Swaggerをプレビューする簡単なCLI</title><link>https://skanehira.github.io/blog/posts/20200205-go-swagger-preview/</link><pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200205-go-swagger-preview/</guid><description>初めに 仕事でAPIのドキュメントにswaggerを使っていますが、プレビューするために毎度VSCodeを立ち上げて使っていました。 しかし、こ</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>仕事でAPIのドキュメントにswaggerを使っていますが、プレビューするために毎度VSCodeを立ち上げて使っていました。
しかし、このためだけにVSCodeを起動するのはさすがにオーバースペックでそれに耐えられず、簡単なCLIを作りました。</p>
<p><a href="https://github.com/skanehira/swagger-preview">https://github.com/skanehira/swagger-preview</a></p>
<h3 id="使い方">使い方</h3>
<p>コマンドの引数にswagger.yamlを指定します。そうするとサーバが立ち上がってブラウザが開きます。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ spr api.yaml
2021/02/02 21:51:46 start server: <span class="m">9999</span>
2021/02/02 21:51:46 watching swagger.yaml
</code></pre></div><p>デフォルトポートは9999ですが、環境変数<code>PORT</code>を使えば変更できます。</p>
<p><code>PORT=8080 spr api.yaml</code></p>
<p>あとはファイルを編集するたびに画面も更新されます。</p>
<h3 id="しくみ">しくみ</h3>
<p>簡潔に言うと次のようなしくみになっています。</p>
<ul>
<li>プレビューは<a href="https://github.com/swagger-api/swagger-ui">swagger-ui</a>を使っている</li>
<li>WebSocketを使って同期をしている</li>
<li>具体的にサーバ側でファイル変更を監視し、変更がある度にWebSocketでファイルの中身を送信</li>
</ul>
<h3 id="工夫点">工夫点</h3>
<h4 id="ポート">ポート</h4>
<p>swagger-uiはcdnを使えば、特に実ファイルをこちらで要しなくて良いので今回はそのまま次のようにimportして使っています。</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;text/css&#34;</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/3.41.1/swagger-ui.css&#34;</span> <span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/3.41.1/swagger-ui-bundle.js&#34;</span><span class="p">&gt;</span> <span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/3.41.1/swagger-ui-standalone-preset.js&#34;</span><span class="p">&gt;</span> <span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></div><p>サーバでHTMLを返していますが、<code>index.html</code>ファイルを用意せずその中身をGoの文字リテラルに入れています。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">indexHTML</span> <span class="p">=</span> <span class="s">`
</span><span class="s">&lt;!DOCTYPE html&gt;
</span><span class="s">&lt;html lang=&#34;ja&#34;&gt;
</span><span class="s">&lt;head&gt;
</span><span class="s">  &lt;meta charset=&#34;UTF-8&#34;&gt;
</span><span class="s">  &lt;title&gt;mpr&lt;/title&gt;
</span><span class="s">&lt;/head&gt;
</span><span class="s">  ...
</span><span class="s">&lt;/html&gt;
</span><span class="s">`</span>

<span class="o">...</span>

<span class="nx">port</span> <span class="o">:=</span> <span class="s">&#34;9999&#34;</span>
<span class="k">if</span> <span class="nx">p</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getenv</span><span class="p">(</span><span class="s">&#34;PORT&#34;</span><span class="p">);</span> <span class="nx">p</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
	<span class="nx">port</span> <span class="p">=</span> <span class="nx">p</span>
<span class="p">}</span>
<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">body</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="nx">indexHTML</span><span class="p">,</span> <span class="nx">port</span><span class="p">)</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">body</span><span class="p">))</span>
	<span class="k">return</span>
<span class="p">})</span>
</code></pre></div><p>なぜそうしているかというと…
WebSocketを使ってサーバと通信しているので、サーバのポートを自由に変更できるようにするなら画面側でもちゃんとポートも変更する必要があります。
<code>index.html</code>としてファイルを切り出すとポート変更を合わせられないので、文字リテラルとして定義してポートの部分を変えられうようにしています。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="nx">indexHTML</span><span class="p">,</span> <span class="nx">port</span><span class="p">)</span>
</code></pre></div><p>そして、文字リテラルにしたことでファイルを埋め込む必要がないのでシングルバイナリで動きます。</p>
<h4 id="ファイル監視">ファイル監視</h4>
<p>ファイル監視は<a href="https://github.com/fsnotify/fsnotify">fsnotify</a>というパッケージを使っています。既存のパッケージがあるしファイル監視なんてさくっと動くでしょと思っていました。 しかし、ここでやっかいなことが起たのです。
Vimでファイルを編集して保存すると変更ではなく、リネームはパーミッション変更といったイベントをキャッチしちゃっていました。これだとVimでファイルを保存するたびに複数回イベントをキャッチして、その度にファイルの中身を読み取るってWebSocketで送信してしまいます。</p>
<pre><code>2021/02/05 21:58:04 event: &quot;testdata/api.yaml&quot;: RENAME
2021/02/05 21:58:04 event: &quot;testdata/api.yaml&quot;: CHMOD
2021/02/05 21:58:04 event: &quot;testdata/api.yaml&quot;: REMOVE
</code></pre><p>fsnotifyはちゃんと起きたイベントをャッチしているだけなので問題ないですが、
Vimのファイル保存のしくみがファイルを直接書き換えないようになっているので実装で回避するしかない状態でした。
次に考えたのポーリングの案で、500ミリ秒でファイルの更新日を取得して前回と変更があった場合のみWebSocketで送信する実装です。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">fi</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Stat</span><span class="p">(</span><span class="nx">fileName</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>
<span class="nx">old</span> <span class="o">:=</span> <span class="nx">fi</span><span class="p">.</span><span class="nf">ModTime</span><span class="p">()</span>

<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>

		<span class="nx">fi</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Stat</span><span class="p">(</span><span class="nx">fileName</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">now</span> <span class="o">:=</span> <span class="nx">fi</span><span class="p">.</span><span class="nf">ModTime</span><span class="p">()</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">old</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">old</span> <span class="p">=</span> <span class="nx">now</span>

			<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;update&#34;</span><span class="p">)</span>
			<span class="nx">b</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="nx">msg</span> <span class="o">&lt;-</span> <span class="nx">b</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}()</span>
</code></pre></div><p>これでやりたいことは一応できたんですが、不要なI/Oが定期的に発生するのは納得行かず悶々としていました。
ちょうどTwitterでfsnotifyについてつぶやいていたところ、mattnさんからアドバイスをいただきました。</p>
<p><a href="https://twitter.com/mattn_jp/status/1356280779353907200">https://twitter.com/mattn_jp/status/1356280779353907200</a></p>
<p>そして、上記のアドバイスを元に以下のように実装したら期待通りに動きました。（感謝）
ポーリング実装の前に<code>sync.Once</code>は一応試したんですが、書き方が良くなかったようで、参考のコードを見て理解しました。（多分）</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">once</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">event</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">watcher</span><span class="p">.</span><span class="nx">Events</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>

			<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
					<span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
					<span class="k">if</span> <span class="nx">filepath</span><span class="p">.</span><span class="nf">Base</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span> <span class="o">==</span> <span class="nx">filepath</span><span class="p">.</span><span class="nf">Base</span><span class="p">(</span><span class="nx">fileName</span><span class="p">)</span> <span class="p">{</span>
						<span class="nx">fi</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Stat</span><span class="p">(</span><span class="nx">fileName</span><span class="p">)</span>
						<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
							<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
							<span class="k">return</span>
						<span class="p">}</span>
						<span class="nx">now</span> <span class="o">:=</span> <span class="nx">fi</span><span class="p">.</span><span class="nf">ModTime</span><span class="p">()</span>
						<span class="k">if</span> <span class="p">!</span><span class="nx">old</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span> <span class="p">{</span>
							<span class="nx">old</span> <span class="p">=</span> <span class="nx">now</span>

							<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;update&#34;</span><span class="p">)</span>
							<span class="nx">b</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">)</span>
							<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
								<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
								<span class="k">return</span>
							<span class="p">}</span>
							<span class="nx">msg</span> <span class="o">&lt;-</span> <span class="nx">b</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">})</span>
				<span class="nx">once</span> <span class="p">=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span><span class="p">{}</span>
			<span class="p">}()</span>
		<span class="k">case</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">watcher</span><span class="p">.</span><span class="nx">Errors</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}()</span>
</code></pre></div><h2 id="まとめ">まとめ</h2>
<p>ファイル監視周りは紆余曲折がありましたが、<code>sync.Once</code>とdelayを入れるテクニックとVimのファイル保存のしくみを知れて良かったです。
正直こんなに苦戦るとは思わなかったんで、まだまだ精進せねばなという気持ちです。がんばります！</p>
]]></content></item><item><title>Goの宣言済みの識別子は再宣言できる</title><link>https://skanehira.github.io/blog/posts/20210113-go-identifiers-redeclared/</link><pubDate>Wed, 13 Jan 2021 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20210113-go-identifiers-redeclared/</guid><description>最近コツコツとGoの仕様書を日本語に翻訳しています。 その中で識別子について分かったことがあるので、それについてまとめた記事になります。 識別子</description><content type="html"><![CDATA[<p>最近コツコツとGoの<a href="https://golang.org/ref/spec">仕様書</a>を日本語に<a href="https://github.com/skanehira/blog/pull/4">翻訳</a>しています。
その中で識別子について分かったことがあるので、それについてまとめた記事になります。</p>
<h2 id="識別子とは">識別子とは</h2>
<p>Goでは<a href="https://golang.org/ref/spec#Identifiers">識別子</a>という概念があります。</p>
<pre><code>Identifiers name program entities such as variables and types.
An identifier is a sequence of one or more letters and digits.
The first character in an identifier must be a letter.
</code></pre><p>これを意訳すると<code>識別子（文字や数字）を使って、変数や型といったプログラムの構成要素に名前を付けることができます。</code>になります。
たとえば<code>name := &quot;gorilla&quot;</code>の<code>name</code>は識別子、といった感じです。</p>
<p>この識別子は事前に宣言されているものがいくつかあり、それが次になっています。</p>
<p><strong><a href="https://golang.org/ref/spec#Predeclared_identifiers">事前宣言された識別子</a></strong></p>
<pre><code>Types:
	bool byte complex64 complex128 error float32 float64
	int int8 int16 int32 int64 rune string
	uint uint8 uint16 uint32 uint64 uintptr

Constants:
	true false iota

Zero value:
	nil

Functions:
	append cap close complex copy delete imag len
	make new panic print println real recover
</code></pre><p>この宣言済みの識別子のスコープは<code>universe block</code>と呼ばれる一番外側のスコープで宣言されています。
詳細は<a href="https://motemen.github.io/go-for-go-book/#%E3%83%A6%E3%83%8B%E3%83%90%E3%83%BC%E3%82%B9%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97">こちら</a>を参照ください。</p>
<h2 id="宣言済みの識別子は再宣言できる">宣言済みの識別子は再宣言できる</h2>
<p>Goでは宣言済の識別子を上書きできます。たとえば次のコードはOKです。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kc">true</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="nb">println</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// false
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>これは<a href="https://golang.org/ref/spec#Declarations_and_scope">宣言とスコープ</a>で次のように明言されています。</p>
<pre><code>An identifier declared in a block may be redeclared in an inner block.
</code></pre><p>つまり、外側のスコープ（<code>universe block</code>)で宣言された識別子（<code>true</code>や<code>false</code>)を内側のスコープ（上記の例でいうと<code>main</code>関数内）で再宣言されたということです。
次の例も同様に<code>{}</code>内で<code>int</code>を再宣言しています。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="o">:=</span> <span class="s">&#34;a&#34;</span>
		<span class="nb">println</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="c1">// a
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nb">println</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="c1">// 1
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h2 id="最後に">最後に</h2>
<p>Goでは型などは予約語ではなく識別子、そして識別子は再宣言可能で<code>true := false</code>が有効になるのは意外でした。
なぜ識別子を予約語にしていないのかわからないんですが、仕様書を読んでいく内にこの疑問も解決できるかもしれないので引き続き頑張って翻訳しつつ理解していきます。</p>
]]></content></item><item><title>2020年の振り返りと2021年の目標</title><link>https://skanehira.github.io/blog/posts/20210105-look-back-2020/</link><pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20210105-look-back-2020/</guid><description>あけましておめでとうございます。 ちょっと遅めですが、2020年の振り返りと2021年の目標について整理しました。 2020年はコロナの影響でい</description><content type="html"><![CDATA[<p>あけましておめでとうございます。
ちょっと遅めですが、2020年の振り返りと2021年の目標について整理しました。</p>
<p>2020年はコロナの影響でいろいろはたいへんでしたが、無事乗り切ったので2021年も引き続き頑張っていこうと思います。</p>
<h2 id="2020年を振り返る">2020年を振り返る</h2>
<p><a href="https://skanehira.github.io/blog/posts/20191230-look-back-on-this-year/#%E6%9D%A5%E5%B9%B4%E3%81%AE%E7%9B%AE%E6%A8%99">2019年末</a>に次の目標を立てましたが、
一部のみ達成したという結果になりました。</p>
<table>
<thead>
<tr>
<th>目標</th>
<th>結果</th>
<th>補足</th>
</tr>
</thead>
<tbody>
<tr>
<td>プログラミング言語を作る</td>
<td>△</td>
<td>Go言語でパーサまで書いて満足してしまって<br>その後JSONのパーサと電卓を書いた</td>
</tr>
<tr>
<td>Goを補完なしでかけるようになる</td>
<td>○</td>
<td>Go以外も自動補完使わずに書くようになった</td>
</tr>
<tr>
<td>Goの講師をやる</td>
<td>○</td>
<td>無事、前編収録完了した</td>
</tr>
<tr>
<td>Goのカンファレンスに登壇する</td>
<td>☓</td>
<td>コロナの影響でなし</td>
</tr>
<tr>
<td>Vimのカンファレンスに登壇する</td>
<td>☓</td>
<td>コロナの影響でなし</td>
</tr>
<tr>
<td>HTTPサーバをスクラッチで作る</td>
<td>☓</td>
<td>着手していない</td>
</tr>
</tbody>
</table>
<p>プログラミング言語を作るのは、想像以上に難しかったのでJSONのパーサを書く、というところまでいったんレベルを落としていました。
Goで作るインタプリタの本もだいたい半分くらいまでは書いて理解した（多分）ので、それを活かしてJSONと電卓のパーサを書いていました。</p>
<p>HTTPサーバをスクラッチで作るのは、完全に意欲がなくなったので着手すらしていないです。
こういうのは、熱意が消えないうちにやるべきですね。..</p>
<p>2019年末に立てた目標以外にも、コロナの影響などもあり会社が潰れないように自分の中で1つのミッションを持っていました。
それは新人を育ていることです。</p>
<p>4月にチームを立ち上げて新人に技術や仕事のし方を教えていました。最大8人くらいの面倒を見ながら、ほかに4〜5チームのレビュー、実装の相談などを一人でこなしていました。</p>
<p>どれくらいの忙しさだったかというと、1人で3人分くらいの仕事をしていたという感じです。トイレに行く以外は常に全集中で仕事していました。
めちゃくちゃたいへんだったけど、そのおかげで体感的に2倍くらいキャパが広がったので良かったなと思っています。</p>
<p>そして忙しいの中でも、ものを作ったり記事を書いたりとスキルアップを頑張っていました。
2020年に作ったもの次の通りです。</p>
<table>
<thead>
<tr>
<th>OSS</th>
<th>概要</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/skanehira/preview-markdown.vim">skanehira/preview-markdown.vim</a></td>
<td>Vim上でMarkdownをプレビューするプラグイン</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/gh.vim">skanehira/gh.vim</a></td>
<td>Vim上でGitHubの機能を使うプラグイン</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/preview-uml.vim">skanehira/preview-uml.vim</a></td>
<td>Vim上でUMLをプレビューするプラグイン</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/code2img">skanehira/code2img</a></td>
<td>コード片を画像化するCLI</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/code2img.vim">skanehira/code2img.vim</a></td>
<td>code2imgのVimプラグイン</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/fk">skanehira/fk</a></td>
<td>プロセスをあいまい検索してkillするCLI</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/getpr">skanehira/getpr</a></td>
<td>コミットIDからGitHubのPRリンクを取得するCLI</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/getpr.vim">skanehira/getpr.vim</a></td>
<td>getprのVimプラグイン</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/mcp">skanehira/mcp</a></td>
<td>エディタを使って複数のファイルをコピーするCLI</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/clipboard-image">skanehira/clipboard-image</a></td>
<td>画像をクリップボードに書き込み/読み出すライブラリ</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/gyazo">skanehira/gyazo</a></td>
<td>Gyazoに画像をアップロードするCLI</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/gyazo.vim">skanehira/gyazo.vim</a></td>
<td>gyazoのVimプラグイン</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/beatbanana.vim">skanehira/beatbanana.vim</a></td>
<td>Vimでビートマニアをするプラグイン（未完成）</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/amzn-url-shorter">skanehira/amzn-url-shorter</a></td>
<td>AmazonのURLを短縮するCLI</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/google-map.vim">skanehira/google-map.vim</a></td>
<td>VimからGoogle Mapsを開くプラグイン</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/go-dockerveth">skanehira/go-dockerveth</a></td>
<td>Dockerのコンテナがattachしているvethを表示するCLI</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/xj">skanehira/xj</a></td>
<td>XMLをJSONに変換するCLI</td>
</tr>
</tbody>
</table>
<p>こうやってみると、今年はかなりVimに偏っていてあまりGo周り研鑽していなかったなと思いました。
仕事ではコードを書くことはなくなって、プライベートでVimプラグインばっかり作っているので、そうなるよなぁと。..</p>
<h2 id="2021年の目標">2021年の目標</h2>
<p>2021も仕事が多忙なのは見えているので、あまり多くの目標を立てないようにします。
具体的に次の目標を今年中にクリアします。</p>
<table>
<thead>
<tr>
<th>目標</th>
<th>補足</th>
</tr>
</thead>
<tbody>
<tr>
<td>TOIEC700点を取る</td>
<td>将来英語圏で働くのが目標なので英語力をアップする</td>
</tr>
<tr>
<td>Go力アップ</td>
<td>OSSを作る、Goの仕様を読んでブログにまとめる</td>
</tr>
</tbody>
</table>
<p>英語に関してはすでに<a href="https://www.abceed.com">abceed</a>というアプリケーションと<a href="https://cdc-eigo365.com">生イングリッシュ</a>というサービスを使って日々勉強しています。
まだ成長の実感が全然ないんですが、コツコツ頑張っていきます。</p>
<h2 id="最後に">最後に</h2>
<p>2020はいろいろたいへんでしたが、2021も生き残れるように頑張っていきます。
人生は短いので、自分の夢のため日々全力を尽くしていきます。</p>
]]></content></item><item><title>Vimでビートマニアする</title><link>https://skanehira.github.io/blog/posts/20201225-vim-beatbanana/</link><pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20201225-vim-beatbanana/</guid><description>以前、トイレ入ってたら突然Vimでビートマニアしたくなったのでskanehira/beatbanana.vimというのを作っていました。 最近</description><content type="html"><![CDATA[<p>以前、トイレ入ってたら突然Vimでビートマニアしたくなったので<a href="https://github.com/skanehira/beatbanana.vim">skanehira/beatbanana.vim</a>というのを作っていました。
最近はGitHubのプラグイン<a href="https://github.com/skanehira/gh.vim">gh.vim</a>を作っているので、こちらの開発は止まっていますが、少しその話を書いていこうと思います。</p>
<h2 id="どんな感じ">どんな感じ？</h2>
<p>作りかけですが、こんな感じです。</p>
<p><img src="https://storage.googleapis.com/zenn-user-upload/qnf3fo9dghqm54qaq6dg33z42za9" alt=""></p>
<p>上からブロックがランダムで降ってくるので、<code>A~L</code>のキーを使ってジャストヒットをしていけるレベルにはなっています。
現時点ではブロックはランダム生成ですが、これからはサウンド機能と譜面編集機能を実装していく予定です。
この2つが完成すれば、おおよそ遊べるようにはなると思います。</p>
<h2 id="どんなしくみ">どんなしくみ？</h2>
<p>ブロックの生成とはVimの<code>popup window</code>を使っています。こちらは<code>timer_start()</code>を使ってランダムに生成しています。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">make_block</span><span class="p">(</span><span class="nx">opt</span><span class="p">,</span> <span class="nx">timer</span><span class="p">)</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">timer_start</span><span class="p">(</span><span class="nx">rand</span><span class="p">(</span><span class="nx">srand</span><span class="p">())</span> % <span class="m">1000</span><span class="p">,</span> <span class="k">function</span><span class="p">(</span><span class="s1">&#39;s:new_block&#39;</span><span class="p">,</span> [<span class="nx">a</span>:<span class="nx">opt</span>]<span class="p">))</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span><span class="err">
</span><span class="err"></span>（<span class="nx">中略</span>）<span class="err">
</span><span class="err"></span>  <span class="nx">for</span> <span class="nx">i</span> <span class="nx">in</span> <span class="nx">range</span><span class="p">(</span><span class="m">8</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="k">let</span> <span class="nx">press_key</span> <span class="p">=</span> <span class="nx">s</span>:<span class="nx">bottom_bar_keys</span>[<span class="nx">i</span>]<span class="err">
</span><span class="err"></span>    <span class="k">let</span> <span class="nx">opt</span> <span class="p">=</span> {<span class="err">
</span><span class="err"></span>          \ <span class="s1">&#39;press_key&#39;</span>: <span class="nx">press_key</span><span class="p">,</span><span class="err">
</span><span class="err"></span>          \ <span class="s1">&#39;col_len&#39;</span>: <span class="nx">col_len</span><span class="p">,</span><span class="err">
</span><span class="err"></span>          \ <span class="s1">&#39;col_pos&#39;</span>: <span class="nx">col_pos</span><span class="p">,</span><span class="err">
</span><span class="err"></span>          \ }<span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">s</span>:<span class="nx">make_bottom_block</span><span class="p">(</span><span class="nx">opt</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">exe</span> <span class="nx">printf</span><span class="p">(</span><span class="s1">&#39;nnoremap &lt;silent&gt; &lt;buffer&gt; %s :call &lt;SID&gt;press_bottom_bar(&#34;%s&#34;)&lt;CR&gt;&#39;</span><span class="p">,</span> <span class="nx">press_key</span><span class="p">,</span> <span class="nx">press_key</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">timer_start</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span> <span class="k">function</span><span class="p">(</span><span class="s1">&#39;s:make_block&#39;</span><span class="p">,</span> [<span class="nx">opt</span>]<span class="p">),</span> {<span class="s1">&#39;repeat&#39;</span>: <span class="m">-1</span>}<span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="k">let</span> <span class="nx">col_pos</span> <span class="p">+=</span> <span class="p">(</span><span class="nx">col_len</span> <span class="p">+</span> <span class="m">4</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="nx">endfor</span><span class="err">
</span></code></pre></div><p>ちなみに、Vim scriptの関数を非同期（操作をブロックしない）で実行する関数がないですが、<code>timer_start(0, f)</code>というふうに使うと、操作はブロックされないので擬似的に非同期処理が可能です。
コレを使うことで、ブロックが降ってくる処理をしながらキー押下のイベントを拾って判定処理を行えます。</p>
<p>ブロックが降ってくるのは<code>popup window</code>のポジションを<code>timer_start</code>を使って繰り返し+1していきます。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">move_block_down</span><span class="p">(</span><span class="nx">winid</span><span class="p">,</span> <span class="nx">press_key</span><span class="p">,</span> <span class="nx">timer</span><span class="p">)</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">opt</span> <span class="p">=</span> <span class="nx">popup_getpos</span><span class="p">(</span><span class="nx">a</span>:<span class="nx">winid</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="k">if</span> <span class="nx">opt</span>.<span class="nx">line</span> <span class="nx">is</span># <span class="nx">s</span>:<span class="nx">winheight</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">timer_stop</span><span class="p">(</span><span class="nx">a</span>:<span class="nx">timer</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">popup_close</span><span class="p">(</span><span class="nx">a</span>:<span class="nx">winid</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">s</span>:<span class="nx">delete_block_winid</span><span class="p">(</span><span class="nx">a</span>:<span class="nx">press_key</span><span class="p">,</span> <span class="nx">a</span>:<span class="nx">winid</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">return</span><span class="err">
</span><span class="err"></span>  <span class="k">endif</span><span class="err">
</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">opt</span>.<span class="nx">line</span> <span class="p">+=</span> <span class="m">1</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">popup_move</span><span class="p">(</span><span class="nx">a</span>:<span class="nx">winid</span><span class="p">,</span> <span class="nx">opt</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span><span class="err">
</span><span class="err"></span>（<span class="nx">中略</span>）<span class="err">
</span><span class="err"></span><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">new_block</span><span class="p">(</span><span class="nx">opt</span><span class="p">,</span> <span class="nx">timer</span><span class="p">)</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">text</span> <span class="p">=</span> <span class="nx">s</span>:<span class="nx">make_block_text</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="nx">a</span>:<span class="nx">opt</span>.<span class="nx">col_len</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">winid</span> <span class="p">=</span> <span class="nx">popup_create</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> {<span class="err">
</span><span class="err"></span>        \ <span class="s1">&#39;col&#39;</span>: <span class="nx">a</span>:<span class="nx">opt</span>.<span class="nx">col_pos</span><span class="p">,</span><span class="err">
</span><span class="err"></span>        \ <span class="s1">&#39;line&#39;</span>: <span class="m">1</span><span class="p">,</span><span class="err">
</span><span class="err"></span>        \ <span class="s1">&#39;minwidth&#39;</span>: <span class="nx">strlen</span><span class="p">(</span><span class="nx">text</span><span class="p">),</span><span class="err">
</span><span class="err"></span>        \ }<span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">win_execute</span><span class="p">(</span><span class="nx">winid</span><span class="p">,</span> <span class="s1">&#39;syntax match beatbanana_bar /0/&#39;</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">timer_start</span><span class="p">(</span><span class="m">60</span><span class="p">,</span> <span class="k">function</span><span class="p">(</span><span class="s2">&#34;s:move_block_down&#34;</span><span class="p">,</span> [<span class="nx">winid</span><span class="p">,</span> <span class="nx">a</span>:<span class="nx">opt</span>.<span class="nx">press_key</span>]<span class="p">),</span> {<span class="err">
</span><span class="err"></span>        \ <span class="s1">&#39;repeat&#39;</span>: <span class="m">-1</span><span class="p">,</span><span class="err">
</span><span class="err"></span>        \ }<span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">add</span><span class="p">(</span><span class="nx">s</span>:<span class="nx">bar_winid_set</span>[<span class="nx">a</span>:<span class="nx">opt</span>.<span class="nx">press_key</span>]<span class="p">,</span> <span class="nx">winid</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span></code></pre></div><p>判定処理ですが、簡単に説明すると下部のバーを押したときのキーを、降りてくるブロックが持っているキーが一致しているかどうかを確認したうえで位置が一致しているかどうかを確認しています。
たとえば<code>J</code>のキーの列には<code>J</code>のキーだよという情報を持ったブロックが降ってくるので、そのブロックからキーを取り出して、今押しているキーと一致しているかどうかを確認しているという感じです。</p>
<p>細いロジックはコードを読んでてみてください。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">collision_detection</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">winids</span> <span class="p">=</span> <span class="nx">s</span>:<span class="nx">bar_winid_set</span>[<span class="nx">a</span>:<span class="nx">key</span>]<span class="err">
</span><span class="err"></span>  <span class="k">if</span> <span class="nx">empty</span><span class="p">(</span><span class="nx">winids</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">return</span> <span class="m">0</span><span class="err">
</span><span class="err"></span>  <span class="k">endif</span><span class="err">
</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">bar_winid</span> <span class="p">=</span> <span class="nx">winids</span>[<span class="m">0</span>]<span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">opt</span> <span class="p">=</span> <span class="nx">popup_getpos</span><span class="p">(</span><span class="nx">bar_winid</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>  <span class="nx">return</span> <span class="nx">opt</span>.<span class="nx">line</span> <span class="nx">is</span># <span class="nx">s</span>:<span class="nx">winheight</span> <span class="p">||</span> <span class="nx">opt</span>.<span class="nx">line</span> <span class="nx">is</span># <span class="nx">s</span>:<span class="nx">winheight</span> <span class="p">-</span> <span class="m">1</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">press_bottom_bar</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">winid</span> <span class="p">=</span> <span class="nx">s</span>:<span class="nx">bottom_bar_winid_set</span>[<span class="nx">a</span>:<span class="nx">key</span>]<span class="err">
</span><span class="err"></span>  <span class="k">if</span> <span class="nx">s</span>:<span class="nx">collision_detection</span><span class="p">(</span><span class="nx">a</span>:<span class="nx">key</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">win_execute</span><span class="p">(</span><span class="nx">winid</span><span class="p">,</span> <span class="s1">&#39;syntax match beatbanana_hit_good /1/&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="k">else</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">win_execute</span><span class="p">(</span><span class="nx">winid</span><span class="p">,</span> <span class="s1">&#39;syntax match beatbanana_hit /1/&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="k">endif</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">timer_start</span><span class="p">(</span><span class="m">150</span><span class="p">,</span> <span class="k">function</span><span class="p">(</span><span class="s1">&#39;s:restore_bottom_bar_highlight&#39;</span><span class="p">,</span> [<span class="nx">winid</span>]<span class="p">))</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span></code></pre></div><h2 id="さいごに">さいごに</h2>
<p>まだまだ作っている最中で、まともに遊べるかと言われると怪しいですが、できたらちゃんとプラグイン化して公開したいと思います。
ご期待くださいー</p>
]]></content></item><item><title>Neovimを始めた話</title><link>https://skanehira.github.io/blog/posts/20201210-vim-start-use-nvim/</link><pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20201210-vim-start-use-nvim/</guid><description>初めに 11月中旬くらいからNeovimを使い始めました。 Neovim自体は以前から知っていたが、自分が普段作っているプラグインがVimでしか</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>11月中旬くらいからNeovimを使い始めました。
Neovim自体は以前から知っていたが、自分が普段作っているプラグインがVimでしか動かないことや、Vimでだいたい満足しているのでなかなか使おうって気になれませんでした。</p>
<p>そこで<a href="https://github.com/skanehira/gh.vim">gh.vim</a>というプラグインのNeovim対応をするため、Neovimをビルドしてから少しずつNeovimを使うようになりました。
今日はVimを使ってきた筆者がNeovimを少し使った感想の話をしていきます。</p>
<h2 id="neovimとvimの違い">NeovimとVimの違い</h2>
<p>Vimは後方互換を大事にしているので劇的な変化があまりないのに対して、
Neovimは時代に合わせてよりモダンな技術を積極的に取り入れる、というスタンスの違いがあるように感じています。</p>
<p>Neovimのモダンな技術といえば次でしょうか。（ほかにもっとあるかもしれないが…）</p>
<ul>
<li>ターミナル</li>
<li>LSP（builtin）</li>
<li>リモートプラグイン</li>
<li>Floating windows</li>
</ul>
<p>実際まだNeovimを使って1ヵ月も経っていないんですが、気になるVimとの差異の部分について説明していきます。</p>
<h3 id="ターミナル">ターミナル</h3>
<p>NeovimとVimのターミナルの挙動が割と違っていて、Neovimの場合は<code>:terminal</code>で現在のバッファをそのまま使います。
対してVimは<code>split</code>してから画面上部にターミナルが表示さるような動きで、現在のバッファを使うかどうかはオプションで指定できます。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="p">:</span><span class="nx">terminal</span> <span class="p">++</span><span class="nx">curwin</span><span class="err">
</span></code></pre></div><p>Neovimで現在のバッファを使いたくないときは次のように、で新しいバッファを開いてからターミナルを実行できます。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim">`:<span class="nx">new</span> <span class="nx">term</span>:<span class="sr">//</span>${<span class="nx">SHELL</span>}`<span class="err">
</span></code></pre></div><p>NeovimのターミナルはNormalモードで開始するためそのままでは入力できないので、
そのままターミナルを使いたい場合は次の設定が必要です。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="nx">augroup</span> <span class="nx">neovim</span><span class="p">-</span><span class="nx">terminal</span><span class="err">
</span><span class="err"></span>  <span class="nx">au</span><span class="p">!</span><span class="err">
</span><span class="err"></span>  <span class="nx">au</span> <span class="nx">TermOpen</span> * <span class="nx">startinsert</span><span class="err">
</span><span class="err"></span><span class="nx">augroup</span> <span class="nx">END</span><span class="err">
</span></code></pre></div><p>これが結構使いづらいなと感じたところでした。</p>
<p>また、NeovimではターミナルのNormalモードは<code>&lt;C-\&gt;&lt;C-N&gt;</code>というとても打ちづらい（JISキーボード勢なので）キーマップになっています。
Vimでは<code>&lt;C-w&gt;&lt;C-N&gt;</code>になって打ちやすい分、ターミナルで<code>&lt;C-w&gt;</code>をつかって単語を消せないというツライ部分があります。
一応Vimでは<code>termwinkey</code>で<code>&lt;C-w&gt;</code>を変えられますが…</p>
<p>こんな感じでお互い一長一短なところがあります。</p>
<h3 id="カーソル">カーソル</h3>
<p>Neovimでは挿入モードでカーソルの形が<code>|</code>に変わります。これは個人的にわかりやすくて良いなと思いました。
これVimでも設定で再現できないかなと考えていますが、多分難しいでしょうね…</p>
<h3 id="vim-script">Vim script</h3>
<p>Neovimの方がちょっと処理速度が速いようです。
体感ではありますが、NeovimはVimより動作が軽快な感触があります。</p>
<p>実際次のscriptを使って、処理時間を図ってみました。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">fun</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">sum</span><span class="p">()</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">sum</span> <span class="p">=</span> <span class="m">0</span><span class="err">
</span><span class="err"></span>  <span class="nx">for</span> <span class="nx">i</span> <span class="nx">in</span> <span class="nx">range</span><span class="p">(</span><span class="m">2999999</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="k">let</span> <span class="nx">sum</span><span class="p">+=</span><span class="nx">i</span><span class="err">
</span><span class="err"></span>  <span class="nx">endfor</span><span class="err">
</span><span class="err"></span><span class="nx">endfun</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">start</span> <span class="p">=</span> <span class="nx">reltime</span><span class="p">()</span><span class="err">
</span><span class="err"></span><span class="nx">for</span> <span class="nx">_</span> <span class="nx">in</span> <span class="nx">range</span><span class="p">(</span><span class="m">5</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">s</span>:<span class="nx">sum</span><span class="p">()</span><span class="err">
</span><span class="err"></span><span class="nx">endfor</span><span class="err">
</span><span class="err"></span><span class="nx">echo</span> <span class="nx">reltimestr</span><span class="p">(</span><span class="nx">reltime</span><span class="p">(</span><span class="nx">start</span><span class="p">))</span><span class="err">
</span></code></pre></div><p>どうやら体感が正しかったようです。Neovimのが約2秒弱速かったです。</p>
<table>
<thead>
<tr>
<th></th>
<th>秒数</th>
</tr>
</thead>
<tbody>
<tr>
<td>Vim</td>
<td>19.632893</td>
</tr>
<tr>
<td>Neovim</td>
<td>17.632039</td>
</tr>
</tbody>
</table>
<h3 id="関数">関数</h3>
<p>VimにあってNeovimにない関数や、同じような機能だけどIFが異なっている関数がいくつかありました。
こういった差異が結構プラグイン作者の頭を悩ませるなぁとプラグインを作っていて思いました。</p>
<p>たとえば、<code>win_execute()</code>という関数はNeovimにはなく、
特定のWindowで何か処理を行うには<code>win_gotoid()</code>で一度ウィンドウに移動しなければ行けないです。
また、<code>job</code>機能はVim/NeovimともにありますがIFが異なっているので、これもまたやっかいです。</p>
<p>このように、使用感はさほど変わらないけど、少し深いところに足を踏み込むと異なるところがちょいちょいあります。
両方で動作するプラグインを作っているダークパワーを身にまとっている人はやはりすごいなとあらためて思いました。</p>
<h2 id="最後に">最後に</h2>
<p>一部ではありますが、Neovimについて筆者が感じていることを書きました。
もうしばらくNeovim/Vimを交互に使ってみたいと思っています。</p>
<p>最近ではNeovimがLuaに舵を切ったり、VimはVim9 scriptをガシガシ作ったりと、お互い違う道を歩み始めた感がありますが、
Vim/Neovimの良さはそれぞれあるので、みなさんも両方使ってみると新しい世界が見えるかもしれません。</p>
<p>では、よいVim/Neovimライフを。</p>
]]></content></item><item><title>Vim上でGitHubのファイルツリーを表示する話</title><link>https://skanehira.github.io/blog/posts/20201209-vim-github-file-tree/</link><pubDate>Wed, 09 Dec 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20201209-vim-github-file-tree/</guid><description>初めに 先日、gh.vimにファイルツリー機能を実装しました。 Vim上でリポジトリのファイルツリーを見ることができる機能です。 その周りの話をし</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>先日、<a href="https://github.com/skanehira/gh.vim">gh.vim</a>にファイルツリー機能を実装しました。
Vim上でリポジトリのファイルツリーを見ることができる機能です。
その周りの話をしていきます。</p>
<h2 id="やり方">やり方</h2>
<p><code>:30vnew gh://:owner/:repo/:branch|:tree_sha</code>を実行すると、ファイルツリーを開けます。
<code>:repo</code>の後はブランチ名、もしくはコミットハッシュを指定できます。
また、<code>ghe</code>でカーソル上にあるファイルの中身を見ることができます。</p>
<p><img src="https://i.imgur.com/HC7f6b5.gif" alt=""></p>
<h2 id="実装">実装</h2>
<p>GitHubには<a href="https://docs.github.com/en/free-pro-team@latest/rest/reference/git#get-a-tree">Trees</a>APIが用意されていて、それをたたくとファイルとディレクトリの情報を取得できます。</p>
<p>しかし、このレスポンスのではデータ構造が入れ子になっておらず、<code>path</code>にリポジトリのルートディレクトリからのパス情報などが配列になっています。
たとえば次のディレクトリ構成だった場合</p>
<pre><code>.
├── README.md
├── doc
│   └── gh.txt
└── plugin
    └── gh.vim
</code></pre><p>これが次のようなレスポンスになります。</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;sha&#34;</span><span class="p">:</span> <span class="s2">&#34;xxx&#34;</span><span class="p">,</span>
  <span class="nt">&#34;url&#34;</span><span class="p">:</span> <span class="s2">&#34;xxx&#34;</span><span class="p">,</span>
  <span class="nt">&#34;tree&#34;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">&#34;path&#34;</span><span class="p">:</span> <span class="s2">&#34;README.md&#34;</span><span class="p">,</span>
      <span class="err">...</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;path&#34;</span><span class="p">:</span> <span class="s2">&#34;doc&#34;</span><span class="p">,</span>
      <span class="err">...</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;path&#34;</span><span class="p">:</span> <span class="s2">&#34;doc/gh.txt&#34;</span><span class="p">,</span>
      <span class="err">...</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;path&#34;</span><span class="p">:</span> <span class="s2">&#34;plugin&#34;</span><span class="p">,</span>
      <span class="err">...</span>
    <span class="p">}</span>
    <span class="p">{</span>
      <span class="nt">&#34;path&#34;</span><span class="p">:</span> <span class="s2">&#34;plugin/gh.vim&#34;</span><span class="p">,</span>
      <span class="err">...</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
</code></pre></div><p>ツリーを表現するにはフラットなデータ構造ではなく、ネストしたデータ構造のが都合良いので、これらの<code>path</code>を元に次のようなデータ構造に変換する必要があります。</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;gh.vim&#34;</span><span class="p">,</span>
  <span class="nt">&#34;path&#34;</span><span class="p">:</span> <span class="s2">&#34;gh.vim&#34;</span><span class="p">,</span>
  <span class="nt">&#34;children&#34;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;README.md&#34;</span><span class="p">,</span>
      <span class="nt">&#34;path&#34;</span><span class="p">:</span> <span class="s2">&#34;gh.vim/README.md&#34;</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;doc&#34;</span><span class="p">,</span>
      <span class="nt">&#34;path&#34;</span><span class="p">:</span> <span class="s2">&#34;gh.vim/doc&#34;</span><span class="p">,</span>
      <span class="nt">&#34;children&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;gh.txt&#34;</span><span class="p">,</span>
          <span class="nt">&#34;path&#34;</span><span class="p">:</span> <span class="s2">&#34;gh.vim/doc/gh.txt&#34;</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;plugin&#34;</span><span class="p">,</span>
      <span class="nt">&#34;path&#34;</span><span class="p">:</span> <span class="s2">&#34;gh.vim/plugin&#34;</span><span class="p">,</span>
      <span class="nt">&#34;children&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;gh.vim&#34;</span><span class="p">,</span>
          <span class="nt">&#34;path&#34;</span><span class="p">:</span> <span class="s2">&#34;gh.vim/plugin/gh.vim&#34;</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
</code></pre></div><p><code>gh.vim</code>では<code>s:make_node</code>という関数で、1ファイルずつ、上記のデータ構造を構築しています。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">make_node</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">file</span><span class="p">)</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">paths</span> <span class="p">=</span> <span class="nx">split</span><span class="p">(</span><span class="nx">a</span>:<span class="nx">file</span>.<span class="nx">path</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">parent_path</span> <span class="p">=</span> <span class="nx">join</span><span class="p">(</span><span class="nx">paths</span>[:<span class="m">-2</span>]<span class="p">,</span> <span class="s2">&#34;/&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">tree</span> <span class="p">=</span> <span class="nx">a</span>:<span class="nx">tree</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">item</span> <span class="p">=</span> {<span class="err">
</span><span class="err"></span>        \ <span class="s1">&#39;name&#39;</span>: <span class="nx">a</span>:<span class="nx">file</span>.<span class="nx">type</span> <span class="nx">is</span># <span class="s1">&#39;tree&#39;</span> ? <span class="nx">paths</span>[<span class="m">-1</span>] .. <span class="s1">&#39;/&#39;</span> : <span class="nx">paths</span>[<span class="m">-1</span>]<span class="p">,</span><span class="err">
</span><span class="err"></span>        \ <span class="s1">&#39;path&#39;</span>: <span class="nx">a</span>:<span class="nx">file</span>.<span class="nx">path</span><span class="p">,</span><span class="err">
</span><span class="err"></span>        \ <span class="s1">&#39;info&#39;</span>: <span class="nx">a</span>:<span class="nx">file</span><span class="p">,</span><span class="err">
</span><span class="err"></span>        \ <span class="s1">&#39;markable&#39;</span>: <span class="m">1</span><span class="p">,</span><span class="err">
</span><span class="err"></span>        \ }<span class="err">
</span><span class="err">
</span><span class="err"></span>  <span class="k">if</span> <span class="nx">a</span>:<span class="nx">file</span>.<span class="nx">type</span> <span class="nx">is</span># <span class="s1">&#39;tree&#39;</span><span class="err">
</span><span class="err"></span>    <span class="k">let</span> <span class="nx">item</span>[<span class="s1">&#39;children&#39;</span>] <span class="p">=</span> []<span class="err">
</span><span class="err"></span>    <span class="k">let</span> <span class="nx">item</span>[<span class="s1">&#39;state&#39;</span>] <span class="p">=</span> <span class="s1">&#39;close&#39;</span><span class="err">
</span><span class="err"></span>  <span class="k">endif</span><span class="err">
</span><span class="err">
</span><span class="err"></span>  <span class="k">if</span> <span class="nx">has_key</span><span class="p">(</span><span class="nx">b</span>:<span class="nx">tree_node_cache</span><span class="p">,</span> <span class="nx">parent_path</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">add</span><span class="p">(</span><span class="nx">b</span>:<span class="nx">tree_node_cache</span>[<span class="nx">parent_path</span>]<span class="p">,</span> <span class="nx">item</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">return</span><span class="err">
</span><span class="err"></span>  <span class="k">endif</span><span class="err">
</span><span class="err">
</span><span class="err"></span>  <span class="k">if</span> <span class="nx">exists</span><span class="p">(</span><span class="s1">&#39;tree.children&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">for</span> <span class="nx">node</span> <span class="nx">in</span> <span class="nx">tree</span>.<span class="nx">children</span><span class="err">
</span><span class="err"></span>      <span class="nx">call</span> <span class="nx">s</span>:<span class="nx">make_node</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">a</span>:<span class="nx">file</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">endfor</span><span class="err">
</span><span class="err"></span>  <span class="k">endif</span><span class="err">
</span><span class="err">
</span><span class="err"></span>  <span class="k">if</span> <span class="nx">tree</span>.<span class="nx">path</span> <span class="nx">is</span># <span class="nx">parent_path</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">add</span><span class="p">(</span><span class="nx">a</span>:<span class="nx">tree</span>.<span class="nx">children</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="k">let</span> <span class="nx">b</span>:<span class="nx">tree_node_cache</span>[<span class="nx">parent_path</span>] <span class="p">=</span> <span class="nx">a</span>:<span class="nx">tree</span>.<span class="nx">children</span><span class="err">
</span><span class="err"></span>  <span class="k">endif</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span></code></pre></div><p>基本的な処理の流れは次です。</p>
<ol>
<li><code>tree</code>（親要素）と、<code>file</code>（GitHubから取得した1ファイルの情報）を受け取る</li>
<li><code>file</code>の<code>path</code>から親パスを取得</li>
<li><code>tree</code>に追加するデータ<code>item</code>を作成</li>
<li><code>file</code>がディレクトリ（<code>a:file.type is# 'tree'</code>の部分）の場合は<code>tree</code>に<code>children</code>を追加</li>
<li>すでに<code>tree</code>に<code>children</code>がある場合は、子要素の数だけ再帰処理</li>
<li><code>tree</code>の<code>path</code>が<code>file</code>の親パスと一致した場合、<code>tree.children</code>に<code>file</code>を追加</li>
<li>これをAPIレスポンスの<code>tree</code>の配列分繰り返す</li>
</ol>
<p>ただ、このロジックではファイルの数とパスの深さと比例して再帰の回数がえげつない回数になるので、ファイル数が3000個くらいあるプロジェクトだとかなりと処理に時間がかかります。</p>
<p>そこですでに作成したノードをキャッシュして子要素の親パスがキャッシュにあったら、
キャッシュしたデータに追加することでパフォーマンスを改善しました。</p>
<p>それが次の部分のコードになります</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="c">&#34; キャッシュがあればキャッシュに要素を追加</span><span class="err">
</span><span class="err"></span><span class="k">if</span> <span class="nx">has_key</span><span class="p">(</span><span class="nx">b</span>:<span class="nx">tree_node_cache</span><span class="p">,</span> <span class="nx">parent_path</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">add</span><span class="p">(</span><span class="nx">b</span>:<span class="nx">tree_node_cache</span>[<span class="nx">parent_path</span>]<span class="p">,</span> <span class="nx">item</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="nx">return</span><span class="err">
</span><span class="err"></span><span class="k">endif</span><span class="err">
</span><span class="err">
</span><span class="err"></span>...<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">if</span> <span class="nx">tree</span>.<span class="nx">path</span> <span class="nx">is</span># <span class="nx">parent_path</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">add</span><span class="p">(</span><span class="nx">a</span>:<span class="nx">tree</span>.<span class="nx">children</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="c">  &#34; 作成済みの要素をキャッシュ</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">b</span>:<span class="nx">tree_node_cache</span>[<span class="nx">parent_path</span>] <span class="p">=</span> <span class="nx">a</span>:<span class="nx">tree</span>.<span class="nx">children</span><span class="err">
</span><span class="err"></span><span class="k">endif</span><span class="err">
</span></code></pre></div><h2 id="最後に">最後に</h2>
<p>キャッシュ戦略でいくぶんパフォーマンスが改善されたとはいえ、
<code>golang/go</code>といった巨大なプロジェクトのファイルツリーを開くのは時間がかかってしまいます。
より良いロジックがないか、年末あたりに模索してみたいと思います。</p>
<p><code>gh.vim</code>自体はファイルツリー以外にも、プロジェクトやGitHub Actionsをツリーでみたりできますので、
興味ある方は一度触ってみてください。Vim/Neovimともに動きます。</p>
]]></content></item><item><title>My Vim philosophy</title><link>https://skanehira.github.io/blog/posts/20201205-vim-my-philosophy/</link><pubDate>Sat, 05 Dec 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20201205-vim-my-philosophy/</guid><description>始めに 最近フォロワーさんに「なるべくプラグインに頼りすぎないように様にしているんですよね」って話したら、 「いつもプラグイン作っているからてっ</description><content type="html"><![CDATA[<h2 id="始めに">始めに</h2>
<p>最近フォロワーさんに「なるべくプラグインに頼りすぎないように様にしているんですよね」って話したら、
「いつもプラグイン作っているからてっきりプラグインをガンガン使っていると思ってた」といわれました。</p>
<p>あー、たしかにと思って、あらためて自分のVimへのこだわりについて整理したのでそれについて書いていきます。
タイトルは哲学と書いてありますが、まぁそんなに真面目な内容ではないです（笑）</p>
<h2 id="vimの特徴">Vimの特徴</h2>
<p>Vimはなんと言ってもkeybindが特徴的です。豊富なkeybindがあるので1つのキーボードでさまざまな操作を可能にします。
特にモーションとオペレーター（<code>ciw</code>など）がテキスト編集を強化していて、これを使いこなすだけで編集スピードが段違いです。</p>
<p>もうひとつはプラグインです。世の中にはたくさん便利なプラグインがあり、それらは標準機能では解決できない問題を解決してくれます。
そしてプラグインは自作が可能ですので、標準機能に不満があれば自分で作れます。
こういった拡張性が高いことで、Vimプラグインはたくさん作られていて、たくさん使っている人がいます。</p>
<h2 id="vimへのこだわり">Vimへのこだわり</h2>
<h3 id="プラグインに頼りすぎない">プラグインに頼りすぎない</h3>
<p>これは良い、これはだめといった厳密なラインがあるわけではないですが「Vimの標準機能で足りるのか」を初めに考えます。</p>
<p>そして標準で足りているなら、プラグインは導入しないようにしています。なぜならプラグインに頼りすぎるとVim自体を使えなくなってしまう可能性があるからです。
一般的に人間は現状満たされているならそれ以上改善をしようと思わないので、プラグインに目が行き過ぎるとVimの良さに気付けなくなってしまいます。</p>
<p>ぼくはVimを始めた当初はとりあえず<code>NERDTree</code>を入れて使っていましたが、素のVimでのファイルの開き方がわからなかったです。
自分で選んだエディタを使っているのに、そのエディタの標準機能を知らなくてファイルすら開けない、というのはあまりにも情けないなと思ったのは今も覚えています。
そういった理由もあって、プラグインをガンガン使っているわけではなく、標準機能だと厳しいなと思ったらプラグインを導入するようにしています。</p>
<p>また、これが一番重要ですが「編集の体感がかなり変わってしまう」プラグインもなるべく入れないようにしています。
たとえば、<a href="https://github.com/easymotion/vim-easymotion">vim-easymotion</a>というプラグインがありますが、これは入れないようにしています。
内心めっちゃ便利そうと思っていますが、縦横移動は検索<code>/</code>を使えばもの足りるし、これを入れてしまうとかなり依存してしまいそうだからです。</p>
<p>このように、ちゃんと自分が使っているエディタの機能を使った上でそれでも足りないものはプラグインを使って補完すれば良いと思っています
この「足りない」の基準は人それぞれなので明確なラインはないのですが、ぼくは「標準機能で賄えるかどうか」で決めています。</p>
<h3 id="編集ではなく周辺を強化">編集ではなく、周辺を強化</h3>
<p>ぼくがプラグインを作る理由はこれです。Vimを使っていると「すべてをVimで完結したくなる」という病気にかかります。（自分だけかもしれないが）
たとえば「GitHubのissueを作ったり、GitHub Actionsの結果を見たり」をVimで完結するために<a href="https://github.com/skanehira/gh.vim">gh.vim</a>というプラグインを作りしました。</p>
<p><img src="https://i.gyazo.com/503dfe0eba487449f19d1c93e248902c.png" alt=""></p>
<p>こういった普段使っているツールやサービスとVim間をシームレスつなげるためのプラグインを作っています。
基本的にVimの編集体系にあまり不満はないので、それ以外のところで作業が捗るようにプラグインを作っています。</p>
<p>以下が愛用している自作プラグインたちです。</p>
<table>
<thead>
<tr>
<th>プラグイン</th>
<th>概要</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/skanehira/gyazo.vim">gyazo.vim</a></td>
<td>Gayzoに画像をアップロード</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/docker.vim">docker.vim</a></td>
<td>Dockerを操作</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/gh.vim">gh.vim</a></td>
<td>GitHubを操作</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/translate.vim">translate.vim</a></td>
<td>Google翻訳</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/code2img.vim">code2img.vim</a></td>
<td>コード断片の画像化</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/getpr.vim">getpr.vim</a></td>
<td>GitHubのPRのリンクを取得</td>
</tr>
</tbody>
</table>
<h3 id="自動補完を使わない">自動補完を使わない</h3>
<p>これはどちらかというと、プログラマーとしてのこだわりです。</p>
<p>コーディングするとき自動補完を使っている方が多いと思います。ぼくも以前はそうでした。
しかし自動補完に頼りすぎてしまって、いざ自動補完が使えなくなったら、ググらないとまったくコードを書けませんでした。</p>
<p>そういった経験もあって自動補完を使おうのをやめて、手動補完（<code>&lt;C-x&gt;&lt;C-n&gt;</code>など）を使うようにしています。
最初はなかなか歯がゆいところがありましたが、今ではむしろ自動で補完が出てくるのは邪魔だなって感じています。
また、関数を覚えるようになってある程度何も見ず、コーディングできるようになりました。</p>
<p>自動補完はもちろんメリットがありますので、使わないほうが良いというわけではないです。
ただ、「自動補完がないとまともにコードを書けないならプログラマーって胸張って周りに言えないな」と思っています。
これは自分のこだわりであって、周りに対してそう思っているわけではないです。</p>
<h3 id="よりシンプルに">よりシンプルに</h3>
<p>最近、画面上に必要がない情報を出さないようにしています。
以前は<a href="https://github.com/itchyny/lightline.vim">lightline.vim</a>というプラグインを使って、ステータスラインにファイル名、ブランチ情報などを表示していました。
最近ではこれらの情報なくても困ることないなと思ったので、2年間ともにしてきたlightline.vimとお別れをしました。</p>
<p>現在では、次の設定をしています。</p>
<ul>
<li>行番号を非表示</li>
<li>ステータスラインを非表示</li>
<li>タブラインを非表示</li>
</ul>
<p>これで、だいぶ画面がスッキリしました。</p>
<p><img src="https://i.gyazo.com/95c08168947ed15e7e6fec62ae9284ce.png" alt=""></p>
<h2 id="まとめ">まとめ</h2>
<p>Vimを始めた当初はいろいろプラグインを入れたり、外見を変えたりと頑張っていましたが今ではいろいろと逆行しています。
正直これからどうなるのかわからないのですが、日々Vimでの生活を良くしていきたいと思っています。
せっかくなのでみなさんも年末にVimを大掃除してみると良いかもしれません。</p>
<p>では、良いお年を〜</p>
]]></content></item><item><title>VimでGitHubを操作するプラグインgh.vimの紹介</title><link>https://skanehira.github.io/blog/posts/20201203-introduce-gh-vim/</link><pubDate>Thu, 03 Dec 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20201203-introduce-gh-vim/</guid><description>始めに 最近GitHubのVimプラグインgh.vimというのを作っています。 issueやPR、プロジェクト、GitHub Actionsのステ</description><content type="html"><![CDATA[<h2 id="始めに">始めに</h2>
<p>最近GitHubのVimプラグイン<a href="https://github.com/skanehira/gh.vim">gh.vim</a>というのを作っています。
issueやPR、プロジェクト、GitHub ActionsのステータスなどをVim/Neovim上で確認、操作できます。
よい感じにいろいろな機能が入ったので、あらためてちゃんとプラグインを紹介したいと思います。</p>
<p><img src="https://i.gyazo.com/061eea10fef226b1dc104e24f0b6995c.png" alt=""></p>
<h3 id="機能">機能</h3>
<p>現時点では次の機能が実装されています。</p>
<table>
<thead>
<tr>
<th>カテゴリ</th>
<th>機能</th>
</tr>
</thead>
<tbody>
<tr>
<td>issue</td>
<td>一覧/作成/更新</td>
</tr>
<tr>
<td>issue comment</td>
<td>一覧/作成/更新</td>
</tr>
<tr>
<td>issue</td>
<td>open/close</td>
</tr>
<tr>
<td>pull request</td>
<td>一覧/パッチ（差分）</td>
</tr>
<tr>
<td>repository</td>
<td>一覧/README</td>
</tr>
<tr>
<td>project</td>
<td>一覧/カード・カラム一覧</td>
</tr>
<tr>
<td>actions</td>
<td>ワークフロー・ジョブステップ一覧/ジョブログ</td>
</tr>
<tr>
<td>bookmark</td>
<td>一覧/バッファを開く</td>
</tr>
</tbody>
</table>
<p><code>gh.vim</code>では<code>gh://xxx</code>といった仮想バッファのみ提供していて、Exコマンドは用意していません。なので一般的なプラグインとちょっと異なる使い方をします。
たとえば<code>gh://golang/go/issues?state=all</code>というバッファ名を開くと、そのバッファにissue一覧が表示され、キーマップが設定されます。</p>
<p>仮想バッファというのは、実際ファイルを作成せず一時的なバッファにデータを表示したり、キーマップを設定したりする手法です。
仮想バッファのみにした理由はこれまでにない形のプラグインを作ってみたかったからです。
あとは実装しやすさがあります。詳細については<a href="#%E4%BB%95%E7%B5%84%E3%81%BF">仕組み</a>の項で解説します。</p>
<p>現在<code>gh.vim</code>が提供している仮想バッファは次になります。大体機能ごとにバッファが別れています。</p>
<table>
<thead>
<tr>
<th>buffer</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>gh://:owner/:repo/issues[?state=open&amp;..]</code></td>
<td>issue一覧</td>
</tr>
<tr>
<td><code>gh://:owner/:repo/issues/:number</code></td>
<td>issue編集</td>
</tr>
<tr>
<td><code>gh://:owner/:repo/:branch/issues/new</code></td>
<td>新規issue作成</td>
</tr>
<tr>
<td><code>gh://:owner/:repo/issues/comments[?page=1&amp;..]</code></td>
<td>issueコメント一覧</td>
</tr>
<tr>
<td><code>gh://:owner/:repo/issues/comments/new</code></td>
<td>新規issueコメント作成</td>
</tr>
<tr>
<td><code>gh://:owner/repos</code></td>
<td>レポジトリ一覧</td>
</tr>
<tr>
<td><code>gh://user/repos</code></td>
<td>認証済みユーザリポジトリ一覧</td>
</tr>
<tr>
<td><code>gh://:owner/:repo/readme</code></td>
<td>リポジトリのREADME</td>
</tr>
<tr>
<td><code>gh://:owner/:repo/pulls[?state=open&amp;...]</code></td>
<td>PR一覧</td>
</tr>
<tr>
<td><code>gh://:owner/:repo/pulls/:number/diff</code></td>
<td>PRの差分</td>
</tr>
<tr>
<td><code>gh://:owner/:repo/projects</code></td>
<td>project一覧</td>
</tr>
<tr>
<td><code>gh://orgs/:org/projects</code></td>
<td>Organazationのproject一覧</td>
</tr>
<tr>
<td><code>gh://projects/:id/columns</code></td>
<td>projectのカラム一覧</td>
</tr>
<tr>
<td><code>gh://:owner/:repo/actions[?status=success&amp;...]</code></td>
<td>actionsステータス一覧</td>
</tr>
<tr>
<td><code>gh://bookmarks</code></td>
<td>ブックマーク一覧</td>
</tr>
</tbody>
</table>
<p>次に、機能の詳細について紹介していきます。</p>
<h4 id="issue機能">Issue機能</h4>
<p>issueの一覧や作成、編集、及びコメントの作成&amp;編集などを行えます。</p>
<p><img src="https://i.gyazo.com/19d67ef4bc621b5f9fe1a09609844284.gif" alt=""></p>
<p><strong>issue一覧</strong><br>
<code>gh://:owner/:repo/issues[?state=open&amp;...]</code>でissueの一覧を表示できます。
<code>?</code>より後ろはクエリパラメータとして認識されるので、APIで使用できるクエリパラメータをそのまま使えます。
たとえば<code>?state=all</code>をつけるとclosedしたissueも一覧に表示されます。詳細は<code>gh.vim</code>のヘルプを参照下さい。
実行可能なアクションは次になります。</p>
<table>
<thead>
<tr>
<th>キー</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;C-h&gt;</code></td>
<td>前のページ</td>
</tr>
<tr>
<td><code>&lt;C-l&gt;</code></td>
<td>次のページ</td>
</tr>
<tr>
<td><code>&lt;C-o&gt;</code></td>
<td>issueをブラウザで開く</td>
</tr>
<tr>
<td><code>ghe</code></td>
<td>issueを編集</td>
</tr>
<tr>
<td><code>ghc</code></td>
<td>issueをclose</td>
</tr>
<tr>
<td><code>gho</code></td>
<td>issueをopen</td>
</tr>
<tr>
<td><code>ghm</code></td>
<td>issueのコメントを開く</td>
</tr>
<tr>
<td><code>ghy</code></td>
<td>issueのURLをコピー</td>
</tr>
</tbody>
</table>
<p><strong>issueの作成</strong><br>
<code>gh://:owner/:repo/:branch/issues/new</code>で新規issueを作成できます。
リポジトリにテンプレートがある場合、テンプレートを選択してissueを作成できます。</p>
<p><img src="https://i.gyazo.com/6373b68c39829a5c3c4288e94bd1be20.gif" alt=""></p>
<p><strong>issueの編集</strong><br>
<code>gh://:owner/:repo/:branch/issues/:number</code>でissueの本文を編集&amp;更新できます。
本文を編集後<code>:w</code>で更新されます。更新の際タイトルも変更するか聞かれるので合わせて修正したいときは新しいタイトルを入力します。</p>
<p><strong>issueのコメント一覧</strong><br>
<code>gh://:owner/:repo/issues/:number/comments[?page=1&amp;...]</code>でissueのコメント一覧を表示できます。
実行可能なアクションは次になります。</p>
<table>
<thead>
<tr>
<th>キー</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;C-h&gt;</code></td>
<td>前のページ</td>
</tr>
<tr>
<td><code>&lt;C-l&gt;</code></td>
<td>次のページ</td>
</tr>
<tr>
<td><code>&lt;C-o&gt;</code></td>
<td>コメントをブラウザで開く</td>
</tr>
<tr>
<td><code>ghn</code></td>
<td>新規コメント</td>
</tr>
<tr>
<td><code>ghy</code></td>
<td>コメントのURLをコピー</td>
</tr>
</tbody>
</table>
<h4 id="pull-request機能">Pull Request機能</h4>
<p>PRの一覧&amp;差分を確認できます。</p>
<p><img src="https://i.gyazo.com/ba4aa068fdaeebcf8168c8994ac73db4.gif" alt=""></p>
<p><strong>PR一覧</strong><br>
<code>gh://:owner/:repo/pulls[?page=1&amp;...]</code>でPR一覧を表示できます。</p>
<p>実行可能なアクションは次になります。</p>
<table>
<thead>
<tr>
<th>キー</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;C-h&gt;</code></td>
<td>前のページ</td>
</tr>
<tr>
<td><code>&lt;C-l&gt;</code></td>
<td>次のページ</td>
</tr>
<tr>
<td><code>&lt;C-o&gt;</code></td>
<td>PRをブラウザで開く</td>
</tr>
<tr>
<td><code>ghd</code></td>
<td>PRの差分</td>
</tr>
<tr>
<td><code>ghy</code></td>
<td>PRのURLをコピー</td>
</tr>
</tbody>
</table>
<p><strong>PRの差分</strong>
<code>gh://:owner/:repo/pull/:number/diff</code>でPRの差分を確認できます。
現時点では差分確認のみですが将来的にはレビューコメントもできるようにする予定です。</p>
<h4 id="repository機能">Repository機能</h4>
<p>リポジトリ一覧&amp;READMEを確認できます。</p>
<p><strong>リポジトリ一覧</strong>
<code>gh://:owner/repos[?page=1&amp;...]</code>でリポジトリ一覧を表示できます。
<code>:owner</code>が<code>user</code>の場合、認証されたユーザ（tokenを発行したユーザ）のプライベートやOrganazationのリポジトリも表示されます。</p>
<p><strong>リポジトリのREADME</strong>
<code>gh://:owner/:repo/readme</code>でリポジトリのREADMEを確認できます。</p>
<p><img src="https://i.gyazo.com/cd2d9bfebce0975fa8d75eaad1582f00.gif" alt=""></p>
<h4 id="project機能">Project機能</h4>
<p>リポジトリのproject一覧&amp;カード一覧を確認できます。
プロジェクトとカラム、カードはツリーになっていて、折りたたみが可能です。
また、カードの移動も出来ます。</p>
<p>この機能の実装については<a href="https://zenn.dev/skanehira/articles/2020-11-22-vim-github-project">こちら</a>を参照ください。</p>
<p><img src="https://i.gyazo.com/e1dfc9d4880ca68f8ca84dfe025bd160.gif" alt=""></p>
<p><strong>プロジェクト一覧</strong>
<code>gh://:owner/:repo/projects</code>で指定したリポジトリのproject一覧を表示します。
<code>:owner</code>が<code>orgs</code>の場合、<code>:repo</code>はOrganazationの名前を指定する必要があります。</p>
<p>実行可能なアクションは次になります。</p>
<table>
<thead>
<tr>
<th>キー</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;CR&gt;</code></td>
<td>カード一覧を開く</td>
</tr>
<tr>
<td><code>&lt;C-o&gt;</code></td>
<td>プロジェクトをブラウザで開く</td>
</tr>
<tr>
<td><code>ghy</code></td>
<td>プロジェクトのURLをコピー</td>
</tr>
</tbody>
</table>
<p><strong>カード一覧</strong>
<code>gh://projects/:id/columns</code>でprojectのカラムとカード一覧とカードの操作が出来ます。</p>
<table>
<thead>
<tr>
<th>キー</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;C-o&gt;</code></td>
<td>選択したカードのURLを開く（現時点issueのみ対応）</td>
</tr>
<tr>
<td><code>gho</code></td>
<td>選択したカードの詳細を開く（現時点issueのみ対応）</td>
</tr>
<tr>
<td><code>ghm</code></td>
<td>選択したカードを現在のカラムに移動</td>
</tr>
<tr>
<td><code>ghy</code></td>
<td>選択したカードのURLをコピー</td>
</tr>
</tbody>
</table>
<h4 id="github-actions機能">GitHub Actions機能</h4>
<p><code>gh://:owner/:repo/actions[?status=success&amp;...]</code>でリポジトリのGitHub Actionsのワークフローとジョブを確認できます。
実装の詳細については<a href="https://zenn.dev/skanehira/articles/2020-11-29-vim-gh-add-actions">こちら</a>を参照下さい。</p>
<p><img src="https://i.gyazo.com/bb920d9694c126b571e4f90fa7cc9a9a.gif" alt=""></p>
<table>
<thead>
<tr>
<th>キー</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;C-o&gt;</code></td>
<td>選択したワークフロー/ジョブをブラウザで開く</td>
</tr>
<tr>
<td><code>ghy</code></td>
<td>選択したワークフロー/ジョブのURLをコピー</td>
</tr>
<tr>
<td><code>gho</code></td>
<td>選択したジョブのログを確認</td>
</tr>
</tbody>
</table>
<h4 id="キーマップ">キーマップ</h4>
<p><code>gh.vim</code>では各種バッファで使用できるキーマップを用意しています。
詳細なキーマップはヘルプを参照いただければと思いますが、vimrcに次のような設定を書くことで独自のキーマップを設定できます。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">gh_map_add</span><span class="p">()</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>  <span class="k">if</span> <span class="p">!</span><span class="nx">exists</span><span class="p">(</span><span class="s1">&#39;g:loaded_gh&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">return</span><span class="err">
</span><span class="err"></span>  <span class="k">endif</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">map</span>#<span class="nx">add</span><span class="p">(</span><span class="s1">&#39;gh-buffer-issue-list&#39;</span><span class="p">,</span> <span class="s1">&#39;nnoremap&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;:bw!&lt;CR&gt;&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">map</span>#<span class="nx">add</span><span class="p">(</span><span class="s1">&#39;gh-buffer-issue-list&#39;</span><span class="p">,</span> <span class="s1">&#39;map&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Plug&gt;(gh_issue_list_prev)&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">map</span>#<span class="nx">add</span><span class="p">(</span><span class="s1">&#39;gh-buffer-issue-list&#39;</span><span class="p">,</span> <span class="s1">&#39;map&#39;</span><span class="p">,</span> <span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Plug&gt;(gh_issue_list_next)&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nx">augroup</span> <span class="nx">gh</span><span class="p">-</span><span class="nx">maps</span><span class="err">
</span><span class="err"></span>  <span class="nx">au</span><span class="p">!</span><span class="err">
</span><span class="err"></span>  <span class="nx">au</span> <span class="nx">VimEnter</span> * <span class="nx">call</span> <span class="p">&lt;</span><span class="nx">SID</span><span class="p">&gt;</span><span class="nx">gh_map_add</span><span class="p">()</span><span class="err">
</span><span class="err"></span><span class="nx">augroup</span> <span class="nx">END</span><span class="err">
</span></code></pre></div><h3 id="仕組み">仕組み</h3>
<h4 id="通信">通信</h4>
<p>Vimの<code>job</code>機能を使って非同期に<code>curl</code>でGithubのv3 APIを叩いています。取得した結果をいい感じに表示させているだけなので、すごくムズカシイことをやっているわけではないです。
たとえばissue一覧のバッファを開くと、裏では次のコマンドが実行されます。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">curl -H <span class="s2">&#34;Accept: application/vnd.github.v3+json&#34;</span> -H <span class="s2">&#34;Authorization: token xxxxxxxxxxxxxxxxxxx&#34;</span> <span class="s2">&#34;https://api.github.com/repos/golang/go/issues&#34;</span>
</code></pre></div><p>ただ、生の<code>job</code>機能を使うのはけっこう面倒なので、それをいい感じに使いやすくしてくれた<a href="https://github.com/vim-jp/vital.vim">vital.vim</a>と<code>vital.vim</code>の追加モジュールである<a href="https://github.com/lambdalisue/vital-Whisky">vital-Whisky</a>を使っています。
複雑なVimプラグインを作る上で欠かせないライブラリとなっているので、知らない方は一度使ってみると良いと思います。本当によく出来ています。</p>
<h4 id="仮想バッファ">仮想バッファ</h4>
<p>仮想バッファの仕組みはVimの<code>autocmd</code>の<code>BufReadCmd</code>を使って実現しています。
<code>BufReadCmd</code>は新たなバッファが作られたときに何かしらの処理をしたいときに使えます。<code>gh.vim</code>では<code>gh://*</code>と一致したバッファ名が作られたときに<code>gh#gh#init()</code>という関数を呼び、バッファ名をもとに処理を分岐させています。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim:gh/plugin.vim" data-lang="vim:gh/plugin.vim"><span class="nx">augroup</span> <span class="nx">gh</span><span class="err">
</span><span class="err"></span>  <span class="nx">au</span><span class="p">!</span><span class="err">
</span><span class="err"></span>  <span class="nx">au</span> <span class="nx">BufReadCmd</span> <span class="nx">gh</span>:<span class="sr">//</span>* <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">gh</span>#<span class="nx">init</span><span class="p">()</span><span class="err">
</span><span class="err"></span><span class="nx">augroup</span> <span class="nx">END</span><span class="err">
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-vim:autoload/gh/gh.vim" data-lang="vim:autoload/gh/gh.vim"><span class="k">function</span><span class="p">!</span> <span class="nx">gh</span>#<span class="nx">gh</span>#<span class="nx">init</span><span class="p">()</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>  <span class="nx">setlocal</span> <span class="nx">nolist</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">bufname</span> <span class="p">=</span> <span class="nx">bufname</span><span class="p">()</span><span class="err">
</span><span class="err"></span>  <span class="k">if</span> <span class="nx">bufname</span> <span class="nx">is</span># <span class="s1">&#39;gh://user/repos/new&#39;</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">repos</span>#<span class="nx">new</span><span class="p">()</span><span class="err">
</span><span class="err"></span>  <span class="k">elseif</span> <span class="nx">bufname</span> <span class="p">=~</span># <span class="s1">&#39;^gh:\/\/[^/]\+\/repos$&#39;</span> <span class="p">||</span> <span class="nx">bufname</span> <span class="p">=~</span># <span class="s1">&#39;^gh:\/\/[^/]\+\/repos?\+&#39;</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">repos</span>#<span class="nx">list</span><span class="p">()</span><span class="err">
</span><span class="err"></span>  <span class="k">elseif</span> <span class="nx">bufname</span> <span class="p">=~</span># <span class="s1">&#39;^gh:\/\/[^/]\+\/[^/]\+\/readme$&#39;</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">repos</span>#<span class="nx">readme</span><span class="p">()</span><span class="err">
</span><span class="err"></span>  <span class="k">elseif</span> <span class="nx">bufname</span> <span class="p">=~</span># <span class="s1">&#39;^gh:\/\/[^/]\+\/[^/]\+\/issues$&#39;</span><span class="err">
</span><span class="err"></span>        \ <span class="p">||</span> <span class="nx">bufname</span> <span class="p">=~</span># <span class="s1">&#39;^gh:\/\/[^/]\+\/[^/]\+\/issues?\+&#39;</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">issues</span>#<span class="nx">list</span><span class="p">()</span><span class="err">
</span><span class="err"></span>  <span class="k">elseif</span> <span class="nx">bufname</span> <span class="p">=~</span># <span class="s1">&#39;^gh:\/\/[^/]\+\/[^/]\+\/issues\/[0-9]\+$&#39;</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">issues</span>#<span class="nx">issue</span><span class="p">()</span><span class="err">
</span><span class="err"></span>  <span class="k">elseif</span> <span class="nx">bufname</span> <span class="p">=~</span># <span class="s1">&#39;^gh:\/\/[^/]\+\/[^/]\+\/[^/]\+\/issues\/new$&#39;</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">issues</span>#<span class="nx">new</span><span class="p">()</span><span class="err">
</span><span class="err"></span>  <span class="k">elseif</span> <span class="nx">bufname</span> <span class="p">=~</span># <span class="s1">&#39;^gh:\/\/[^/]\+\/[^/]\+\/issues\/\d\+\/comments$&#39;</span><span class="err">
</span><span class="err"></span>        \ <span class="p">||</span> <span class="nx">bufname</span> <span class="p">=~</span># <span class="s1">&#39;^gh:\/\/[^/]\+\/[^/]\+\/issues\/\d\+\/comments?\+&#39;</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">issues</span>#<span class="nx">comments</span><span class="p">()</span><span class="err">
</span><span class="err"></span>  <span class="k">elseif</span> <span class="nx">bufname</span> <span class="p">=~</span># <span class="s1">&#39;^gh:\/\/[^/]\+\/[^/]\+\/issues\/\d\+\/comments\/new$&#39;</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">issues</span>#<span class="nx">comment_new</span><span class="p">()</span><span class="err">
</span><span class="err"></span>  <span class="k">elseif</span> <span class="nx">bufname</span> <span class="p">=~</span># <span class="s1">&#39;^gh:\/\/[^/]\+\/[^/]\+\/pulls$&#39;</span><span class="err">
</span><span class="err"></span>        \ <span class="p">||</span> <span class="nx">bufname</span> <span class="p">=~</span># <span class="s1">&#39;^gh:\/\/[^/]\+\/[^/]\+\/pulls?\+&#39;</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">pulls</span>#<span class="nx">list</span><span class="p">()</span><span class="err">
</span><span class="err"></span>  <span class="k">elseif</span> <span class="nx">bufname</span> <span class="p">=~</span># <span class="s1">&#39;^gh:\/\/[^/]\+\/[^/]\+\/pulls\/\d\+\/diff$&#39;</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">pulls</span>#<span class="nx">diff</span><span class="p">()</span><span class="err">
</span><span class="err"></span>  <span class="k">elseif</span> <span class="nx">bufname</span> <span class="p">=~</span># <span class="s1">&#39;^gh:\/\/[^/]\+\/[^/]\+\/projects$&#39;</span><span class="err">
</span><span class="err"></span>        \ <span class="p">||</span> <span class="nx">bufname</span> <span class="p">=~</span># <span class="s1">&#39;^gh:\/\/[^/]\+\/[^/]\+\/projects?\+&#39;</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">projects</span>#<span class="nx">list</span><span class="p">()</span><span class="err">
</span><span class="err"></span>  <span class="k">elseif</span> <span class="nx">bufname</span> <span class="p">=~</span># <span class="s1">&#39;^gh:\/\/projects\/[^/]\+\/columns$&#39;</span><span class="err">
</span><span class="err"></span>        \ <span class="p">||</span> <span class="nx">bufname</span> <span class="p">=~</span># <span class="s1">&#39;^gh:\/\/projects\/[^/]\+\/columns?\+&#39;</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">projects</span>#<span class="nx">columns</span><span class="p">()</span><span class="err">
</span><span class="err"></span>  <span class="k">elseif</span> <span class="nx">bufname</span> <span class="p">=~</span># <span class="s1">&#39;^gh:\/\/[^/]\+\/[^/]\+\/actions$&#39;</span><span class="err">
</span><span class="err"></span>        \ <span class="p">||</span> <span class="nx">bufname</span> <span class="p">=~</span># <span class="s1">&#39;^gh:\/\/[^/]\+\/[^/]\+\/actions?\+&#39;</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">actions</span>#<span class="nx">list</span><span class="p">()</span><span class="err">
</span><span class="err"></span>  <span class="k">elseif</span> <span class="nx">bufname</span> <span class="p">=~</span># <span class="s1">&#39;^gh:\/\/bookmarks$&#39;</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">bookmark</span>#<span class="nx">list</span><span class="p">()</span><span class="err">
</span><span class="err"></span>  <span class="k">endif</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span></code></pre></div><p>仮想バッファのメリットは簡単にいうとバッファを開く処理とバッファ初期化の処理を分断できる、ということです。
分断することで、たとえばissue編集バッファをissue一覧やprojectバッファから開くときは以下を実行するだけで済みます。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="nx">exe</span> <span class="s1">&#39;gh://:owner/:repo/issues/:number&#39;</span><span class="err">
</span></code></pre></div><p>しかし分断されていない場合、バッファ作成したあとに初期化の処理関数を呼び出す必要があります。
そして関数名が変わったら修正範囲も広がってしまいます。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="nx">exe</span> <span class="s1">&#39;gh://:owner/:repo/issues/:number&#39;</span><span class="err">
</span><span class="err"></span><span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">issue</span>#<span class="nx">edit</span><span class="p">()</span><span class="err">
</span></code></pre></div><p>このように、結合度を低く保てることにメリットがあるため<code>gh.vim</code>は積極的に仮想バッファを採用しています。</p>
<h4 id="モジュール">モジュール</h4>
<p><code>gh.vim</code>では大きく分けて次のモジュール群があります。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>autoload/gh/http.vim</code></td>
<td>http通信を提供する</td>
</tr>
<tr>
<td><code>autoload/gh/tree.vim</code></td>
<td>treeバッファを提供する</td>
</tr>
<tr>
<td><code>autoload/gh/github/*.vim</code></td>
<td>http通信をラップしてわかりやすくした</td>
</tr>
<tr>
<td><code>autoload/gh/*.vim</code></td>
<td>各種バッファを提供している</td>
</tr>
<tr>
<td><code>autoload/gh/gh.vim</code></td>
<td>全バッファ共通のutil関数などを提供している</td>
</tr>
</tbody>
</table>
<p>ディレクトリ構成は次になっています。
他のプラグインと名前空間がかぶらないように、<code>gh</code>というディレクトリ配下にコードを置くようにしています。</p>
<pre><code> gh.vim
 |- autoload/
  |- gh/
   |- github/
    |  actions.vim
    |  issues.vim
    |  projects.vim
    |  pulls.vim
    |  repos.vim
   |  actions.vim
   |  bookmark.vim
   |  buffer.vim
   |  gh.vim
   |  http.vim
   |  issues.vim
   |  map.vim
   |  projects.vim
   |  pulls.vim
   |  repos.vim
   |  tree.vim
</code></pre><p>基本、各種バッファから<code>gh#http#xxx()</code>または<code>gh#github#xxx()</code>を呼び出して、結果を受け取って画面描画とキーマップの設定を行っています。
次はissue一覧バッファを開いたときに実行される関数です。中で<code>gh#github#issues#list()</code>を呼び出していてissue一覧を取得しています。
大体どの機能も、バッファの処理と通信の処理に分かれているのでファイル単位で分割しました。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim:autoload/gh/issue.vim" data-lang="vim:autoload/gh/issue.vim"><span class="k">function</span><span class="p">!</span> <span class="nx">gh</span>#<span class="nx">issues</span>#<span class="nx">list</span><span class="p">()</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>  <span class="nx">setlocal</span> <span class="nx">ft</span><span class="p">=</span><span class="nx">gh</span><span class="p">-</span><span class="nx">issues</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">m</span> <span class="p">=</span> <span class="nx">matchlist</span><span class="p">(</span><span class="nx">bufname</span><span class="p">(),</span> <span class="s1">&#39;gh://\(.*\)/\(.*\)/issues?*\(.*\)&#39;</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">gh</span>#<span class="nx">delete_buffer</span><span class="p">(</span><span class="nx">s</span>:<span class="p">,</span> <span class="s1">&#39;gh_issues_list_bufid&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">s</span>:<span class="nx">gh_issues_list_bufid</span> <span class="p">=</span> <span class="nx">bufnr</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">param</span> <span class="p">=</span> <span class="nx">gh</span>#<span class="nx">http</span>#<span class="nx">decode_param</span><span class="p">(</span><span class="nx">m</span>[<span class="m">3</span>]<span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="k">if</span> <span class="p">!</span><span class="nx">has_key</span><span class="p">(</span><span class="nx">param</span><span class="p">,</span> <span class="s1">&#39;page&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="k">let</span> <span class="nx">param</span>[<span class="s1">&#39;page&#39;</span>] <span class="p">=</span> <span class="m">1</span><span class="err">
</span><span class="err"></span>  <span class="k">endif</span><span class="err">
</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">s</span>:<span class="nx">issue_list</span> <span class="p">=</span> {<span class="err">
</span><span class="err"></span>        \ <span class="s1">&#39;repo&#39;</span>: {<span class="err">
</span><span class="err"></span>        \   <span class="s1">&#39;owner&#39;</span>: <span class="nx">m</span>[<span class="m">1</span>]<span class="p">,</span><span class="err">
</span><span class="err"></span>        \   <span class="s1">&#39;name&#39;</span>: <span class="nx">m</span>[<span class="m">2</span>]<span class="p">,</span><span class="err">
</span><span class="err"></span>        \ }<span class="p">,</span><span class="err">
</span><span class="err"></span>        \ <span class="s1">&#39;param&#39;</span>: <span class="nx">param</span><span class="p">,</span><span class="err">
</span><span class="err"></span>        \ }<span class="err">
</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">gh</span>#<span class="nx">init_buffer</span><span class="p">()</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">gh</span>#<span class="nx">set_message_buf</span><span class="p">(</span><span class="s1">&#39;loading&#39;</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">gh</span>#<span class="nx">github</span>#<span class="nx">issues</span>#<span class="nx">list</span><span class="p">(</span><span class="nx">s</span>:<span class="nx">issue_list</span>.<span class="nx">repo</span>.<span class="nx">owner</span><span class="p">,</span> <span class="nx">s</span>:<span class="nx">issue_list</span>.<span class="nx">repo</span>.<span class="nx">name</span><span class="p">,</span> <span class="nx">s</span>:<span class="nx">issue_list</span>.<span class="nx">param</span><span class="p">)</span><span class="err">
</span><span class="err"></span>        \.<span class="nx">then</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="s1">&#39;s:issue_list&#39;</span><span class="p">))</span><span class="err">
</span><span class="err"></span>        \.<span class="nx">then</span><span class="p">(</span>{<span class="p">-&gt;</span> <span class="nx">gh</span>#<span class="nx">map</span>#<span class="nx">apply</span><span class="p">(</span><span class="s1">&#39;gh-buffer-issue-list&#39;</span><span class="p">,</span> <span class="nx">s</span>:<span class="nx">gh_issues_list_bufid</span><span class="p">)</span>}<span class="p">)</span><span class="err">
</span><span class="err"></span>        \.<span class="nx">catch</span><span class="p">(</span>{<span class="nx">err</span> <span class="p">-&gt;</span> <span class="nx">execute</span><span class="p">(</span><span class="s1">&#39;call gh#gh#error_message(err.body)&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>}<span class="p">)</span><span class="err">
</span><span class="err"></span>        \.<span class="nx">finally</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="s1">&#39;gh#gh#global_buf_settings&#39;</span><span class="p">))</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span></code></pre></div><p>以上が<code>gh.vim</code>の大まかな仕組みです。
まだまだリファクタリングしないといけない箇所がたくさんありますが、より詳細な実装を知りたい方はコードを覗いてみて下さい。</p>
<h3 id="課題">課題</h3>
<p><strong>一覧バッファの共通化</strong>
現在、一覧バッファは大体どれも同じ仕組みですが、共通の部分を分けられていない状態です。
<code>tree.vim</code>のように、<code>list.vim</code>を作って一覧の処理の共通化をする必要があります。
共通化しておかないと、今後一覧画面が増えるたびに似通った処理が増えてメンテナンスが大変なので、いまのうちに手を付けておきたいと思っています。</p>
<p><strong>API通信量の削減</strong>
v3のAPIを使っているため、通信量が結構多いです。
たとえばプロジェクトのカード一覧を取得するAPIがありますが、こちらにはカードの種類とURLの情報くらいしかなくて、種類がissueやPRの場合は別途APIを叩く必要があります。
カードがN百枚の場合、Vimが死ぬのでv4のGraphQLを使って通信量と回数を減らすのが直近一番やらないと行けない課題です。</p>
<p><strong>エラーハンドリング</strong>
<code>vital.vim</code>の<code>promise</code>を使っていることによる原因かわからないんですが、処理でエラーが起きたときに握りつぶされることがあります。
実装時結構大変なのでこれも早い段階で解決しなければ行けないんですが、良い解決策が浮かばずという状態です。
知見がある方はアドバイスをお願いします。</p>
<h3 id="最後">最後</h3>
<p>少し長くなりましたが、<code>gh.vim</code>の大体の機能について紹介しました。
このプラグインはまだまだ未完成なので、今後もコツコツと作っていきたいと思います。</p>
<p>プラグイン気になる方は、ぜひ一度使ってみて下さい。</p>
]]></content></item><item><title>あまり知られていないGoのスライス/配列の初期化</title><link>https://skanehira.github.io/blog/posts/20201202-go-slice-initialize/</link><pubDate>Wed, 02 Dec 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20201202-go-slice-initialize/</guid><description>初めに 先日、こちらの動画で見たことがない配列の初期化をしていたので、それについてわかったことを解説してきます。 配列の初期化 動画のほうでは次の</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>先日、<a href="https://www.youtube.com/watch?v=elGjixFQLYE&amp;t=1054s&amp;ab_channel=mercaridevjp">こちらの動画</a>で見たことがない配列の初期化をしていたので、それについてわかったことを解説してきます。</p>
<h2 id="配列の初期化">配列の初期化</h2>
<p>動画のほうでは次のような配列宣言をしていました。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">var</span> <span class="nx">array</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">array</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>一般的な配列やスライスの宣言は以下のパターンがあると思います</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">slice1</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">slice2</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">array1</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">array2</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
</code></pre></div><p>これらはよく見かけるパターンですが、<code>{0, 4:1, 2, 1:1}</code>というのは見たことがなく、どう読めばよいのかわかりませんでした。
これについて<a href="https://twitter.com/hajimehoshi">Hajime Hoshi (星一)</a>さんに教えていただきました。結論からいうと以下の処理と同じことをしています。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">array</span> <span class="p">=</span> <span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
<span class="nx">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
<span class="nx">array</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
<span class="nx">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span>
</code></pre></div><h2 id="解説">解説</h2>
<p>配列、スライスではインデックスを指定して値をセットできます。
つまり<code>{0, 4:1, 2, 1:1}</code>は、<code>0</code>番目に<code>0</code>、<code>4:1</code>は<code>4</code>番目に値<code>1</code>、<code>5</code>番目に<code>2</code>、<code>1</code>番目に<code>1</code>をセットしています。
これは構造体の初期化時にフィールドを指定できるのと同じです。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">gorilla</span> <span class="o">:=</span> <span class="nx">Animal</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;gorilla&#34;</span><span class="p">,</span> <span class="nx">Age</span><span class="p">:</span> <span class="mi">28</span><span class="p">}</span>
</code></pre></div><h2 id="最後に">最後に</h2>
<p>普通にGoを書いていたらこのような書き方は使わないんですが、構造体の初期化と同じ理屈と考えるとすごく腑に落ちます。
Go、奥が深い。。</p>
]]></content></item><item><title>VimでGitHub Actionsのステータスを確認</title><link>https://skanehira.github.io/blog/posts/20201129-vim-gh-add-actions/</link><pubDate>Sun, 29 Nov 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20201129-vim-gh-add-actions/</guid><description>始めに 最近少しずつGitHub Actionsを使い始めています。とても便利でよくできているエコシステムだなって感心しました。 そこで、Vimで</description><content type="html"><![CDATA[<h2 id="始めに">始めに</h2>
<p>最近少しずつGitHub Actionsを使い始めています。とても便利でよくできているエコシステムだなって感心しました。
そこで、VimでGitHub Actionsのステータスを確認できたら便利かなと思って<a href="https://zenn.dev/skanehira/articles/2020-09-19-vim-plugin-for-github">ブラウザをやめてVimでGitHubを使う</a>で作った<a href="https://github.com/skanehira/gh.vim">gh.vim</a>に機能を追加しました。</p>
<p><code>gh://:owner/:repo/actions</code> を開くとそのリポジトリにGtHub Actionsが動いていれば、ワークフローとジョブのステータスが表示されます。</p>
<p><img src="https://i.gyazo.com/7550a3a547f6a1d94cecd68497f72cf0.gif" alt=""></p>
<h3 id="ui">UI</h3>
<p>ワークフローとジョブがツリー状になっています。
ルートはリポジトリ名、その下はワークフロー一覧となっています。
さらにその下はジョブとそのステップになっています。</p>
<pre><code>- clipboard-image                                             &lt;-- リポジトリ名
| - ✗ add github actions... @skanehira [add-github-actions]   &lt;-- ワークフロー
| | - ✗ Test (ubuntu-latest)                                  &lt;-- ジョブ
| | | | ✓ #1 Set up job                                       &lt;-+
| | | | ✓ #2 Run actions/checkout@v2                            |
| | | | ✓ #3 Run actions/setup-go@v2                            | ジョブステップ
| | | | ✓ #4 install xclip                                      |
| | | | ✗ #5 Test                                               |
| | | | ✓ #10 Post Run actions/checkout@v2                      |
| | | | ✓ #11 Complete job                                    &lt;-+
</code></pre><p>ワークフロー行では次のフォーマットになっていて、
ジョブが成功しているかどうかが一目で分かるようになっています。</p>
<pre><code>実行結果 コミットメッセージ 作者 ブランチ名
------------------------------------------------------
✓ add github actions... @skanehira [add-github-actions]
✗ add github actions... @skanehira [add-github-actions]
</code></pre><p>GitHubではワークフローとジョブのレスポンスに<code>status</code>と<code>conclusion</code>というフィールドがあって、<code>status</code>はActionsの実行状態、<code>conclusion</code>が実行結果です。
↑の実行結果は<code>conclusion</code>をもとに判定しています。</p>
<p><img src="https://i.gyazo.com/f38c64240c590e49efe127604e1fb0ed.png" alt=""></p>
<h3 id="機能">機能</h3>
<p>現時点ではワークフローとジョブの表示とURLのコピー・ブラウザで開くの機能があります。
一応ジョブのre-runはやろうと思えばできますが、これ本当に必要かな？って思っているので未実装です。</p>
<p>gh.vim自体をできるだけシンプルに保ちたいので、
とりあえずあったら良いんじゃない？という感じで実装をしないようにしています。</p>
<p>選択したワークフロー/ジョブのURLをコピーする機能を実装したのは、たとえばURLを開発メンバーにここ落ちているよって共有するのに便利です。</p>
<p>2020/11/29追記
ジョブのログを確認できるようになりました。</p>
<p><img src="https://i.gyazo.com/c5ed35bbb72fdc247265a6a5b7808600.gif" alt=""></p>
<h3 id="実装">実装</h3>
<p>GitHub v3のAPIでリポジトリのGitHub Actionsの情報を取得しています。</p>
<p><a href="https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs-for-a-repository">https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs-for-a-repository</a></p>
<p>このAPIはGitHub Actionsの情報のみ取得するので、たとえばCIをAWSのcodebuildで行っているといったケースでは情報は取れないです。
また、このAPIではワークフロー一覧しか取得できないのでさらにその中にあるジョブとステップ情報は次のAPIから取得する必要があります。REST APIだとこういうのがツライですよね。..</p>
<p><a href="https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run">https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run</a></p>
<p>本当はRESTではなくGraphQLを使いたかったんですが、v4 APIはGitHub Actions未対応なのでひとまずv3を使っています。
早くv4でGitHub Actionsの情報を取れるようになってほしいですね。</p>
<p>ツリー実装は<a href="https://zenn.dev/skanehira/articles/2020-11-22-vim-github-project">VimでGitHubのプロジェクトボードを使う</a>のときに作ったものをそのまま使っているので、難なく実装できました。
汎用なツリーモジュールにしといて良かったです。
ライブラリにするのはちょっと難しいんですが、VimでツリーのUIを実現したい方は適当にコードからパクってもらって大丈夫です。</p>
<h3 id="余談">余談</h3>
<p><img src="https://i.gyazo.com/7c3b40585f4ca937f5f0f71e7f4fd03d.png" alt="">
↑は初期UIですが、文字情報しかなくてとても分かりづらかったので、GitHubのUIを参考にみたら今の形になりました。自分のデザインのセンスがなさすぎてツライ。..</p>
<p><img src="https://i.gyazo.com/2cc3c5d9521fef08ddb349ea0d3796d6.png" alt=""></p>
]]></content></item><item><title>VimでGitHubのプロジェクトボードを使う</title><link>https://skanehira.github.io/blog/posts/20201122-vim-github-project/</link><pubDate>Sun, 22 Nov 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20201122-vim-github-project/</guid><description>初めに みなさん、GitHubのプロジェクトボードはご存じですか？ 詳細は公式を参照していただければと思いますが、いわゆるカンバンです。 とても便</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>みなさん、GitHubのプロジェクトボードはご存じですか？
詳細は<a href="https://docs.github.com/ja/free-pro-team@latest/github/managing-your-work-on-github/about-project-boards">公式</a>を参照していただければと思いますが、いわゆるカンバンです。
とても便利ですので仕事でガッツリ使っています。</p>
<p>しかしとても残念なことに、これを使うにはブラウザを開く必要があります。
普段Vimで作業しているので、カンバンを見るためだけにブラウザを開くのは効率が悪いです。</p>
<p>すべてをVimで完結できなくても、最低限カンバンを見たり、カードを移動したりはVim上でやりたいです。
残念なことにそんなVimプラグインはないので、以前作ったVim上でGitHubを扱えるプラグイン<a href="https://github.com/skanehira/gh.vim">gh.vim</a>にこの機能を実装してみました。</p>
<p><img src="https://i.gyazo.com/ede622d346b60d03530bf88c6284e353.gif" alt=""></p>
<h2 id="機能">機能</h2>
<p>次の機能を実装しました。これだけでも結構苦労したので、その苦労話もこのあと少し話します。</p>
<ul>
<li>プロジェクト
<ul>
<li>一覧</li>
<li>URLコピー</li>
<li>開く（ブラウザ）</li>
</ul>
</li>
<li>カード
<ul>
<li>一覧</li>
<li>カラム移動（単一、複数同時）</li>
<li>URLコピー</li>
<li>開く（ブラウザ）</li>
</ul>
</li>
</ul>
<h2 id="uiの実現">UIの実現</h2>
<p>ブラウザではプロジェクトはカンバンになっていますが、Vimでカンバンを実現するなら1つのカラムが1ウィンドウになるので、
10個もカラムがあったら画面幅足りないことは容易に想像できます。
なのでVimではカンバンではなく次のようにツリーという形でカンバンを表現しました。</p>
<p><img src="https://i.gyazo.com/69d7dca998640782725af533fa1b5e1b.png" alt=""></p>
<p>ルートはプロジェクト名、ルート直下のノードはカラム、その下はカードという配置となっています。
ツリーにすることで1つのウィンドウ内でコンテンツが収まるので、検索や操作がツリーを開くと行った操作が手軽にできます。</p>
<h3 id="ツリーの実装課題">ツリーの実装課題</h3>
<p>ツリーにする上でデータ構造という大きな課題がありました。
ツリーのデータ構造はネストになっていて再帰しているに対して、Vimはエディタなので行思考のUIとなっているため、描画はフラットな配列が適しています。
こういったデータ構造の差異を吸収しつつ「今の行（現在のノード）がツリーのどの部分にあるのか」ということを判断できるしくみが必要です。</p>
<p>具体的に例を上げると、gh.vimでは次のようにカードを別のカラムに移動する機能がありますが、
「選択したノード」と「移動先ノード」をそれぞれ配列からデータを抽出してツリーをたどっていきノードの削除&amp;追加の処理を行う必要があります。
しかも、このカードの移動は非同期で通信をするのでさらに移動に失敗した時のことも考慮しなければ行けないです。</p>
<p><img src="https://i.gyazo.com/e1dfc9d4880ca68f8ca84dfe025bd160.gif" alt=""></p>
<p>このように、ツリーをVim上で扱うのは骨が折れます。
Vimのファイラプラグインに<a href="https://github.com/lambdalisue/fern.vim">fern.vim</a>というのがありますが、本当によくできているなぁと関心しました。</p>
<h2 id="プラグインの課題">プラグインの課題</h2>
<p>必要最低限の機能実装はできたのですが、API通信の回数がかなり多いという課題があります。
現在GitHub v3のAPIを使っていますが、カードがissueの場合はカラムのレスポンス情報にissueの情報が含まれないので、別途issueのAPIを叩いて取得する必要があります。
つまり、100枚カードがあったら非同期100回APIをたたきます。そして100回ツリーを再描画します。</p>
<p>量が増えれば増えるほど、処理がどんどん重くなっていくのは目に見えているので、近いうちにv4（GraphQL）に乗換える予定です。
v4をたたくことで、選択的にデータを取得できるので処理が軽くなる見込みです。</p>
<h2 id="今後の展望">今後の展望</h2>
<p>プロジェクト機能に関しては、あとカードを追加したり、消したりする機能を追加したらぼくのニーズは満たせるのでいったん終わりかなと思っています。
gh.vim自体はまだまだ未完成なのでのんびり作っていこうと思います。</p>
<h2 id="余談">余談</h2>
<p>Vimでツリーを実装したのはじめてですので、最初は小さなツリーをまず作ってみたらこんなのができました。</p>
<p><img src="https://i.gyazo.com/8295d83143358c58c39d7d3372e7157e.gif" alt=""></p>
]]></content></item><item><title>Gyazoに画像をアップロードするVimプラグインを作った</title><link>https://skanehira.github.io/blog/posts/20201116-go-vim-gyazo/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20201116-go-vim-gyazo/</guid><description>zenn.devやQiitaで記事を書いていると画像をアップロードしたくなることがあります。 そして、とても良いことにzenn.devやQii</description><content type="html"><![CDATA[<p>zenn.devやQiitaで記事を書いていると画像をアップロードしたくなることがあります。
そして、とても良いことにzenn.devやQiitaにはWebのエディタ上では<code>Ctrl(Cmd) + v</code>でクリップボードから画像をアップロードできる機能があります。</p>
<p>しかし普段Vimで記事を書いている自分としては、やはりVimだけで完結したいという気持ちがあります。
クリップボードの画像をアップロードのために、わざわざWebのエディタを開きたくないし、わざわざファイルに書き出したくないです。</p>
<p>しかし、zenn.devとQiitaは画像アップロードのAPIを公開していないので長らく諦めていましたが、<a href="https://gyazo.com">Gyazo</a>というサービスがあるのを知りました。
GyazoにはAPIがあるので、それをWebエディタと使えば同じことができると思い<a href="https://github.com/skanehira/gyazo.vim">gyazo.vim</a>というプラグインを作りました。</p>
<p><img src="https://i.gyazo.com/2adcdcc57f144bd524bc29bd1affbe75.gif" alt=""></p>
<p>やっていることはシンプルで<code>gyazo</code>のCLIを使ってAPIを叩いているだけです。URLが返ってくるのでそれをそのまま現在行に挿入させるだけで同じような動作を再現できます。</p>
]]></content></item><item><title>Vimで快適に記事を書くため環境</title><link>https://skanehira.github.io/blog/posts/20201116-vim-writing-articles/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20201116-vim-writing-articles/</guid><description>初めに こんにちは、Neovimを使い初めたゴリラです。 普段zenn.devに載せる記事をVimで書いています。 しかしVimで記事を書くとどう</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>こんにちは、Neovimを使い初めたゴリラです。</p>
<p>普段zenn.devに載せる記事をVimで書いています。
しかしVimで記事を書くとどうしても画像アップロードとリンク挿入の手間がかかってしまったり、
誤字脱字があったり、文章表現がバラバラになったりという問題があります。</p>
<p>こういった問題を長らく放置してきましたが、重い腰を上げて対策しました。
本記事は、Vim/Neovimで快適に記事を書くためにどんなことをしたのかについて解説していきます。</p>
<h3 id="環境">環境</h3>
<p>筆者の環境は次になっています。<code>Node.js</code>と<code>npm</code>と<code>Go</code>は必要です。</p>
<table>
<thead>
<tr>
<th>Environments</th>
<th>Version</th>
</tr>
</thead>
<tbody>
<tr>
<td>OS</td>
<td>Ubuntu 20.04 TLS</td>
</tr>
<tr>
<td>Vim</td>
<td>8.2.1992</td>
</tr>
<tr>
<td>Neovim</td>
<td>v0.5.0-834-g7c4f34966</td>
</tr>
<tr>
<td>Node.js</td>
<td>v14.15.0</td>
</tr>
<tr>
<td>npm</td>
<td>6.14.8</td>
</tr>
<tr>
<td>Go</td>
<td>go version go1.15.3 linux/amd64</td>
</tr>
</tbody>
</table>
<h3 id="要件">要件</h3>
<p>まず、記事を書くにあたり次の要件があります。</p>
<ol>
<li>誤字脱字を可能な限りなくす</li>
<li>文章の表現を統一</li>
<li>クリップボードや画像ファイルを選択してアップロードして、そのリンクを本文に挿入</li>
</ol>
<p>これらはmustと考えています。特に3は記事を書いていると画像やgifとを貼ったりするのでそれを毎度ブラウザを使ってアップロードするのは非常に手間です。
エディタで記事を書きながら、シームレスに画像をアップロードできたらこれだけで少なくとも5秒くらいは短縮できるでしょう。</p>
<p>この要件をもとに、対策をしていきます。</p>
<h3 id="誤字脱字表記ゆれ対策">誤字脱字、表記ゆれ対策</h3>
<p>1と2に関してはいわゆる校正作業ですが、こちらは<a href="https://github.com/textlint/textlint">textlint</a>を使います。</p>
<ul>
<li>zenn.devは記事をリポジトリと連携できる</li>
<li>Node.jsを使っている</li>
</ul>
<p>ということで、zenn.devと相性も良いです。（インストールして設定するだけ）</p>
<p>合わせて、校正ルールのプリセットもインストールします。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># textlint のインストール</span>
$ npm install textlint

<span class="c1"># ルールセット</span>
$ npm install textlint-rule-prh textlint-rule-preset-jtf-style textlint-rule-preset-ja-technical-writing
</code></pre></div><p>使用しているルールは次の通りです。詳細はリンク先を参照ください。ひとまずこれらがあれば問題ないでしょう。</p>
<table>
<thead>
<tr>
<th>ルール</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/textlint-ja/textlint-rule-preset-JTF-style">textlint-rule-preset-jtf-style</a></td>
<td>JTF日本語標準スタイルガイド</td>
</tr>
<tr>
<td><a href="https://github.com/textlint-ja/textlint-rule-preset-ja-technical-writing">textlint-rule-preset-ja-technical-writing</a></td>
<td>技術文章向けのルールプリセット</td>
</tr>
<tr>
<td><a href="https://github.com/textlint-rule/textlint-rule-prh">textlint-rule-prh</a></td>
<td><a href="https://github.com/prh/prh">prh</a>という校正ツールの<code>textlint</code>ルールプリセット</td>
</tr>
</tbody>
</table>
<p>インストール完了後<code>.textlintrc</code>に次の設定をします。（<code>preset-ja-technical-writing</code>でいくつかルールを無効にしています）</p>
<pre><code class="language-json:.textlintrc" data-lang="json:.textlintrc">{
  &quot;filters&quot;: {},
  &quot;rules&quot;: {
    &quot;preset-ja-technical-writing&quot;: {
      &quot;ja-no-weak-phrase&quot;: false,
      &quot;ja-no-mixed-period&quot;: false,
      &quot;no-exclamation-question-mark&quot;: false
    },
    &quot;preset-jtf-style&quot;: true,
    &quot;prh&quot;: {
      &quot;rulePaths&quot;: [
        &quot;node_modules/prh/prh-rules/media/WEB+DB_PRESS.yml&quot;,
        &quot;node_modules/prh/prh-rules/media/techbooster.yml&quot;
      ]
    }
  }
}
</code></pre><p>設定完了したら、試しにエラーが起きる文章に<code>textlint</code>をかけてみると、次のように修正すべき箇所が出てきます。</p>
<p><img src="https://i.gyazo.com/697868b83322fb9333f83c4cfa7a15c0.png" alt=""></p>
<p>これらをまとめて修正するには<code>textlint --fix [file]</code>すればよいです。
Vim上で実行する場合は<code>:terminal npx textlint --fix [file]</code>もしくは<code>:!npx textlint --fix [file]</code>すればよいです。
これでひとまず校正すべき箇所を検出してくれる環境を用意できました。次はVim/Neovimの設定を行っていきます。</p>
<p>Vim/Neovimでは<a href="https://microsoft.github.io/language-server-protocol/">LSP(Language Server Protocol)</a>を使って、動的に<code>textlint</code>で校正箇所を検出します。
次のプラグインをインストールことで、Vim/NeovimでもLSPを使えます。</p>
<ul>
<li><a href="https://github.com/prabirshrestha/vim-lsp">vim-lsp</a></li>
<li><a href="https://github.com/mattn/vim-lsp-settings">vim-lsp-settings</a>（LSPのサーバの導入を補助してくれる）</li>
</ul>
<p>プラグインをインストール後、<code>:LspInstallServer efm-langserver</code>で<code>efm-langserver</code>をインストールします。<code>efm-langserver</code>は<code>textlint</code>をLSPサーバとして動かすのに必要です。</p>
<p>プラグインの用意ができたら、プラグインの設定をします。<code>vimrc</code>または<code>init.vim</code>に次の設定を書きます。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="c">&#34; lsp settings {{{</span><span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">g</span>:<span class="nx">lsp_signs_error</span> <span class="p">=</span> {<span class="s1">&#39;text&#39;</span>: <span class="s1">&#39;ｳﾎ&#39;</span>}<span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">g</span>:<span class="nx">lsp_signs_warning</span> <span class="p">=</span> {<span class="s1">&#39;text&#39;</span>: <span class="s1">&#39;🍌&#39;</span>}<span class="err">
</span><span class="err"></span><span class="k">if</span> <span class="p">!</span><span class="nx">has</span><span class="p">(</span><span class="s1">&#39;nvim&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">g</span>:<span class="nx">lsp_diagnostics_float_cursor</span> <span class="p">=</span> <span class="m">1</span><span class="err">
</span><span class="err"></span><span class="k">endif</span><span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">g</span>:<span class="nx">lsp_log_file</span> <span class="p">=</span> <span class="s1">&#39;&#39;</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">g</span>:<span class="nx">lsp_settings</span> <span class="p">=</span> {<span class="err">
</span><span class="err"></span>      \ <span class="s1">&#39;efm-langserver&#39;</span>: {<span class="err">
</span><span class="err"></span>      \   <span class="s1">&#39;disabled&#39;</span>: <span class="m">0</span><span class="p">,</span><span class="err">
</span><span class="err"></span>      \   <span class="s1">&#39;allowlist&#39;</span>: [<span class="s1">&#39;markdown&#39;</span>]<span class="p">,</span><span class="err">
</span><span class="err"></span>      \  }<span class="err">
</span><span class="err"></span>      \ }<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">on_lsp_buffer_enabled</span><span class="p">()</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>  <span class="nx">setlocal</span> <span class="nx">completeopt</span><span class="p">=</span><span class="nx">menu</span><span class="err">
</span><span class="err"></span>  <span class="nx">setlocal</span> <span class="nx">omnifunc</span><span class="p">=</span><span class="nx">lsp</span>#<span class="nx">complete</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nx">augroup</span> <span class="nx">lsp_install</span><span class="err">
</span><span class="err"></span>  <span class="nx">au</span><span class="p">!</span><span class="err">
</span><span class="err"></span>  <span class="nx">au</span> <span class="nx">User</span> <span class="nx">lsp_buffer_enabled</span> <span class="nx">call</span> <span class="nx">s</span>:<span class="nx">on_lsp_buffer_enabled</span><span class="p">()</span><span class="err">
</span><span class="err"></span><span class="nx">augroup</span> <span class="nx">END</span><span class="err">
</span><span class="err"></span><span class="c">&#34; }}}</span><span class="err">
</span></code></pre></div><p>最後に<code>textlint</code>をLSPとして動かすために<code>efm-langserver</code>の設定を行います。
<code>~/.config/efm-langserver/config.yaml</code>に次の設定をします。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml:config.yaml" data-lang="yaml:config.yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="m">2</span><span class="w">
</span><span class="w"></span><span class="nt">tools</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">markdown-textlint</span><span class="p">:</span><span class="w"> </span><span class="cp">&amp;markdown-textlint</span><span class="w">
</span><span class="w">    </span><span class="nt">lint-command</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;npx --no-install textlint -f unix --stdin --stdin-filename ${INPUT}&#39;</span><span class="w">
</span><span class="w">    </span><span class="nt">lint-ignore-exit-code</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="w">    </span><span class="nt">lint-stdin</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="w">    </span><span class="nt">lint-formats</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="nt">&#39;%f:%l:%c</span><span class="p">:</span><span class="w"> </span><span class="l">%m [%trror/%r]&#39;</span><span class="w">
</span><span class="w">    </span><span class="nt">root-markers</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">.textlintrc</span><span class="w">
</span><span class="w"></span><span class="nt">languages</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">markdown</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">&lt;&lt;</span><span class="p">:</span><span class="w"> </span><span class="cp">*markdown-textlint</span><span class="w">
</span></code></pre></div><p>これで設定は終わりです。Vim/NeovimでMarkdownのファイルを開くと次のようにtextlintの指摘が表示されます。
編集、保存するたびに<code>efm-langserver</code>が<code>textlint</code>を実行しその結果を返してくれるので記事を書きながら校正できます。</p>
<p><img src="https://i.gyazo.com/20662c65af0d9c33e5fac45cfec42491.png" alt=""></p>
<h3 id="画像アップロード">画像アップロード</h3>
<p>zenn.devやQiitaはそれぞれ、Webエディタ上で<code>Ctrl(Cmd)+v</code>を使うとクリップボードから画像をアップロード&amp;リンクを挿入してくれます。
これはすばらしい機能と体験ですが、残念ながらVim/Neovimはそのような機能を持っていません。</p>
<p>そこで、Vim/Neovimでクリップボードから画像をアップロード&amp;リンクを挿入してくれるプラグイン<a href="https://github.com/skanehira/gyazo.vim">gyazo.vim</a>を作りました。
画像のアップロード先は<a href="https://gyazo.com">Gyazo</a>になるので別途アカウント&amp;トークンを取得する必要はありますが、次のようにスクショを撮ってそのままアップロードできるので要件を満たせます。</p>
<p><img src="https://i.gyazo.com/2adcdcc57f144bd524bc29bd1affbe75.gif" alt=""></p>
<h2 id="終わりに">終わりに</h2>
<p>これらの設定でだいぶ執筆環境が整って捗りました。今回はMarkdownだけ動くようにしていますが、ほかの拡張子でも動かせます。
少し手間がかかりますが、Vimmerで同じように不便を感じている方はぜひ試してみてください。</p>
]]></content></item><item><title>Goで作ったライブラリのバージョンアップ手順</title><link>https://skanehira.github.io/blog/posts/20201112-go-versionup-library/</link><pubDate>Thu, 12 Nov 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20201112-go-versionup-library/</guid><description>初めに 以前Goでクリップボードから画像を取得&amp;amp;保存できるライブラリclipboard-imageを作りました。 ただ、関数名が気に入ら</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>以前Goでクリップボードから画像を取得&amp;保存できるライブラリ<a href="https://github.com/skanehira/clipboard-image">clipboard-image</a>を作りました。</p>
<p>ただ、関数名が気に入らなかったので名前を変えてv1-&gt;v2にアップして<code>go get</code>したら次のエラーが出ました。</p>
<pre><code>go get github.com/skanehira/clipboard-image@v2.0.0: github.com/skanehira/clipboard-image@v2.0.0: invalid version: module contains a go.mod file, so major version must be compatible: should be v0 or v1, not v2
</code></pre><p><code>go modules</code>を使っているからなのか、少々面倒だったのでv1以上にする手順を残しておきます。</p>
<h3 id="手順">手順</h3>
<p>以下通りにやれば、バージョンアップできるはずです。</p>
<ol>
<li>
<p>ライブラリの<code>go.mod</code>に<code>/v2</code>をつける
変更前</p>
<pre><code>module github.com/skanehira/clipboard-image
</code></pre><p>変更後</p>
<pre><code>module github.com/skanehira/clipboard-image/v2
</code></pre></li>
<li>
<p>タグをつけてpush</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">git tag v2.0.0
git push origin --tags
</code></pre></div></li>
<li>
<p>利用する側で<code>go get module/v2</code></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">go get github.com/skanehira/clipboard-image/v2
</code></pre></div></li>
<li>
<p>importにバージョンをつける</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
 <span class="s">&#34;github.com/skanehira/clipboard-image/v2&#34;</span>
<span class="p">)</span>
</code></pre></div></li>
</ol>
<h3 id="解説">解説</h3>
<p>どうやら<code>go modules</code>を使っているライブラリをv1以上にする場合は、<code>module@2.0.0</code>ではなく<code>module/v2</code>というふうに<code>go.mod</code>に定義する必要があるようです。
詳細は参考文献の<code>go get の動作メモ</code>を参照ください。</p>
<h3 id="参考文献">参考文献</h3>
<ul>
<li><a href="https://www.kaoriya.net/blog/2020/06/13/">go get の動作メモ</a></li>
<li><a href="https://proxy.golang.org">Go Module Mirror, Index, and Checksum Database</a> のFAQ</li>
</ul>
]]></content></item><item><title>Vimで現在行のコミットIDからGitHubのPRを開く</title><link>https://skanehira.github.io/blog/posts/20201104-vim-getpr/</link><pubDate>Wed, 04 Nov 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20201104-vim-getpr/</guid><description>初めに 先日getprというコミットIDからPRのリンク取得できるCLIを作りました。 CLIだけだとちょっと使い勝手が良くないので、Vimで使</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>先日<a href="https://github.com/skanehira/getpr">getpr</a>というコミットIDからPRのリンク取得できるCLIを作りました。
CLIだけだとちょっと使い勝手が良くないので、Vimで使いやすいようにプラグインを作りました。</p>
<p><img src="https://i.imgur.com/QBtn4LD.gif" alt=""></p>
<p>使い方は簡単で、<code>:GetprOpen</code>でPRのリンクを開く、<code>:GetprYank</code>でレジスタにヤンクします。
もともと<code>getpr</code>を作ったのはバグの原因となった行のPRを開きたかったので、Vimでそれを手軽にできるようにしたという感じです。</p>
<h3 id="実装">実装</h3>
<p>実装は簡単で、現在行を<code>line('.')</code>で取得して、それを使って<code>git blame</code>からコミットを抽出します。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">let</span> <span class="nx">line</span> <span class="p">=</span> <span class="nx">line</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">blame_line</span> <span class="p">=</span> <span class="nx">system</span><span class="p">(</span><span class="nx">printf</span><span class="p">(</span><span class="s1">&#39;git blame -L %s,%s -- %s&#39;</span><span class="p">,</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">file</span><span class="p">))</span><span class="err">
</span></code></pre></div><p>行を取得できたら、あとは半角スペースで区切って1つ目のコミットidを取得します。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">let</span> <span class="nx">id</span> <span class="p">=</span> <span class="nx">blame_line</span><span class="p">-&gt;</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>[<span class="m">0</span>]<span class="err">
</span></code></pre></div><p>あとは<code>getpr</code>に渡せばリンクを取れます。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">let</span> <span class="nx">url</span> <span class="p">=</span> <span class="nx">system</span><span class="p">(</span><span class="nx">printf</span><span class="p">(</span><span class="s1">&#39;%s %s&#39;</span><span class="p">,</span> <span class="s1">&#39;getpr&#39;</span><span class="p">,</span> <span class="nx">id</span><span class="p">))-&gt;</span><span class="nx">trim</span><span class="p">()</span><span class="err">
</span></code></pre></div><p><code>getpr.vim</code>はキーマップを2つ提供していて、これをつかって次のように設定すればコマンド打たずに簡単にPRを開けるので、だいぶ手間が省けます。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="nx">map</span> <span class="nx">go</span> <span class="p">&lt;</span><span class="nx">Plug</span><span class="p">&gt;(</span><span class="nx">getpr</span><span class="p">-</span><span class="nx">open</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nx">map</span> <span class="nx">gy</span> <span class="p">&lt;</span><span class="nx">Plug</span><span class="p">&gt;(</span><span class="nx">getpr</span><span class="p">-</span><span class="nx">yank</span><span class="p">)</span><span class="err">
</span></code></pre></div><p>ぜひお試しください。</p>
<h3 id="おまけ">おまけ</h3>
<p>普段ぼくは<a href="https://github.com/lambdalisue/gina.vim">gina.vim</a>というプラグインを使っていますが、このプラグインも<code>git blame</code>の機能があります。</p>
<p><img src="https://storage.googleapis.com/zenn-user-upload/rem3ozqyrb1i2syb5aip5zr8l0q5" alt=""></p>
<p>次のようにカスタマイズすれば、<code>gina</code>の<code>blame</code>バッファで<code>&lt;C-o&gt;</code>を押すとそのPRのリンクを開けます。<code>gina</code>ユーザーはぜひお試しください。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="nx">call</span> <span class="nx">gina</span>#<span class="nx">custom</span>#<span class="nx">mapping</span>#<span class="nx">nmap</span><span class="p">(</span><span class="err">
</span><span class="err"></span>      \ <span class="s1">&#39;blame&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;C-o&gt;&#39;</span><span class="p">,</span><span class="err">
</span><span class="err"></span>      \ <span class="s1">&#39;:&lt;C-u&gt;call GinaOpenPR()&lt;CR&gt;&#39;</span><span class="p">,</span><span class="err">
</span><span class="err"></span>      \ {<span class="s1">&#39;silent&#39;</span>: <span class="m">1</span>}<span class="p">,</span><span class="err">
</span><span class="err"></span>      \<span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">s</span>:<span class="nx">cmd</span> <span class="p">=</span> <span class="s1">&#39;open&#39;</span><span class="err">
</span><span class="err"></span><span class="k">if</span> <span class="nx">has</span><span class="p">(</span><span class="s1">&#39;linux&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">s</span>:<span class="nx">cmd</span> <span class="p">=</span> <span class="s1">&#39;xdg-open&#39;</span><span class="err">
</span><span class="err"></span><span class="k">elseif</span> <span class="nx">has</span><span class="p">(</span><span class="s1">&#39;win64&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">s</span>:<span class="nx">cmd</span> <span class="p">=</span> <span class="s1">&#39;cmd /c start&#39;</span><span class="err">
</span><span class="err"></span><span class="k">endif</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">function</span><span class="p">!</span> <span class="nx">GinaOpenPR</span><span class="p">()</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">can</span> <span class="p">=</span> <span class="nx">gina</span>#<span class="nx">action</span>#<span class="nx">candidates</span><span class="p">()</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">url</span> <span class="p">=</span> <span class="nx">system</span><span class="p">(</span><span class="nx">printf</span><span class="p">(</span><span class="s1">&#39;%s %s&#39;</span><span class="p">,</span> <span class="s1">&#39;getpr&#39;</span><span class="p">,</span> <span class="nx">can</span>[<span class="m">0</span>].<span class="nx">rev</span><span class="p">))-&gt;</span><span class="nx">trim</span><span class="p">()</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">system</span><span class="p">(</span><span class="nx">printf</span><span class="p">(</span><span class="s1">&#39;%s %s&#39;</span><span class="p">,</span> <span class="nx">s</span>:<span class="nx">cmd</span><span class="p">,</span> <span class="nx">url</span><span class="p">))</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span></code></pre></div>]]></content></item><item><title>コミットIDからGitHubのPRリンクを取得するCLI</title><link>https://skanehira.github.io/blog/posts/20201104-go-get-github-pr-url/</link><pubDate>Wed, 04 Nov 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20201104-go-get-github-pr-url/</guid><description>初めに 普段GitHubを使って仕事で、次のフローで開発をしています。 PRを出す レビュー マージ そして、たまにバグを見つけるので、git blam</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>普段GitHubを使って仕事で、次のフローで開発をしています。</p>
<ol>
<li>PRを出す</li>
<li>レビュー</li>
<li>マージ</li>
</ol>
<p>そして、たまにバグを見つけるので、<code>git blame</code>を使ってどのコミットが原因なのかを特定することがありますが、どのPRなのかまで知りたいことがあります。</p>
<p>そこで、GitHub限定ではありますが、コミットIDからPRのリンクを取得できるCLIを作りました。
本記事はその紹介と作るに至るまでの過程について書きました。</p>
<h2 id="cliについて">CLIについて</h2>
<p>Goで<a href="https://github.com/skanehira/getpr">getpr</a>というCLIを作りました。</p>
<p><img src="https://i.imgur.com/VrXQw15.gif" alt=""></p>
<p>使い方引数にコミットIDを指定するだけです。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ getpr 02b3cb3
https://github.com/skanehira/getpr/pull/2
</code></pre></div><p>特定のリポジトリを指定することもできます。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ getpr skanehira/getpr 02b3cb3
https://github.com/skanehira/getpr/pull/2
</code></pre></div><h2 id="コミットidからprを取得する方法">コミットIDからPRを取得する方法</h2>
<p>このCLIを作るまで結構試行錯誤していました。
<a href="https://qiita.com/awakia/items/f14dc6310e469964a8f7">こちら</a>を見るとコミットメッセージに<code>Merge pull request #</code>があれば、PRの番号を取得できます。
番号さえわかればあとはURLを組み立てるだけですので割と簡単ですが、問題点はマージだけどメッセージが<code>Merge pull request</code>になっていない場合です。</p>
<p>たとえば、squashマージする際はメッセージが変わります。このようにメッセージから取得するとどうしても溢れるケースが出てきます。
特に僕はプロジェクトでsquashマージするのでむしろこのやり方ではPRのリンクを取れないです。</p>
<p>squashマージでもメッセージからPR番号を取ることはできますが、結局の所メッセージに依存してしまうので、根本解決できない問題は変わらないです。</p>
<h2 id="githubのblame">GitHubのblame</h2>
<p>GitHubにはblame機能があって、画像のようにコミットの詳細にPRのリンクが表示されたりします。</p>
<p><img src="https://storage.googleapis.com/zenn-user-upload/telwvr0au8eka1mpx4oinnl0xm17" alt=""></p>
<p>これはつまりGitHubがコミットとPRのリレーションを持っているということでもあります。
であれば、GitHubのAPIから取れるのではないか考え調べたところ、取れることがわかりました。</p>
<h2 id="コミットidからprを取得">コミットIDからPRを取得</h2>
<p><a href="https://github.community/t/find-a-commit-by-oid-sha-via-graphql-v4-api/14118/9">こちら</a>を見ると、GitHubのv4のAPIを使えば次のようにコミットIDから関連のPR情報を取得できます。</p>
<div class="highlight"><pre class="chroma"><code class="language-graphql" data-lang="graphql"><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="py">repository</span><span class="p">(</span><span class="py">owner</span><span class="p">:</span><span class="w"> </span><span class="s">&#34;skanehira&#34;</span><span class="p">,</span><span class="w"> </span><span class="nc">name</span><span class="p">:</span><span class="w"> </span><span class="s">&#34;getpr&#34;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="nc">object</span><span class="p">(</span><span class="py">expression</span><span class="p">:</span><span class="w"> </span><span class="s">&#34;02b3cb3&#34;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="kd">...</span><span class="w"> </span><span class="nc">on</span><span class="w"> </span><span class="py">Commit</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="py">associatedPullRequests</span><span class="p">(</span><span class="py">first</span><span class="p">:</span><span class="w"> </span><span class="nc">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">          </span><span class="py">nodes</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="py">url</span><span class="w">
</span><span class="w">          </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">      </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>あとはこれをGoで実装すればよいだけですので、それほど難しくありません。
実際データを取得する部分の実装は次だけです。とてもシンプルです。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">getPullRequest</span><span class="p">(</span><span class="nx">owner</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">id</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">PullRequest</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">q</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">Repository</span> <span class="kd">struct</span> <span class="p">{</span>
			<span class="nx">Object</span> <span class="kd">struct</span> <span class="p">{</span>
				<span class="nx">Commit</span> <span class="kd">struct</span> <span class="p">{</span>
					<span class="nx">AssociatedPullRequests</span> <span class="kd">struct</span> <span class="p">{</span>
						<span class="nx">Nodes</span> <span class="p">[]</span><span class="nx">PullRequest</span>
					<span class="p">}</span> <span class="s">`graphql:&#34;associatedPullRequests(first: 1)&#34;`</span>
				<span class="p">}</span> <span class="s">`graphql:&#34;... on Commit&#34;`</span>
			<span class="p">}</span> <span class="s">`graphql:&#34;object(expression: $id)&#34;`</span>
		<span class="p">}</span> <span class="s">`graphql:&#34;repository(owner: $owner, name: $name)&#34;`</span>
	<span class="p">}</span>

	<span class="nx">variables</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
		<span class="s">&#34;id&#34;</span><span class="p">:</span>    <span class="nx">githubv4</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">id</span><span class="p">),</span>
		<span class="s">&#34;owner&#34;</span><span class="p">:</span> <span class="nx">githubv4</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">owner</span><span class="p">),</span>
		<span class="s">&#34;name&#34;</span><span class="p">:</span>  <span class="nx">githubv4</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">name</span><span class="p">),</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="o">&amp;</span><span class="nx">q</span><span class="p">,</span> <span class="nx">variables</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">Repository</span><span class="p">.</span><span class="nx">Object</span><span class="p">.</span><span class="nx">Commit</span><span class="p">.</span><span class="nx">AssociatedPullRequests</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;not found pull request&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">q</span><span class="p">.</span><span class="nx">Repository</span><span class="p">.</span><span class="nx">Object</span><span class="p">.</span><span class="nx">Commit</span><span class="p">.</span><span class="nx">AssociatedPullRequests</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h2 id="後日談">後日談</h2>
<p>この記事を書いている最中に<a href="https://qiita.com/kyoshidajp/items/18d5385ef8375c7bcd14">こちら</a>を見つけて車輪の再開発だったことが判明しました。
いろいろと勉強になったので、プロジェクト外での車輪の再開発は悪いことばかりではないですが、ちょっと悔しかったのは内緒です。</p>
]]></content></item><item><title>tmuxのpopupが便利</title><link>https://skanehira.github.io/blog/posts/20201025-tmux-toggle-popup/</link><pubDate>Sun, 25 Oct 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20201025-tmux-toggle-popup/</guid><description>初めに 仕事で複数プロジェクトを同時に使っていることが多く、tmuxを愛用しています。 tmuxを使えば、簡易に画面を増やしたり分割したりできま</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>仕事で複数プロジェクトを同時に使っていることが多く、<code>tmux</code>を愛用しています。
<code>tmux</code>を使えば、簡易に画面を増やしたり分割したりできますが、次のような不便さを感じるときがあります。</p>
<ul>
<li>画面分割すると画面サイズが小さくなる</li>
<li>画面数が増えるとよく使うプロジェクトの画面をすぐ出せない</li>
</ul>
<p>そこで、最近入ったpopup機能を使ってみたところ上記の課題を解決できそうだったので、軽く紹介をしていきます。
こんな感じで画面分割ではなく、画面中央にウィンドウを出せます。</p>
<p><img src="https://storage.googleapis.com/zenn-user-upload/u63jvksh7pulaw5lg843r3v5k89g" alt=""></p>
<h2 id="やり方">やり方</h2>
<p>筆者の環境は次になっています。</p>
<ul>
<li>tmux next-3.3</li>
<li>fish version 3.1.2</li>
</ul>
<p><a href="https://twitter.com/yutakatay">@yutakatayさん</a>から教えていただいたものをベースにfishの関数を用意します。
bashやzshの方は適宜変えてみてください。</p>
<div class="highlight"><pre class="chroma"><code class="language-fish:tmuxpopup.fish" data-lang="fish:tmuxpopup.fish"><span class="k">function</span> tmuxpopup -d <span class="s2">&#34;toggle tmux popup window&#34;</span>
  <span class="k">set</span> width <span class="s1">&#39;80%&#39;</span>
  <span class="k">set</span> height <span class="s1">&#39;80%&#39;</span>
  <span class="k">set</span> session <span class="o">(</span>tmux display-message -p -F <span class="s2">&#34;#{session_name}&#34;</span><span class="o">)</span>
  <span class="k">if</span> <span class="nb">contains</span> <span class="s2">&#34;popup&#34;</span> <span class="nv">$session</span>
    tmux detach-client
  <span class="k">else</span>
    tmux popup -d <span class="s1">&#39;#{pane_current_path}&#39;</span> -xC -yC -w<span class="nv">$width</span> -h<span class="nv">$height</span> -K -E -R <span class="s2">&#34;tmux attach -t popup || tmux new -s popup&#34;</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>上記を用意したら、<code>tmuxpopup</code>を実行すると画面中央にウィンドウが表示されます。関数の動きは次の通りです。</p>
<ol>
<li>今のセッションがpopupセッションならdetach</li>
<li>popupセッションがなければ新規作成、あればattachする</li>
</ol>
<p>あとはtmuxのキーバインドを設定します。</p>
<pre><code class="language-fish:tmux.conf" data-lang="fish:tmux.conf">bind -n C-q run-shell &quot;fish -c \&quot;tmuxpopup\&quot;&quot;
</code></pre><p>これでいつでも<code>C-q</code>でpopupをtoggleできます。</p>
<h2 id="最後に">最後に</h2>
<p><code>tmux</code>はやはり便利ですね。</p>
]]></content></item><item><title>xormでマイクロ秒の日付保存でハマった話</title><link>https://skanehira.github.io/blog/posts/20201023-xorm-cannot-use-microsecond/</link><pubDate>Fri, 23 Oct 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20201023-xorm-cannot-use-microsecond/</guid><description>始め GoのxormというORMとMySQLを仕事で使っていますが、 マイクロ秒の日付を保存できないという謎の動きをしていたので、調査と対処をし</description><content type="html"><![CDATA[<h2 id="始め">始め</h2>
<p>Goの<a href="https://gitea.com/xorm/xorm">xorm</a>という<code>ORM</code>と<code>MySQL</code>を仕事で使っていますが、
マイクロ秒の日付を保存できないという謎の動きをしていたので、調査と対処をしたというお話です。</p>
<h2 id="結論">結論</h2>
<p>2020/10/23時点<code>xorm</code>は<code>Microsoft SQL Server</code>以外のRDBにマイクロ秒の日付を保存できません。</p>
<h2 id="旅の始まり">旅の始まり</h2>
<p>仕事で次のカラムに<code>time.Time</code>のデータを保存しようとしたら、マイクロ秒のところが0のままなっていました。</p>
<pre><code>mysql&gt; desc t;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| date  | datetime(6) | NO   |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+

mysql&gt; select * from t;
+----------------------------+
| date                       |
+----------------------------+
| 2020-10-23 23:00:47.000000 |
+----------------------------+
</code></pre><p>ためしに普通にSQLを発行してみたところ、問題なくマイクロ秒が挿入されていたのでこれはコードもしくは<code>xorm</code>が原因かなと疑い始めました。</p>
<pre><code>mysql&gt; insert into t (date) values(now(6));
Query OK, 1 row affected (0.00 sec)

mysql&gt; select * from t;
+----------------------------+
| date                       |
+----------------------------+
| 2020-10-23 23:00:47.000000 |
| 2020-10-23 23:02:21.793967 |
+----------------------------+
</code></pre><h3 id="コードが悪いのかそれともxormが悪いのか">コードが悪いのか、それとも<code>xorm</code>が悪いのか</h3>
<p>DBは問題ないなら自分が悪いのかなと疑い初めて、
次の小さなサンプルコードを動かしてみたところ、マイクロ秒が入りませんでした。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">engine</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">xorm</span><span class="p">.</span><span class="nf">NewEngine</span><span class="p">(</span><span class="s">&#34;mysql&#34;</span><span class="p">,</span> <span class="s">&#34;gorilla:gorilla@/gorilla?charset=utf8&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">t</span> <span class="o">:=</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Date</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
<span class="p">}{</span>
	<span class="nx">Date</span><span class="p">:</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">(),</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">engine</span><span class="p">.</span><span class="nf">Table</span><span class="p">(</span><span class="s">&#34;t&#34;</span><span class="p">).</span><span class="nf">Insert</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="xormへ"><code>xorm</code>へ</h3>
<p>こうなると<code>xorm</code>だなと思って<code>xorm</code>コードを読み始めました。
<code>xorm</code>で<code>time.Time</code>を変換している箇所があるはずですので、<code>Insert</code>メソッドからたどれば良さそうと思って潜ったら次の処理を見つけました。</p>
<div class="highlight"><pre class="chroma"><code class="language-go:internal/statements/values.go" data-lang="go:internal/statements/values.go"><span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Struct</span><span class="p">:</span>
	<span class="k">if</span> <span class="nx">fieldType</span><span class="p">.</span><span class="nf">ConvertibleTo</span><span class="p">(</span><span class="nx">schemas</span><span class="p">.</span><span class="nx">TimeType</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">t</span> <span class="o">:=</span> <span class="nx">fieldValue</span><span class="p">.</span><span class="nf">Convert</span><span class="p">(</span><span class="nx">schemas</span><span class="p">.</span><span class="nx">TimeType</span><span class="p">).</span><span class="nf">Interface</span><span class="p">().(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span>
		<span class="nx">tf</span> <span class="o">:=</span> <span class="nx">dialects</span><span class="p">.</span><span class="nf">FormatColumnTime</span><span class="p">(</span><span class="nx">statement</span><span class="p">.</span><span class="nx">dialect</span><span class="p">,</span> <span class="nx">statement</span><span class="p">.</span><span class="nx">defaultTimeZone</span><span class="p">,</span> <span class="nx">col</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">tf</span><span class="p">,</span> <span class="kc">nil</span>
</code></pre></div><p><code>dialects.FormatColumnTime</code>ってメソッドがいかにもそれっぽいなと思って中を覗いたらビンゴでした。
<code>FormatTime</code>関数が日付のフォーマットを生成していて、しかも<code>schemas.DateTime</code>の場合は秒までのフォーマットになっていました。</p>
<div class="highlight"><pre class="chroma"><code class="language-go:dialects/time.go" data-lang="go:dialects/time.go"><span class="c1">// FormatTime format time as column type
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">FormatTime</span><span class="p">(</span><span class="nx">dialect</span> <span class="nx">Dialect</span><span class="p">,</span> <span class="nx">sqlTypeName</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">t</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">sqlTypeName</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">schemas</span><span class="p">.</span><span class="nx">Time</span><span class="p">:</span>
		<span class="nx">s</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Format</span><span class="p">(</span><span class="s">&#34;2006-01-02 15:04:05&#34;</span><span class="p">)</span> <span class="c1">// time.RFC3339
</span><span class="c1"></span>		<span class="nx">v</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">11</span><span class="p">:</span><span class="mi">19</span><span class="p">]</span>
	<span class="k">case</span> <span class="nx">schemas</span><span class="p">.</span><span class="nx">Date</span><span class="p">:</span>
		<span class="nx">v</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Format</span><span class="p">(</span><span class="s">&#34;2006-01-02&#34;</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">schemas</span><span class="p">.</span><span class="nx">DateTime</span><span class="p">,</span> <span class="nx">schemas</span><span class="p">.</span><span class="nx">TimeStamp</span><span class="p">,</span> <span class="nx">schemas</span><span class="p">.</span><span class="nx">Varchar</span><span class="p">:</span> <span class="c1">// !DarthPestilane! format time when sqlTypeName is schemas.Varchar.
</span><span class="c1"></span>		<span class="nx">v</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Format</span><span class="p">(</span><span class="s">&#34;2006-01-02 15:04:05&#34;</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">schemas</span><span class="p">.</span><span class="nx">TimeStampz</span><span class="p">:</span>
		<span class="k">if</span> <span class="nx">dialect</span><span class="p">.</span><span class="nf">URI</span><span class="p">().</span><span class="nx">DBType</span> <span class="o">==</span> <span class="nx">schemas</span><span class="p">.</span><span class="nx">MSSQL</span> <span class="p">{</span>
			<span class="nx">v</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Format</span><span class="p">(</span><span class="s">&#34;2006-01-02T15:04:05.9999999Z07:00&#34;</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">v</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Format</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">RFC3339Nano</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="nx">schemas</span><span class="p">.</span><span class="nx">BigInt</span><span class="p">,</span> <span class="nx">schemas</span><span class="p">.</span><span class="nx">Int</span><span class="p">:</span>
		<span class="nx">v</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Unix</span><span class="p">()</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nx">v</span> <span class="p">=</span> <span class="nx">t</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>そんなことあるのかとびっくりしましたが、現実は残酷なものです。受け入れて対処しなければいけません。</p>
<h3 id="パッチを書く">パッチを書く</h3>
<p>このままだとお仕事困ってしまうので、パッチを書くしかないかなと悩んでいました。
ちょうど同じ現象に遭遇して、すでに<a href="https://gitea.com/xorm/xorm/pulls/1655">PR</a>を出していた<a href="twitter.com/kaoriya">KoRoN</a>さんのコードがあったので、
少し拝借してテストも書いて<a href="https://gitea.com/xorm/xorm/pulls/1815">PR</a>を投げました。</p>
<p>対処方法はシンプルで、PostgreSQLとMySQLで<code>TimeStamp</code>と<code>DateTime</code>型のときは日付フォーマットをマイクロ秒までにするだけです。</p>
<div class="highlight"><pre class="chroma"><code class="language-diff" data-lang="diff"><span class="gd">-	case schemas.DateTime, schemas.TimeStamp, schemas.Varchar: // !DarthPestilane! format time when sqlTypeName is schemas.Varchar.
</span><span class="gd"></span><span class="gi">+	case schemas.Varchar: // !DarthPestilane! format time when sqlTypeName is schemas.Varchar.
</span><span class="gi"></span> 		v = t.Format(&#34;2006-01-02 15:04:05&#34;)
<span class="gi">+	case schemas.TimeStamp, schemas.DateTime:
</span><span class="gi">+		dbType := dialect.URI().DBType
</span><span class="gi">+		if dbType == schemas.POSTGRES || dbType == schemas.MYSQL {
</span><span class="gi">+			v = t.Format(&#34;2006-01-02T15:04:05.999999&#34;)
</span><span class="gi">+		} else {
</span><span class="gi">+			v = t.Format(&#34;2006-01-02 15:04:05&#34;)
</span><span class="gi">+		}
</span><span class="gi"></span> 	case schemas.TimeStampz:
 		if dialect.URI().DBType == schemas.MSSQL {
 			v = t.Format(&#34;2006-01-02T15:04:05.9999999Z07:00&#34;)
</code></pre></div><h3 id="動かしてみる">動かしてみる</h3>
<p>まだ本体へマージされていないのですが、上記修正で無事動きました。めでたい。
<img src="https://storage.googleapis.com/zenn-user-upload/xdv2ykyzwztdcjctbupfttt18fk1" alt=""></p>
<h3 id="最後に">最後に</h3>
<p>やれることはやったので、後は神頼みするしかないです。
はやくマージしてほしい。</p>
]]></content></item><item><title>tmuxで選択したテキストを画像化&amp;クリップボードにコピー</title><link>https://skanehira.github.io/blog/posts/20201012-tmux-generate-img/</link><pubDate>Mon, 12 Oct 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20201012-tmux-generate-img/</guid><description>始めに tmuxで選択した範囲のテキストを画像にしてクリップボードにコピーしたいことがたまにあります。 ちょうど、tmuxにはコピーモードでテキ</description><content type="html"><![CDATA[<h2 id="始めに">始めに</h2>
<p>tmuxで選択した範囲のテキストを画像にしてクリップボードにコピーしたいことがたまにあります。
ちょうど、tmuxにはコピーモードでテキストをコピーする方法があるので、あとはコマンドを用意すれば実現できそうだなと思ってやってみました。</p>
<h2 id="やり方">やり方</h2>
<p>ゴリラ製の<a href="https://github.com/skanehira/code2img">code2img</a>をインストールして、tmux.confに次の設定をします。</p>
<pre><code># コピーモードでvimキーバインドを使う
setw -g mode-keys vi

# 選択範囲を画像化
bind-key -T copy-mode-vi C-i send-keys -X copy-pipe-and-cancel &quot;code2img -c -ext sh&quot;
</code></pre><p>あとはtmuxを再起動して、範囲選択したら<code>Ctrl + i</code>で画像がクリップボードにコピーされます。キーバインドはご自由に変えてください。</p>
<h2 id="余談">余談</h2>
<p>Vimで選択したテキストを画像化したいときは<a href="https://github.com/skanehira/code2img.vim">code2img.vim</a>を使うと便利です。
お試しください。</p>
]]></content></item><item><title>VimでUMLをプレビュー</title><link>https://skanehira.github.io/blog/posts/20201010-vim-uml-preview/</link><pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20201010-vim-uml-preview/</guid><description>始めに 先日 Vimでマインドマップをプレビュー という記事を書きました。 その前後に、フォロワーさんからUMLをプレビューできる vim-slumlord ってのを教えても</description><content type="html"><![CDATA[<h2 id="始めに">始めに</h2>
<p>先日 <a href="https://zenn.dev/skanehira/articles/2020-10-07-vim-write-plantuml">Vimでマインドマップをプレビュー</a> という記事を書きました。
その前後に、フォロワーさんからUMLをプレビューできる <a href="https://github.com/scrooloose/vim-slumlord">vim-slumlord</a> ってのを教えてもらいました。</p>
<p>リンク先のGIFを見たらとてもよさそうでしたが、2年以上更新されていなくてかつJavaの実行環境が必要でした。
UMLを書くためにわざわざJavaの環境を作りたくない、dockerで実行のイメージを用意するのもアリですが、
プレビューなのでこまめに保存することを考えるとオーバーヘッドが気になってしまいます。</p>
<h3 id="じゃあ作るか">じゃあ作るか</h3>
<p>自分のニーズに合わないと感じたので、じゃあ自作するかと思って <a href="https://github.com/skanehira/preview-uml.vim">preview-uml.vim</a> を作りました。</p>
<p><img src="https://i.imgur.com/9Uyr1xC.gif" alt=""></p>
<h3 id="しくみ">しくみ</h3>
<p>図の生成は<code>plantuml server</code>に任せています。なのでserverをローカルもしくは<a href="http://www.plantuml.com/plantuml">外部のサーバー</a>を使うかの2択があります。基本プロダクトでは情報を外部サーバに、送らないようにすべきなのでローカルでサーバを用意すると良いでしょう。
dockerがあれば次のコマンドで簡単にローカルサーバをサクッと用意できます。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker run -d -p 8888:8080 plantuml/plantuml-server:jetty
</code></pre></div><p>あとは、Vimから<code>curl</code>でサーバにテキストを送信すれば、図を取得できます。
ただ、図を取得するのがちょっと面倒で、次の処理をしないと行けないです。</p>
<ol>
<li><code>curl</code>でテキストを送信</li>
<li>レスポンスヘッダのLocationからURLを抜き出して、アスキーアートを取得できるURLに変換</li>
<li><code>curl</code>で2のURLからデータを取得</li>
</ol>
<p>これをシェルで書くと次のとおりです。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ curl -s -i -X POST http://localhost:8888 -d <span class="s2">&#34;text=@startuml
</span><span class="s2">Alice -&gt; Bob
</span><span class="s2">@enduml
</span><span class="s2">&#34;</span>
HTTP/1.1 <span class="m">302</span> Found
Location: http://localhost:8888/uml/Syp9J4vLqBLJSCfF0W00
Content-Length: <span class="m">0</span>
Server: Jetty<span class="o">(</span>9.4.31.v20200723<span class="o">)</span>

$ curl -s http://localhost:8888/txt/Syp9J4vLqBLJSCfF0W00
     ┌─────┐          ┌───┐
     │Alice│          │Bob│
     └──┬──┘          └─┬─┘
        │               │
        │──────────────&gt;│
     ┌──┴──┐          ┌─┴─┐
     │Alice│          │Bob│
     └─────┘          └───┘
</code></pre></div><p>一発でアスキーアートのURLを取得できる方法があればよいんですが、調べた限りではなさそうです。
どなたか、ご存じでしたら教えてください。</p>
<p>あとは上記の処理をVim scriptから実行して、レスポンスをバッファに書き込むだけなので実装はとてもシンプルです。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">update</span><span class="p">()</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">body</span> <span class="p">=</span> <span class="nx">getline</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="s1">&#39;$&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="k">if</span> <span class="nx">empty</span><span class="p">(</span><span class="nx">body</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">return</span><span class="err">
</span><span class="err"></span>  <span class="k">endif</span><span class="err">
</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">cmd</span> <span class="p">=</span> <span class="nx">printf</span><span class="p">(</span><span class="s1">&#39;curl -X POST -s -i %s/form -d &#34;text=%s&#34;&#39;</span><span class="p">,</span> <span class="nx">s</span>:<span class="nx">url</span><span class="p">,</span><span class="err">
</span><span class="err"></span>        \ <span class="nx">body</span><span class="p">-&gt;</span><span class="nx">join</span><span class="p">(</span><span class="s2">&#34;\n&#34;</span><span class="p">)-&gt;</span><span class="nx">escape</span><span class="p">(</span><span class="s1">&#39;&#34;&#39;</span><span class="p">))</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">resp</span> <span class="p">=</span> <span class="nx">systemlist</span><span class="p">(</span><span class="nx">cmd</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">location</span> <span class="p">=</span> <span class="nx">resp</span><span class="p">-&gt;</span><span class="nx">filter</span><span class="p">(</span><span class="s1">&#39;v:val =~ &#34;Location&#34;&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="k">if</span> <span class="nx">empty</span><span class="p">(</span><span class="nx">location</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="p">&lt;</span><span class="nx">SID</span><span class="p">&gt;</span><span class="nx">echo_err</span><span class="p">(</span><span class="s1">&#39;invalid response&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">win_execute</span><span class="p">(</span><span class="nx">s</span>:<span class="nx">preview</span>.<span class="nx">winid</span><span class="p">,</span> <span class="s1">&#39;bw!&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">return</span><span class="err">
</span><span class="err"></span>  <span class="k">endif</span><span class="err">
</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">url</span> <span class="p">=</span> <span class="nx">location</span>[<span class="m">0</span>][<span class="m">10</span>:]<span class="p">-&gt;</span><span class="nx">trim</span><span class="p">()-&gt;</span><span class="nx">substitute</span><span class="p">(</span><span class="s1">&#39;uml&#39;</span><span class="p">,</span> <span class="s1">&#39;txt&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">resp</span> <span class="p">=</span> <span class="nx">systemlist</span><span class="p">(</span><span class="nx">printf</span><span class="p">(</span><span class="s1">&#39;curl -s %s&#39;</span><span class="p">,</span> <span class="nx">url</span><span class="p">))</span><span class="err">
</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">win_execute</span><span class="p">(</span><span class="nx">s</span>:<span class="nx">preview</span>.<span class="nx">winid</span><span class="p">,</span> <span class="s1">&#39;%d_&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">setbufline</span><span class="p">(</span><span class="nx">s</span>:<span class="nx">preview</span>.<span class="nx">bufid</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span></code></pre></div><h3 id="余談">余談</h3>
<p>これまでVSCodeでUMLを書いてきましたが、これでVSCodeとはさよならになりそうかなぁって気がしてます。
でも、多分そんなことないと思われます笑。</p>
<p>ちなみに、ちょうど<a href="https://sendai.gocon.jp">Go Conference'20 in Autumn SENDAI</a>のセッション視聴中に思いついて作り始めたんで途中でセッション諦めました。
もちろん、あとでちゃんと動画を見返しました（えらい）</p>
]]></content></item><item><title>Vimでマインドマップをプレビュー</title><link>https://skanehira.github.io/blog/posts/20201007-vim-write-plantuml/</link><pubDate>Wed, 07 Oct 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20201007-vim-write-plantuml/</guid><description>始めに 思考整理のため、Vimでマインドマップ書けないかなってちょっと調べて試したらできたので、 やり方の備忘録として残しておきます。 必要なもの</description><content type="html"><![CDATA[<h2 id="始めに">始めに</h2>
<p>思考整理のため、Vimでマインドマップ書けないかなってちょっと調べて試したらできたので、
やり方の備忘録として残しておきます。</p>
<h2 id="必要なもの">必要なもの</h2>
<ul>
<li>Docker</li>
<li><a href="https://github.com/previm/previm">previm</a></li>
</ul>
<h2 id="やり方">やり方</h2>
<p><code>previm</code>を導入すればMarkdownをプレビューできますが、Markdownだけではなく<code>plantuml</code>もプレビューしてくれます。
<code>plantuml</code>をプレビューするにはサーバを立て、<code>previm</code>を設定する必要があります。</p>
<p>まず、Dockerを使ってサーバを建てます。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker run -d -p 8888:8080 plantuml/plantuml-server:jetty
</code></pre></div><p>これで<code>plantuml</code>のサーバが起動するので、次に<code>previm</code>の設定をします。
ここで注意点ですがurlは<code>/</code>終わっている必要があります。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">let</span> <span class="nx">g</span>:<span class="nx">previm_plantuml_imageprefix</span> <span class="p">=</span> <span class="s1">&#39;http://localhost:8888/png/&#39;</span><span class="err">
</span></code></pre></div><p>これだけど、プレビュー画面で画像が表示されます。</p>
<p>たとえば次のumlを書いた場合は、スクショのように出力されます。</p>
<blockquote>
<p>```plantuml
@startmindmap
* a
** b
*** c
** d
** f
@endmindmap
```</p>
</blockquote>
<p><img src="https://storage.googleapis.com/zenn-user-upload/facc40opwhn4bg52cmbb68biqntc" alt=""></p>
<h2 id="さいごに">さいごに</h2>
<p><code>previm</code>と<code>plantuml</code> is便利。</p>
]]></content></item><item><title>Vimの:wと:rの便利Tips</title><link>https://skanehira.github.io/blog/posts/20201005-vim-about-rw/</link><pubDate>Mon, 05 Oct 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20201005-vim-about-rw/</guid><description>始めに Vimには:wと:rコマンドがあります。コマンド自体は知っている方が多いかと思います。 ぼく的にちょっと便利な使い方ができるので、それお</description><content type="html"><![CDATA[<h2 id="始めに">始めに</h2>
<p>Vimには<code>:w</code>と<code>:r</code>コマンドがあります。コマンド自体は知っている方が多いかと思います。
ぼく的にちょっと便利な使い方ができるので、それお紹介していこうと思います。</p>
<h2 id="r"><code>:r</code></h2>
<p><code>:r banana.txt</code>でファイルの中身を読み取って、現在のカーソルの次の行に挿入してくれます。
挿入できる行も指定できます。その場合は<code>:{lnum}r banana.txt</code>というふうに先頭に行番号を入力します。</p>
<p><img src="https://storage.googleapis.com/zenn-user-upload/g6g1zofrp56zqr5jrj8znju1dvgy" alt=""></p>
<p>ここからがイチオシですが、実は<code>:r !{cmd}</code>でコマンドの出力も挿入できます。
たとえば、APIのレスポンスをVimでちょっと編集したい場合や、コマンド実行結果を記事に挿入したい場合などに便利です。</p>
<p><img src="https://storage.googleapis.com/zenn-user-upload/7denlktdtsg3yvr22v8l010v8jkx" alt=""></p>
<h2 id="w"><code>:w</code></h2>
<p><code>:w</code>についてVimmerのみなさんなら誰もが知っているコマンドなので説明は省きますが、
実は<code>:w !{cmd}</code>でバッファの内容を外部コマンドの標準入力として渡してくれます。</p>
<p>つまり、標準入力からコードを受け取って実行できるインタプリタがあれば、
<strong>ファイルをいちいち保存しなくても</strong>サクッとコード片を実行できるのです。</p>
<p>たとえば、<code>:w !node</code>ならJavaScriptのコードを実行できるし、<code>:w !bash</code>ならシェルスクリプトを実行できます。</p>
<p>実際に、サンプルコード<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>を実行すると結果が出力されます。</p>
<p><img src="https://storage.googleapis.com/zenn-user-upload/ltv5t73vsbeivd3q659r2lyr3w02" alt=""></p>
<h2 id="rとwの組み合わせ"><code>:r</code>と<code>:w</code>の組み合わせ</h2>
<p>この2つコマンドを組み合わせると、Vimでdockerのコンテナをまとめて停止できたりします。</p>
<p><img src="https://storage.googleapis.com/zenn-user-upload/3ier74brh8ayykfgdotqa2m2klh3" alt=""></p>
<p>この2つのコマンドの詳細は<code>:h :r</code>と<code>:h :w</code>を参照ください。
解説した内容全部書いてあります。</p>
<h2 id="さいごに">さいごに</h2>
<p><code>:r</code>と<code>:w</code>は便利。</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p><a href="https://zenn.dev/uhyo/articles/array-n-keys-yamero">こちら</a>の記事から拝借。 <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></item><item><title>Vim初めて2年間つくったVimプラグインを振り返る</title><link>https://skanehira.github.io/blog/posts/20200928-vim-plugin-made-for-2years/</link><pubDate>Mon, 28 Sep 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200928-vim-plugin-made-for-2years/</guid><description>初めに 最近zenn.devでVimプラグイン周りの記事がいくつか投稿されています。 スニペットプラグインについて 2020 年版 Vim の超軽量ファイラを作っ</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>最近zenn.devでVimプラグイン周りの記事がいくつか投稿されています。</p>
<ul>
<li><a href="https://zenn.dev/shougo/articles/snippet-plugins-2020">スニペットプラグインについて 2020 年版</a></li>
<li><a href="https://zenn.dev/mattn/articles/1da58d6ee91a8e36e690">Vim の超軽量ファイラを作った</a></li>
<li><a href="https://zenn.dev/yutakatay/articles/vim-fuzzy-finder">Vimにたくさんあるファジーファインダー系プラグインを比較してみる</a></li>
<li><a href="https://zenn.dev/lambdalisue/articles/3deb92360546d526381f">2020秋 Vim のファイラー系プラグイン比較</a></li>
</ul>
<p>せっかくだし、2018年の8月ころからVimを使い始めて2年くらい経ったので、これまで作成したVimプラグインを時系列で振り返ってみます。</p>
<h2 id="初めてのプラグイン">初めてのプラグイン</h2>
<p>Vim触り始めて数ヵ月のベイビーVimmerの状態だったが、すっかりVimにハマっていたので、自分でも何かプラグインを作りたいと思っていました。
ちょうどVimのセッション機能を知ったし、これチョット使いやすくできるかもと思って作ったのが<a href="https://github.com/skanehira/vsession">vsession</a>です。</p>
<p>初のプラグイン開発ですので、 <a href="https://qiita.com/aratana_tamutomo/items/4f754c301fb911ff54e8">こちら</a>の記事を参考に作っていましたが、
plugin、autoload、開発フロー周りがよくわからず困っていた記憶があります。
ただ、思ったよりも難しくなかったので、意外とこんなもんかって思ったりしました。</p>
<h2 id="翻訳プラグイン">翻訳プラグイン</h2>
<p>英語苦手なのでよくGoogle翻訳を使っていましたが、Vim上でGoogle翻訳できたら便利と思って、プラグインを作り始めました。
このころpopup window機能が入ったので、オシャレだし新機能だから試してみようと、翻訳したメッセージをpopup windowで表示させていました。</p>
<p>popup window周りをいろいろといじっていたのが記憶に残っています。</p>
<p><img src="https://i.imgur.com/p3WsE8P.gif" alt=""></p>
<h2 id="電車乗換案内プラグイン">電車乗換案内プラグイン</h2>
<p>ある日突然Vimで電車乗り換えを検索できたら便利と思い作りました。</p>
<p>しくみはシンプルに、Yahoo!乗換案内をスクレイピングした情報をpopup windowに表示させていました。
しかしこちらは利用規約に反すると怒られたため非公開となりました。</p>
<p>利用規約、ダイジ、ゼッタイ。</p>
<p>@<a href="https://twitter.com/gorilla0513/status/1140401248115367936">tweet</a></p>
<h2 id="bad-apple"><code>Bad Apple!!</code></h2>
<p>このころは、何でもかんでもVimで何かをやろうと思っていました。Vimで<code>Bad Apple!!</code>を流せたら良いなと思って作ったのが<a href="https://github.com/skanehira/badapple.vim">badapple.vim</a>です。
業務中にひっそり懐かしい<code>Bad Apple!!</code>を見れたらやる気も出て効率上がるんじゃないかなという狙いでしたが、結局一度も業務中で使用することはありませんでした。</p>
<p><img src="https://github.com/skanehira/badapple.vim/blob/master/screenshots/screenshot.gif?raw=true" alt=""></p>
<h2 id="dockerを操作するプラグイン">dockerを操作するプラグイン</h2>
<p>普段の開発でdockerの操作を自作の<a href="https://github.com/skanehira/docui">docui</a>を使っていたが、
画面分割してからdocuiを起動するまでの操作による時間ロスが気になっていました。
ですので、Vimでサクッと操作できるdockerを操作できるプラグインを作りました。</p>
<p>このプラグインはこれまで一番頑張ったもので、便利そうと思った機能もたくさん実装しました。
でも実際使っているのはコンテナの起動、停止、アタッチ、イメージのpullと削除くらいです。
ほかにも高機能（CPU、MEM使用率をリアルタイムで表示するなど）がありますが、ほぼ使っていないので無駄な高機能になってしまいました。</p>
<p>必要な機能だけ実装して、需要や要望があれば実装、というのが良いんだろうなと今になって思います。</p>
<p><img src="https://imgur.com/5h1FufL.gif" alt=""></p>
<h2 id="タピオカプラグイン">タピオカプラグイン</h2>
<p>このころ、世の中ではタピオカブームで、せっかくなのでVimでタピオカを量産するプラグインを作りました。
残念ながら実務で使用することはついぞありませんでした。</p>
<p><img src="https://i.imgur.com/Up93dk7.gif" alt=""></p>
<h2 id="コードを画像化するプラグイン">コードを画像化するプラグイン</h2>
<p>普段、社内チャットでやSNSでサンプルコードを貼ったりしますが、
コードシンタックスが使えないのでとても不便でした。</p>
<p>一番理想ですので、Vimで書いたコードをそのまま選択して画像化、そしてクリップボードにコピーすることです。
それができる<a href="https://github.com/skanehira/code2img">code2img</a>を作り、Vimから使えるよう<a href="https://github.com/skanehira/code2img.vim">code2img.vim</a>を作りしました。</p>
<p>うれしいことでcode2imgは<a href="https://www.moongift.jp/2020/08/code2img-%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E7%94%BB%E5%83%8F%E5%8C%96%E3%81%99%E3%82%8B%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89/">MOONGIFT</a>で紹介されました。</p>
<h2 id="githubを操作できるプラグイン">GitHubを操作できるプラグイン</h2>
<p>今年に入って仕事でGitHubを使うようになってブラウザでの作業がだいぶ増えました。
issue作成、確認、コメント、PR作成、レビューなどができます。</p>
<p>ブラウザでの作業が増えるということは必然的にVimを触る時間が減るということですので、Vimmerとしてはあまりうれしくないことです。
そこで、できるだけVimで作業できるように<a href="https://github.com/skanehira/gh.vim">gh.vim</a>を作りました。</p>
<p>できたてホヤホヤのプラグインですが、普段の作業の6割くらいはVimできるようになったので、一安心しています。</p>
<p><img src="https://i.imgur.com/VK6rebH.gif" alt=""></p>
<h2 id="時系列まとめ">時系列まとめ</h2>
<p>他にも解説していないプラグインがいくつかありますが、時系列にまとめるとこうなりました。
こうやってみると、今年入ってからプラグインを作っている回数が減りましたね。
個人的に2年間でこれしか作っていないのかという気持ちです。</p>
<table>
<thead>
<tr>
<th>日時</th>
<th>プラグイン名</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>2018/12/21</td>
<td><a href="https://github.com/skanehira/vsession">vsession</a></td>
<td>セッションのプラグイン</td>
</tr>
<tr>
<td>2019/05/06</td>
<td><a href="https://github.com/skanehira/translate.vim">translate.vim</a></td>
<td>Google翻訳</td>
</tr>
<tr>
<td>2019/06/16</td>
<td>train.vim</td>
<td>電車乗換案内（非公開）</td>
</tr>
<tr>
<td>2019/06/19</td>
<td><a href="https://github.com/skanehira/docker.vim">docker.vim</a></td>
<td>Dockerのコンテナ、イメージなどの操作</td>
</tr>
<tr>
<td>2019/06/21</td>
<td>weather.vim</td>
<td>天気予報（非公開）</td>
</tr>
<tr>
<td>2019/07/20</td>
<td><a href="https://github.com/skanehira/badapple.vim">badapple.vim</a></td>
<td><code>Bad Apple!!</code>を再生</td>
</tr>
<tr>
<td>2019/08/17</td>
<td><a href="https://github.com/skanehira/generatedir.vim">generatedir.vim</a></td>
<td>プロジェクトレイアウトを生成</td>
</tr>
<tr>
<td>2019/09/26</td>
<td><a href="https://github.com/skanehira/docker-compose.vim">docker-compose.vim</a></td>
<td>docker-composeのラッパ</td>
</tr>
<tr>
<td>2019/10/05</td>
<td><a href="https://github.com/skanehira/say.vim">say.vim</a></td>
<td>Macの<code>play</code>のラッパ</td>
</tr>
<tr>
<td>2019/11/10</td>
<td><a href="https://github.com/skanehira/popupfiles.vim">popupfiles.vim</a></td>
<td>popup windowを使ったファイルセレクタ</td>
</tr>
<tr>
<td>2019/11/13</td>
<td><a href="https://github.com/skanehira/tapioca.vim">tapioca.vim</a></td>
<td>文字を打つとタピオカになる</td>
</tr>
<tr>
<td>2020/01/08</td>
<td><a href="https://github.com/skanehira/preview-markdown.vim">preview-markdown.vim</a></td>
<td>Markdownのプレビュー</td>
</tr>
<tr>
<td>2020/03/03</td>
<td><a href="https://github.com/skanehira/google-map.vim">google-map.vim</a></td>
<td>Google Mapsのルート検索ができる</td>
</tr>
<tr>
<td>2020/08/02</td>
<td><a href="https://github.com/skanehira/code2img.vim">code2img.vim</a></td>
<td>選択した範囲のコードを画像にしてクリップボードにコピー</td>
</tr>
<tr>
<td>2020/09/06</td>
<td><a href="https://github.com/skanehira/gh.vim">gh.vim</a></td>
<td>GitHubのissueやPR、リポジトリなどを操作できる</td>
</tr>
</tbody>
</table>
<h2 id="最後に">最後に</h2>
<p>いくつかはお遊びプラグインですが、業務で役に立っているプラグインもあって、作ってよかったなと思っています。
これからも、Vimに引きこもって生活できるようにプラグインを作っていきます。</p>
]]></content></item><item><title>CSSのgrid-template-columnsを使ってレスポンシブに要素を並べる</title><link>https://skanehira.github.io/blog/posts/20200919-css-grid-template-columns/</link><pubDate>Sat, 19 Sep 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200919-css-grid-template-columns/</guid><description>始めに レスポンシブに要素を並べたいという要望があって、久しぶりにCSSを使ったのでその備忘録です。 これが適切なやり方かどうはわからないので、</description><content type="html"><![CDATA[<h2 id="始めに">始めに</h2>
<p>レスポンシブに要素を並べたいという要望があって、久しぶりにCSSを使ったのでその備忘録です。
これが適切なやり方かどうはわからないので、変なところがあればアドバイスいただけるとうれしいです。</p>
<h2 id="要件">要件</h2>
<ul>
<li>複数の要素を横に並べたい</li>
<li>画面サイズが小さくなったら自動で要素をwrap（次の行に移動）してほしい</li>
</ul>
<p>イメージは次になります。コードは<a href="https://jsfiddle.net/skanehira/ea6Ldk40/102/">デモ</a>です。
<img src="https://storage.googleapis.com/zenn-user-upload/7hokbaq2dbwk8apm4j1bi7ekhofr" alt=""></p>
<h2 id="やり方">やり方</h2>
<p><a href="http://www.htmq.com/css/grid-template-columns.shtml">grid-template-columns</a>と<a href="https://developer.mozilla.org/ja/docs/Web/CSS/repeat">repeat</a>を使うことで実現できます。</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;wrapper&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;item&#34;</span><span class="p">&gt;</span>item1<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;item&#34;</span><span class="p">&gt;</span>item2<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;item&#34;</span><span class="p">&gt;</span>item3<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;item&#34;</span><span class="p">&gt;</span>item4<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;item&#34;</span><span class="p">&gt;</span>item5<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;item&#34;</span><span class="p">&gt;</span>item6<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;item&#34;</span><span class="p">&gt;</span>item7<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;item&#34;</span><span class="p">&gt;</span>item8<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;item&#34;</span><span class="p">&gt;</span>item9<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;item&#34;</span><span class="p">&gt;</span>item10<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">style</span><span class="p">&gt;</span>
  <span class="p">.</span><span class="nc">wrapper</span> <span class="p">{</span>
    <span class="k">display</span><span class="p">:</span> <span class="k">grid</span><span class="p">;</span>
    <span class="k">grid-template-columns</span><span class="p">:</span> <span class="nf">repeat</span><span class="p">(</span><span class="kc">auto</span><span class="o">-</span><span class="kc">fill</span><span class="p">,</span> <span class="mi">60</span><span class="kt">px</span><span class="p">);</span>
    <span class="k">grid-gap</span><span class="p">:</span> <span class="mi">5</span><span class="kt">px</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="p">.</span><span class="nc">item</span> <span class="p">{</span>
    <span class="k">text-align</span><span class="p">:</span> <span class="kc">center</span><span class="p">;</span>
    <span class="k">background-color</span><span class="p">:</span> <span class="kc">gray</span><span class="p">;</span>
    <span class="k">color</span><span class="p">:</span> <span class="kc">white</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">&lt;/</span><span class="nt">style</span><span class="p">&gt;</span>
</code></pre></div><p>詳細を解説していきます。
前提として<code>display: grid</code>は必須になります。</p>
<h3 id="grid-template-columns"><code>grid-template-columns</code></h3>
<p>要素のサイズと要素数を指定できます。
たとえば<code>grid-template-columns: 100px 100px</code>なら次の動きになります。</p>
<ul>
<li><strong>1要素のwidthが100px</strong></li>
<li><strong>横2つまで表示する</strong></li>
<li><strong>2つ以上の場合はwrap</strong></li>
</ul>
<p>つまり横に個数を増やしたければサイズ指定を増やせば良いだけです。</p>
<p>ただ、これだけだと画面のサイズ内に目いっぱい表示したい場合は困ります。
なぜなら画面のサイズによって表示できる個数が変わるので、それを動的に計算する必要があるからです。</p>
<p>そこで、<code>repeat</code>の出番です。</p>
<h3 id="repeat"><code>repeat</code></h3>
<p>要素の繰り返しを定義できる関数です。2つの引数を受け取ることができ、
<strong>1つ目： 繰り返す回数</strong>
<strong>2つ目： 1要素のサイズ</strong>
になっています。</p>
<p>たとえば繰り返す回数を2、サイズを100pxにする場合は次のように書きます。</p>
<div class="highlight"><pre class="chroma"><code class="language-css" data-lang="css"><span class="nt">grid-template-columns</span><span class="o">:</span> <span class="nt">repeat</span><span class="o">(</span><span class="nt">2</span><span class="o">,</span> <span class="nt">100px</span><span class="o">);</span>
</code></pre></div><p>これは次と同じ定義になります。</p>
<div class="highlight"><pre class="chroma"><code class="language-css" data-lang="css"><span class="nt">grid-template-columns</span><span class="o">:</span> <span class="nt">100px</span> <span class="nt">100px</span><span class="o">;</span>
</code></pre></div><p>ただ、このままだとやはり回数指定になってしまうのでそこで<a href="https://www.webprofessional.jp/difference-between-auto-fill-and-auto-fit/">auto-fill</a>です。
<code>auto-fill</code>は<strong>親要素のサイズ内で要素を何個配置できるかを計算してくれる</strong>ので、こちらで個数を指定する必要がなくなります。</p>
<p><code>auto-fill</code>のほかに<code>auto-fit</code>というのがありますが、違いは<a href="https://www.webprofessional.jp/difference-between-auto-fill-and-auto-fit/">こちら</a>の記事のgifを見れば一発でわかります。</p>
<h3 id="grid-gap"><code>grid-gap</code></h3>
<p>要素間の間隔を指定します。たとえば10pxずつ要素を離したいなら<code>grid-gap: 10px;</code>になります。
これに関してはシンプルでわかりやすいですね。</p>
<h3 id="最後に">最後に</h3>
<p>CSS、奥深すぎてやばいですね。魔界です。
じっくり勉強していきます。</p>
<h3 id="参考情報">参考情報</h3>
<ul>
<li><a href="https://parashuto.com/rriver/development/responsive-layout-with-css-grid-and-flexbox">https://parashuto.com/rriver/development/responsive-layout-with-css-grid-and-flexbox</a></li>
<li><a href="https://www.webprofessional.jp/difference-between-auto-fill-and-auto-fit/">https://www.webprofessional.jp/difference-between-auto-fill-and-auto-fit/</a></li>
</ul>
]]></content></item><item><title>EchoのBindでクエリとパスパラメータを構造体に入れる方法</title><link>https://skanehira.github.io/blog/posts/20200919-go-echo-bind-tips/</link><pubDate>Sat, 19 Sep 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200919-go-echo-bind-tips/</guid><description>始めに 普段GoでAPIを作るときはよくEchoを使っていますが、 コードリーディングしたらクエリとパスパラメータを構造体にサクッと入れる機能を</description><content type="html"><![CDATA[<h2 id="始めに">始めに</h2>
<p>普段GoでAPIを作るときはよく<a href="https://echo.labstack.com/">Echo</a>を使っていますが、
コードリーディングしたらクエリとパスパラメータを構造体にサクッと入れる機能を知ったので紹介します。</p>
<h3 id="前提知識">前提知識</h3>
<p><code>Echo</code>では次のやり方で値を取得できます。</p>
<ul>
<li>
<p><code>e.Param(key)</code>でパスパラメータ</p>
</li>
<li>
<p><code>e.QueryParam(key)</code>でクエリパラメータ</p>
</li>
<li>
<p>クエリパラメータ</p>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// curl localhost/users?name=gorilla
</span><span class="c1"></span><span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">QueryParam</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">)</span>
	<span class="c1">// gorilla
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>パスパラメータ</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// curl localhost/users/gorilla
</span><span class="c1"></span><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/users/:name&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Param</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">)</span>
	<span class="c1">// gorilla
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div><h3 id="例">例</h3>
<ul>
<li>API定義は<code>PUT /users/:id</code></li>
<li>リクエストボディは<code>{&quot;name&quot;: &quot;xxx&quot;}</code></li>
</ul>
<p>という定義になっているとします。</p>
<p>その場合、次の処理をします。</p>
<ol>
<li><code>c.Param()</code>でパスパラメータからidを取得</li>
<li><code>c.Bind()</code>でリクエストボディからは更新データを取得</li>
<li>idとnameを構造体に入れて、O/RマッパのUpdateを使って更新</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ID</span>   <span class="kt">int</span>    <span class="s">`json:&#34;id&#34;`</span>
	<span class="nx">Name</span> <span class="kt">string</span> <span class="s">`json:&#34;name&#34;`</span>
<span class="p">}</span>

<span class="nx">e</span><span class="p">.</span><span class="nf">PUT</span><span class="p">(</span><span class="s">&#34;/users/:id&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">id</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Param</span><span class="p">(</span><span class="s">&#34;id&#34;</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">u</span> <span class="nx">User</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Bind</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">u</span><span class="p">);</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// error handling
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nx">u</span><span class="p">.</span><span class="nx">ID</span> <span class="p">=</span> <span class="nx">id</span>
	<span class="nx">db</span><span class="p">.</span><span class="nf">Update</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">u</span><span class="p">)</span>
	<span class="o">...</span>
<span class="p">})</span>
</code></pre></div><h3 id="やり方">やり方</h3>
<p>ただ、これだとidとnameのデータ取得方法がそれぞれ異なるのでチョット面倒です。</p>
<p>そこで、構造体に<code>query</code> or <code>param</code>をつけて<code>c.Bind</code>すれば<code>Echo</code>がよしなに
クエリパラメータorパスパラメータを構造体に入れてくれます。</p>
<p>次の例は<code>param</code>をつけてパスパラメータのidを取得しています。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ID</span>   <span class="kt">int</span>    <span class="s">`json:&#34;id&#34; param:&#34;id&#34;`</span>
	<span class="nx">Name</span> <span class="kt">string</span> <span class="s">`json:&#34;name&#34;`</span>
<span class="p">}</span>

<span class="nx">e</span><span class="p">.</span><span class="nf">PUT</span><span class="p">(</span><span class="s">&#34;/users/:id&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">u</span> <span class="nx">User</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Bind</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">u</span><span class="p">);</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// error handling
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nx">db</span><span class="p">.</span><span class="nf">Update</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">u</span><span class="p">)</span>
	<span class="o">...</span>
<span class="p">})</span>
</code></pre></div><h3 id="雑感">雑感</h3>
<p>一応この機能は<a href="https://echo.labstack.com/guide/request">公式ガイド</a>に書いてありましたが、コードリーディングして見つけました…
ちゃんと公式ドキュメントを読もうねって気持ちになりました。</p>
]]></content></item><item><title>vim-lspでgoplsがディレクトリ構成によっては正しく動作しない</title><link>https://skanehira.github.io/blog/posts/20200918-vim-lsp-gopls-doesnt-work/</link><pubDate>Fri, 18 Sep 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200918-vim-lsp-gopls-doesnt-work/</guid><description>こんにちは、VimとGo使いのゴリラです。 zenn.devが良さそうだったので使ってみようと思い、最近ハマっていた問題を記事にしました。 同じ</description><content type="html"><![CDATA[<p>こんにちは、VimとGo使いのゴリラです。</p>
<p>zenn.devが良さそうだったので使ってみようと思い、最近ハマっていた問題を記事にしました。
同じ問題にハマった方の助けになれればと思います。</p>
<p>2020/09/19追記
<a href="https://github.com/prabirshrestha/vim-lsp/issues/849">こちら</a>のissueの対応が終わったので、本記事で言及している問題は無事解決しました。</p>
<h2 id="goplsが正しく動作しないディレクトリ構成">goplsが正しく動作しないディレクトリ構成</h2>
<p>backendがGoのプロジェクトになっていますが、このような場合vim-lspでgoplsを使うと
定義ジャンプなどができなくなります。</p>
<pre><code>project
├── .git
├── frontend
│   ├── src
│   ├── config.js
│   └── package.json
└── backend
    ├── go.mod
    ├── go.sum
    ├── handler
    ├── usecase
    └── repo
</code></pre><p>原因はvim-lspが<code>.git</code>ディレクトリをワークスペースとするからです。
本来ならgoplsの場合はgo.modがあるディレクトリをワークスペースとしてほしいですが、
現在そうなっていません。（悲しい）</p>
<p>一応本件は<a href="https://github.com/prabirshrestha/vim-lsp/issues/849">issue</a>を起こしていますが、いつ解決されるのやら…（方針をどうするかってところで止まっている）</p>
<h2 id="応急処理">応急処理</h2>
<p>Goのディレクトリに <code>mkdir .git</code> をしておけば動きます。
さきほどの例だと<code>backend/.git</code>になります。</p>
<h2 id="雑感">雑感</h2>
<p>検索してもこのような事象にハマったって方は見かけなかったので、
このプロジェクト構成にしているのは自分だけかなぁって気持ちになっています。（ツライ）</p>
<p>話変わりますが、zenn.dev軽いですね。デザインが良きです（おしゃれ）
自分のブログをここに移そうかなって考えていますがいったん様子見ています。</p>
<p>使い勝手は良さそうな感じでしたので、このまま頑張ってほしいところですね。</p>
]]></content></item><item><title>Vimで:cexprを使ってgrep結果をquickfixに流す</title><link>https://skanehira.github.io/blog/posts/20200918-vim-cexpr-quickfix/</link><pubDate>Fri, 18 Sep 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200918-vim-cexpr-quickfix/</guid><description>始めに みなさんはVimで一度くらいはgrepしたことがあるかと思います。 基本:grepで物足りますが、ちょっとシェルの画面になるのはあまり行</description><content type="html"><![CDATA[<h2 id="始めに">始めに</h2>
<p>みなさんはVimで一度くらいはgrepしたことがあるかと思います。
基本<code>:grep</code>で物足りますが、ちょっとシェルの画面になるのはあまり行けていない感じがします。</p>
<p>そこで<code>cexpr</code>と<code>system</code>と<code>cw</code>を組み合わせることでシェル画面にならず、quickfixに結果を流し込めるので、
それをコマンド化してチョット使いやすくする方法を紹介します。</p>
<h3 id="やり方">やり方</h3>
<p>次をvimrcに貼り付ければ<code>Grep</code>が使えます。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">grep</span><span class="p">(</span><span class="nx">word</span><span class="p">)</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>  <span class="nx">cexpr</span> <span class="nx">system</span><span class="p">(</span><span class="nx">printf</span><span class="p">(</span><span class="s1">&#39;ag &#34;%s&#34;&#39;</span><span class="p">,</span> <span class="nx">a</span>:<span class="nx">word</span><span class="p">))</span> <span class="p">|</span> <span class="nx">cw</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nx">command</span><span class="p">!</span> <span class="p">-</span><span class="nx">nargs</span><span class="p">=</span><span class="m">1</span> <span class="nx">Grep</span> <span class="nx">call</span> <span class="p">&lt;</span><span class="nx">SID</span><span class="p">&gt;</span><span class="nx">grep</span><span class="p">(&lt;</span><span class="nx">q</span><span class="p">-</span><span class="nx">args</span><span class="p">&gt;)</span><span class="err">
</span></code></pre></div><p><img src="https://storage.googleapis.com/zenn-user-upload/3adzzygk1ggqaqu1g45dwitc9525" alt=""></p>
<p><code>cexpr {expr}</code>は<code>{expr}</code>の結果をquickfixに流し込んでくれます。
<code>cw</code>はquickfixを開きます。</p>
<p><code>system</code>は外部コマンドを実行してくれるので、お好きなgrepコマンドを置き換えても問題ないです。
<code>grep</code>コマンドの出力結果によっては<code>errorformat</code>の設定を返る必要はありますのでご注意ください。</p>
<h4 id="追記2020-10-16">追記2020-10-16</h4>
<p><code>cgetexpr</code>を使えば、grep結果の1つ目にジャンプしなくなります。
自動でジャンプしたくない方は<code>cgetexpr</code>を使うと良きです。</p>
<h3 id="余談">余談</h3>
<p>もともと、<a href="https://github.com/junegunn/fzf.vim">fzf.vim</a>の<code>Ag</code>コマンドでgrepをしてましたが、
次のエラーが起きてgrepできなくなっていました。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="nx">Error</span> <span class="nx">running</span> <span class="s1">&#39;fzf&#39;</span>  <span class="s1">&#39;--ansi&#39;</span> <span class="s1">&#39;--prompt&#39;</span> <span class="s1">&#39;Ag&gt; &#39;</span> <span class="s1">&#39;--multi&#39;</span> <span class="s1">&#39;--bind&#39;</span> <span class="s1">&#39;alt-a:select-all,alt-d:deselect-all&#39;</span> &#39;<span class="err">
</span><span class="err"></span><span class="p">--</span><span class="nx">delimiter</span><span class="s1">&#39; &#39;</span>:<span class="s1">&#39; &#39;</span><span class="p">--</span><span class="nx">preview</span><span class="p">-</span><span class="nx">window</span><span class="s1">&#39; &#39;</span><span class="p">+</span>{<span class="m">2</span>}<span class="m">-5</span><span class="s1">&#39; &#39;</span><span class="p">--</span><span class="nx">color</span><span class="s1">&#39; &#39;</span><span class="nx">hl</span>:<span class="m">4</span><span class="p">,</span><span class="nx">hl</span><span class="p">+</span>:<span class="m">12</span>&#39; <span class="p">--</span><span class="nx">expect</span><span class="p">=</span><span class="nx">ctrl</span><span class="p">-</span><span class="nx">v</span><span class="p">,</span><span class="nx">ctrl</span><span class="p">-</span><span class="nx">x</span><span class="p">,</span><span class="nx">ctrl</span><span class="p">-</span><span class="nx">t</span> <span class="p">--</span><span class="nx">heigh</span><span class="err">
</span><span class="err"></span><span class="nx">t</span><span class="p">=</span><span class="m">22</span> <span class="p">&gt;</span> <span class="sr">/tmp/</span><span class="nx">vjUnOWu</span>/<span class="m">3</span><span class="err">
</span></code></pre></div><p>ちょっと原因調べるの面倒ですので、ちょっと自作コマンドを用意することにしました。
今のところは快適ですが、<code>system</code>はVimの操作をブロックしてしまうので、
困ったら<code>job_start</code>を使って改善するかもしれません。</p>
]]></content></item><item><title>Vimで画像をツイートする</title><link>https://skanehira.github.io/blog/posts/20200817-vim-tweet-with-image/</link><pubDate>Mon, 17 Aug 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200817-vim-tweet-with-image/</guid><description>初めに ども、連休が終わったのをいまだに信じられないゴリラです 先日 code2img.vim というプラグインを作ったんですが、 基本ソースコードを画像にして共有するのは</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>ども、連休が終わったのをいまだに信じられないゴリラです</p>
<p>先日 <a href="https://github.com/skanehira/code2img.vim">code2img.vim</a> というプラグインを作ったんですが、
基本ソースコードを画像にして共有するのはTwitterですので、それらをまとめてVimできたら良いなと思って、簡単なスクリプトを書きました。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/99185e3a-90d5-9f73-ea7d-c8d52a266c63.gif" alt="tweet_with_image.gif"></p>
<p>コードの本体は<a href="https://gist.github.com/skanehira/7dd6ed0dc8da8c6e87a11ab70ea83b53">ここ</a>に置いてあります。</p>
<h2 id="必要なもの">必要なもの</h2>
<ul>
<li><a href="https://github.com/skanehira/code2img">code2img</a></li>
<li><a href="https://github.com/mattn/twty">twty</a></li>
</ul>
<h2 id="使い方">使い方</h2>
<p>コードをvimrcに記述すれば<code>TweetWithImg</code>コマンドが使えます。</p>
<ul>
<li>選択した範囲のテキストが画像として出力される</li>
<li>コマンドの引数はツイート本文として送信される</li>
</ul>
<p>ので、<code>TweetWithImg 私はゴリラです</code>というふう実行すれば<code>私はゴリラです</code>と画像つきのツイートがつぶやけます。</p>
<p>しくみはシンプルで、<code>code2img</code>でソースコードを画像ファイルに出力して、<code>twty</code>で画像ファイルと本文をツイートするだけです。
<code>job_start</code>なので非同期で動くのでVimが固まることがないです（これ重要）</p>
<h2 id="さいごに">さいごに</h2>
<p>やはりコードを画像化してさくっとTwtterで共有できるのは良い体験</p>
]]></content></item><item><title>100種類以上のターミナルのカスタムテーマをサクッと導入</title><link>https://skanehira.github.io/blog/posts/20200813-terminal-themes/</link><pubDate>Thu, 13 Aug 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200813-terminal-themes/</guid><description>初めに こんにちは 最近メインPCがThinkpadになって、メインOSがUbuntuになったゴリラです 普段ターミナルで作業する方はカスタムテー</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>こんにちは
最近メインPCがThinkpadになって、メインOSがUbuntuになったゴリラです</p>
<p>普段ターミナルで作業する方はカスタムテーマを使っていますか？
割とカスタムテーマをダウンロードして適用したりするの面倒と感じている方もいると思いますが、
今日はサクッとテーマを適用する方法を紹介します</p>
<h2 id="やり方">やり方</h2>
<p>こちらを使います。MacとLinux対応しています。
<a href="https://github.com/Mayccoll/Gogh">https://github.com/Mayccoll/Gogh</a></p>
<p>ぼくはLinuxですので、次のコマンドを実行します。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">bash -c  <span class="s2">&#34;</span><span class="k">$(</span>wget -qO- https://git.io/vQgMr<span class="k">)</span><span class="s2">&#34;</span>
</code></pre></div><p>100種類以上のテーマがあるので、<a href="https://mayccoll.github.io/Gogh/">こちら</a>を見て使ってみたいものの番号を選択してください
もしくは<code>ALL</code>で全テーマを入れてもOKです。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/7aa499a5-9e6f-c63d-60bf-1bd40b24bc2e.png" alt="image.png"></p>
<p>入れたあと、デフォルト設定にしてターミナルを再起動すれば適用されます（gnome-terminalの場合）
あとはフォントを変えるなりして見てください。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/ddf36f95-5650-2792-c106-82ebbf9130b4.png" alt="image.png"></p>
<h2 id="さいごに">さいごに</h2>
<p>100種類以上のテーマをサクッと導入できるのは便利ですね</p>
]]></content></item><item><title>Goで画像をクリップボードに保存、読み取るライブラリを作った</title><link>https://skanehira.github.io/blog/posts/20200808-go-clipboard-image/</link><pubDate>Sat, 08 Aug 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200808-go-clipboard-image/</guid><description>初めに こんにちは ゴリラです 画像をクリップボードにコピー、コピーした画像をクリップボードから読み取るGoのライブラリ clipboard-image を作ったので紹介します。</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>こんにちは
ゴリラです</p>
<p>画像をクリップボードにコピー、コピーした画像をクリップボードから読み取るGoのライブラリ <a href="https://github.com/skanehira/clipboard-image">clipboard-image</a> を作ったので紹介します。
このライブラリはMac、Linux、Windowsで動作します。</p>
<p>先日 <a href="https://qiita.com/gorilla0513/items/013aea9060bca1455137">Goでソースコードを画像化するCLIを作った</a> で紹介したCLIではこのライブラリを使っています。</p>
<h2 id="使い方">使い方</h2>
<p>関数は2つのみ</p>
<ul>
<li><code>CopyToClipboard</code></li>
<li><code>ReadFromClipboard</code></li>
</ul>
<p>画像ファイルをクリップボードにコピーするときは <code>CopyToClipboard</code></p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/598e7a39-59fc-fc35-9982-9093fefde5ff.png" alt="image.png"></p>
<p>クリップボードから画像ファイルを読み取るときは <code>ReadFromClipboard</code></p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/5c676cb6-5a69-70d6-4af2-0c5cc9e93178.png" alt="image.png"></p>
<h2 id="しくみ">しくみ</h2>
<p>クリップボードへのアクセスは外部コマンドを用いています。
それらをGoでラップしてライブラリとして提供しています。それぞれ次になっています。</p>
<table>
<thead>
<tr>
<th>OS</th>
<th>コマンド</th>
</tr>
</thead>
<tbody>
<tr>
<td>macOS</td>
<td>osascript</td>
</tr>
<tr>
<td>Windows</td>
<td>PowerShell</td>
</tr>
<tr>
<td>Linux</td>
<td>xclip</td>
</tr>
</tbody>
</table>
<p>macOSではApple Scriptを使えばクリップボードにアクセスできます。
Apple Scriptは標準でmacOSに入っているのでライブラリ意外は特に不要です。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># copy to clipboard</span>
osascript -e <span class="s1">&#39;set the clipboard to (read &#34;/path/to/file.png&#34; as TIFF picture)&#39;</span>

<span class="c1"># write file from clipboard</span>
osascript -e <span class="s1">&#39;write (the clipboard as «class PNGf») to (open for access &#34;/tmp/file.png&#34; with write permission)&#39;</span>
</code></pre></div><p>WindowsではPowershellでクリップボードにアクセスできます。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># copy to clipboard</span>
PowerShell -Command Add-Type -AssemblyName System.Windows.Forms<span class="p">;</span><span class="o">[</span>Windows.Forms.Clipboard<span class="o">]</span>::SetImage<span class="o">([</span>System.Drawing.Image<span class="o">]</span>::FromFile<span class="o">(</span><span class="s1">&#39;/path/to/file.png&#39;</span><span class="o">))</span><span class="p">;</span>

<span class="c1"># write file from clipboard</span>
PowerShell -Command Add-Type -AssemblyName System.Windows.Forms<span class="p">;</span><span class="nv">$clip</span><span class="o">=[</span>Windows.Forms.Clipboard<span class="o">]</span>::GetImage<span class="o">()</span><span class="p">;</span><span class="k">if</span> <span class="o">(</span><span class="nv">$clip</span> -ne <span class="nv">$null</span><span class="o">)</span> <span class="o">{</span> <span class="nv">$clip</span>.Save<span class="o">(</span><span class="s1">&#39;/path/to/file.png&#39;</span><span class="o">)</span> <span class="o">}</span><span class="p">;</span>
</code></pre></div><p>Linuxでは<code>xclip</code>というコマンドをインストールことでクリップボードにアクセスできます。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># copy to clipboard</span>
xclip -selection clipboard -t image/png &lt; /path/to/file.png

<span class="c1"># write file from clipboard</span>
xclip -selection clipboard -o &gt; /path/to/file.png
</code></pre></div><p>これらのコマンドをGoの<code>exec.Command</code>で実行することで、Goでクリップボードにアクセスできます。</p>
<h2 id="詰まったポイント">詰まったポイント</h2>
<p><code>xclip</code>を使う時、標準入力でファイルの中身を渡すのですが、次のように書いても標準入力に渡っていかないです。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/3a94a766-6962-8f61-181b-01500522f5e1.png" alt="image.png"></p>
<p>標準入力に渡すには<code>StdinPipe</code>でpipeを取得してファイルの中身を書き込んだ後にstdinを閉じる必要あります。
<code>xclip</code>の実装は<a href="https://github.com/atotto/clipboard">atotto/clipboard</a>を参考にしました。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/14aae070-760d-9abb-af14-0ac5c9313aaf.png" alt="image.png"></p>
<h2 id="さいごに">さいごに</h2>
<p>クリップボード周りは結構苦戦して、いろいろな方に質問してなんとか作れました。
ライブラリとしてはまだ完成形とは考えていなくて、今後も拡張していきたいと考えています。</p>
<p>ちなみに、この記事の画像はVimで書いたコードを<a href="https://github.com/skanehira/code2img.vim">code2img.vim</a>でクリップボードにコピーしてサクッとQiitaにアップロードしたものです。
当初手軽にVimでコードを画像化したいという目的を達成できて、実際使って便利ので満足しています。</p>
<p>コードブロックが使えないチャットやTwitterといったSNSでコード貼りたいときにぜひCLIを使ってみてください。</p>
]]></content></item><item><title>Goでソースコードを画像化するCLIを作った</title><link>https://skanehira.github.io/blog/posts/20200806-go-code2img/</link><pubDate>Thu, 06 Aug 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200806-go-code2img/</guid><description>初めに こんにちは ゴリラです 普段、Twitterでたまにこういうふうにソースコードの画像を貼り付けることがあります。 画像を作るのにcarbon</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>こんにちは
ゴリラです</p>
<p>普段、Twitterでたまにこういうふうにソースコードの画像を貼り付けることがあります。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/4bf71de8-abd8-ffee-27e5-af3968bbe859.png" alt="image.png"></p>
<p>画像を作るのに<a href="https://carbon.now.sh/">carbon</a>というサービスを使っています。
このサービスできれいな画像を生成できますが、インターネットとブラウザなしでは使えないためちょっと不便と感じています。
また、<a href="https://github.com/Aloxaf/silicon">slicon</a>というrust製のツールもありますが、これもcarbonと同様の制限があります。
そこで、ブラウザやネットを使用せずCLIでソースコードを画像化できたら良いなと思いCLIを作りました。</p>
<p><a href="https://github.com/skanehira/code2img"><img src="https://github-link-card.s3.ap-northeast-1.amazonaws.com/skanehira/code2img.png" width="460px"></a></p>
<h2 id="どんな感じ">どんな感じ</h2>
<p>こんな感じでpngファイルを出力できます。外部ツール依存なしでGoだけで動くのでインターネットもブラウザも必要ないです。</p>
<p><img src="https://i.imgur.com/TjoOQct.gif" alt=""></p>
<h2 id="使い方">使い方</h2>
<p>2通りあります。ソースコードを標準入力で渡すか、ファイルを渡すかです。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ code2img
code2img - generate image of <span class="nb">source</span> code

Version: 1.1.0

Usage:
  $ code2img -t monokai main.go main.png
  $ <span class="nb">echo</span> <span class="s1">&#39;fmt.Println(&#34;Hello World&#34;)&#39;</span> <span class="p">|</span> code2img -ext go -t native -o sample.png
  $ code2img -c main.go

  -t    color theme<span class="o">(</span>default: solarized-dark<span class="o">)</span>
  -o    output file name<span class="o">(</span>default: out.png<span class="o">)</span>
  -c    copy to clipboard
  -ext  file extension
</code></pre></div><p>ファイルの場合はオプションなくても使えます。カラースキーマを指定したい場合は<code>-t</code>を使用します。
使用可能なカラースキーマは<a href="https://xyproto.github.io/splash/docs/all.html">こちら</a>、サポートしている言語一覧は<a href="https://github.com/alecthomas/chroma#supported-languages">こちら</a>を参照ください。</p>
<p><code>-c</code>で画像をファイルではなくクリップボードにコピーします。そのままツイートに貼り付けたいときに使用すると便利です。</p>
<h2 id="実装">実装</h2>
<p>処理の流れは大まかと次になります。</p>
<ol>
<li>コードをトークナイズして、トークンごとに色を情報をつける</li>
<li>トークンを一文字ずつpngに書き込む</li>
</ol>
<p>ソースコードをトークナイズしてトークンごとに色（RGBA）をつけますが、ここをスクラッチで多言語に対応するのは骨が折れるので、素直に<a href="https://github.com/alecthomas/chroma">github.com/alecthomas/chroma</a>というライブラリを使用しました。</p>
<p>このライブラリを使えば、2の処理だけを書けば済みます。</p>
<p>2の処理は大まかに次になります。</p>
<ol>
<li>文字を描画するfontを読み込み</li>
<li>座標を計算しつつ、一文字ずつ描画する</li>
</ol>
<p>fontに関してはマルチバイト対応の<a href="https://github.com/miiton/Cica">Cica</a>を<a href="https://github.com/jessevdk/go-assets">github.com/jessevdk/go-assets</a>で埋め込んでいます。
そのためCLIのサイズが倍くらい増えましたが、致し方ない…</p>
<p>文字描画の処理は次になっています。この<code>iterator.Tokens()</code>がtoken情報を返してくるので、
tokenの種類から<code>style.Get()</code>で色情報を取得しています。その後、一文字ずつpngに書き込んで、座標を計算して…を繰り返します。</p>
<p>ここでポイントですが、マルチバイトの場合は座標は +2しないと文字が重なって読めなくなります。なので一文字の長さを確認して必要あればx座標を +2しています。これでマルチバイトでも問題なく描画されます。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">t</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">iterator</span><span class="p">.</span><span class="nf">Tokens</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">style</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">Type</span><span class="p">).</span><span class="nx">Colour</span>
	<span class="nx">dr</span><span class="p">.</span><span class="nx">Src</span> <span class="p">=</span> <span class="nx">image</span><span class="p">.</span><span class="nf">NewUniform</span><span class="p">(</span><span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="nx">R</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Red</span><span class="p">(),</span> <span class="nx">G</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Green</span><span class="p">(),</span> <span class="nx">B</span><span class="p">:</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Blue</span><span class="p">(),</span> <span class="nx">A</span><span class="p">:</span> <span class="mi">255</span><span class="p">})</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">t</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span> <span class="p">{</span>
			<span class="nx">x</span> <span class="p">=</span> <span class="nx">fixed</span><span class="p">.</span><span class="nf">Int26_6</span><span class="p">(</span><span class="nx">padding</span><span class="p">)</span>
			<span class="nx">y</span><span class="o">++</span>
			<span class="k">continue</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="sc">&#39;\t&#39;</span> <span class="p">{</span>
			<span class="nx">x</span> <span class="o">+=</span> <span class="nx">fixed</span><span class="p">.</span><span class="nf">Int26_6</span><span class="p">(</span><span class="nx">padding</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">dr</span><span class="p">.</span><span class="nx">Dot</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="nx">fixed</span><span class="p">.</span><span class="nf">I</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="nx">x</span>
		<span class="nx">dr</span><span class="p">.</span><span class="nx">Dot</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="nx">fixed</span><span class="p">.</span><span class="nf">I</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="o">*</span> <span class="nx">y</span>
		<span class="nx">s</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%c&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
		<span class="nx">dr</span><span class="p">.</span><span class="nf">DrawString</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

		<span class="c1">// if mutibyte
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">2</span> <span class="p">{</span>
			<span class="nx">x</span> <span class="p">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">x</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="エディタと連携">エディタと連携</h2>
<p><del>標準入力に対応しているので、Vimなどのエディタと連携してサクッと画像化できます。</del>
<a href="https://github.com/skanehira/code2img.vim">code2img.vim</a>というプラグインを作りました。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/fb37eb6f-fb51-8666-af58-bd200229568b.gif" alt="vim-code2img.gif"></p>
<h2 id="さいごに">さいごに</h2>
<p>依存なしでソースコードを画像に変換できるので、ぜひ試してみてください。エディタとも連携できて便利です。</p>
]]></content></item><item><title>Vimでソースコードを画像化してクリップボードにコピー</title><link>https://skanehira.github.io/blog/posts/20200806-vim-code2img/</link><pubDate>Thu, 06 Aug 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200806-vim-code2img/</guid><description>初めに こんにちは ゴリラです Goでソースコードを画像化するCLIを作った でソースコードを画像化するCLIを紹介しましたが、Vimからもう少し使</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>こんにちは
ゴリラです</p>
<p><a href="https://qiita.com/gorilla0513/items/013aea9060bca1455137">Goでソースコードを画像化するCLIを作った</a> でソースコードを画像化するCLIを紹介しましたが、Vimからもう少し使いやすくするためプラグインを作りました。</p>
<p><a href="https://github.com/skanehira/code2img.vim"><img src="https://github-link-card.s3.ap-northeast-1.amazonaws.com/skanehira/code2img.vim.png" width="460px"></a></p>
<h2 id="使い方">使い方</h2>
<p>次のとおりです</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="c">&#34; 選択した範囲を画像化してクリップボードにコピー</span><span class="err">
</span><span class="err"></span><span class="p">:</span><span class="s1">&#39;&lt;&#39;</span><span class="p">&gt;</span><span class="nx">Code2img</span><span class="err">
</span><span class="err"></span><span class="c">
</span><span class="c">&#34; ファイル全体を画像化してクリップボードにコピー</span><span class="err">
</span><span class="err"></span><span class="p">:</span><span class="nx">Code2img</span><span class="err">
</span><span class="err"></span><span class="c">
</span><span class="c">&#34; ファイルに出力</span><span class="err">
</span><span class="err"></span><span class="p">:</span><span class="nx">Code2img</span> <span class="nx">image</span>.<span class="nx">png</span><span class="err">
</span><span class="err"></span><span class="c">
</span><span class="c">&#34; 選択範囲を画像化してファイルに出力</span><span class="err">
</span><span class="err"></span><span class="p">:</span><span class="s1">&#39;&lt;&#39;</span><span class="p">&gt;</span><span class="nx">Code2img</span> <span class="nx">image</span>.<span class="nx">png</span><span class="err">
</span></code></pre></div><h2 id="しくみ">しくみ</h2>
<p>Vimの<code>job_start</code>を使って<code>code2img</code>を実行しているだけです。
引数がなければクリップボードにコピー、引数があればファイルに出力するように引数を組み合わせています。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/32395da9-4f89-5baf-12e3-934d3fddd221.png" alt="image.png"></p>
<h2 id="さいごに">さいごに</h2>
<p>久しぶりにVimプラグイン作りましたが、楽かったです
あとやはり書かないといろいろ忘れるなと思いました
定期的にプラグインを作りたい（気持ちはある）</p>
]]></content></item><item><title>Vim上でツイートをニコ動のコメント風に流す</title><link>https://skanehira.github.io/blog/posts/20200727-vim-tweet-niconico/</link><pubDate>Mon, 27 Jul 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200727-vim-tweet-niconico/</guid><description>初めに こんにちは ゴリラです Vimでターミナルを使うときは:term ++close +shell {cmd}というふうに実行することが多々ありますが、 オプションが多くな</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>こんにちは
ゴリラです</p>
<p>Vimでターミナルを使うときは<code>:term ++close +shell {cmd}</code>というふうに実行することが多々ありますが、
オプションが多くなると、いささか不便に感じます。</p>
<p>そこで、<code>BufReadCmd</code>を使えば、ターミナルがちょっと使いやすくなります。</p>
<h1 id="やり方">やり方</h1>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">termopen</span><span class="p">()</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">name</span> <span class="p">=</span> <span class="nx">split</span><span class="p">(</span><span class="nx">bufname</span><span class="p">(),</span> <span class="s1">&#39;\/\/&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="k">if</span> <span class="nx">len</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">&lt;</span> <span class="m">2</span><span class="err">
</span><span class="err"></span>    <span class="nx">return</span><span class="err">
</span><span class="err"></span>  <span class="k">endif</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">execute</span><span class="p">(</span><span class="nx">printf</span><span class="p">(</span><span class="s1">&#39;term ++curwin ++close ++shell %s&#39;</span><span class="p">,</span> <span class="nx">name</span>[<span class="m">1</span>]<span class="p">))</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nx">augroup</span> <span class="nx">terminal</span><span class="err">
</span><span class="err"></span>  <span class="nx">au</span><span class="p">!</span><span class="err">
</span><span class="err"></span>  <span class="nx">au</span> <span class="nx">BufReadCmd</span> <span class="nx">term</span>:<span class="sr">//</span>* <span class="nx">call</span> <span class="nx">s</span>:<span class="nx">termopen</span><span class="p">()</span><span class="err">
</span><span class="err"></span><span class="nx">augroup</span> <span class="nx">END</span><span class="err">
</span></code></pre></div><p>上記のコードを<code>vimrc</code>に追記&amp;リロードして、<code>:vnew term://top</code> すると、ターミナルが起動して<code>top</code>コマンドが動きます。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/346ec215-2109-3c5f-c01c-9601c7ae6054.gif" alt="vim-term.gif"></p>
<h2 id="しくみ">しくみ</h2>
<p>しくみは簡単で、bufferが作られたら <code>BufReadcmd</code> イベントが走るので、そのとき <code>s:termopen</code> を実行させるように <code>autocmd</code> を設定します。
<code>s:termopen</code>関数内ではバッファ名からterminalで実行するコマンド（<code>//</code>よりも後ろの部分）を取得してターミナルを起動します。</p>
<p><code>//</code>よりも後ろがコマンドになるので、たとえば<code>tabnew term://bash</code>でも動くし、<code>new term://docker exec -it golang bash</code>でも動きます。
設定自体はシンプルでかつ柔軟にコマンドを実行できるので個人的に便利と思っています。</p>
<h2 id="さいごに">さいごに</h2>
<p>このターミナルのカスタマイズはneovimから着想を得ました。neovimでは標準で同じようなことができます（ヘルプより抜粋）。</p>
<pre><code>- Edit a file with a name matching `term://(.{-}//(\d+:)?)?\zs.*`.
  For example:

    :edit term://bash
    :vsplit term://top
</code></pre>]]></content></item><item><title>Vimのターミナルをすこし使いやすくする</title><link>https://skanehira.github.io/blog/posts/20200726-vim-improve-terminal/</link><pubDate>Sun, 26 Jul 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200726-vim-improve-terminal/</guid><description>初めに こんにちは ゴリラです Vimでターミナルを使うときは:term ++close +shell {cmd}というふうに実行することが多々ありますが、 オプションが多くな</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>こんにちは
ゴリラです</p>
<p>Vimでターミナルを使うときは<code>:term ++close +shell {cmd}</code>というふうに実行することが多々ありますが、
オプションが多くなると、いささか不便に感じます。</p>
<p>そこで、<code>BufReadCmd</code>を使えば、ターミナルがちょっと使いやすくなります。</p>
<h1 id="やり方">やり方</h1>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">termopen</span><span class="p">()</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>  <span class="k">let</span> <span class="nx">name</span> <span class="p">=</span> <span class="nx">split</span><span class="p">(</span><span class="nx">bufname</span><span class="p">(),</span> <span class="s1">&#39;\/\/&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>  <span class="k">if</span> <span class="nx">len</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">&lt;</span> <span class="m">2</span><span class="err">
</span><span class="err"></span>    <span class="nx">return</span><span class="err">
</span><span class="err"></span>  <span class="k">endif</span><span class="err">
</span><span class="err"></span>  <span class="nx">call</span> <span class="nx">execute</span><span class="p">(</span><span class="nx">printf</span><span class="p">(</span><span class="s1">&#39;term ++curwin ++close ++shell %s&#39;</span><span class="p">,</span> <span class="nx">name</span>[<span class="m">1</span>]<span class="p">))</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nx">augroup</span> <span class="nx">terminal</span><span class="err">
</span><span class="err"></span>  <span class="nx">au</span><span class="p">!</span><span class="err">
</span><span class="err"></span>  <span class="nx">au</span> <span class="nx">BufReadCmd</span> <span class="nx">term</span>:<span class="sr">//</span>* <span class="nx">call</span> <span class="nx">s</span>:<span class="nx">termopen</span><span class="p">()</span><span class="err">
</span><span class="err"></span><span class="nx">augroup</span> <span class="nx">END</span><span class="err">
</span></code></pre></div><p>上記のコードを<code>vimrc</code>に追記&amp;リロードして、<code>:vnew term://top</code> すると、ターミナルが起動して<code>top</code>コマンドが動きます。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/346ec215-2109-3c5f-c01c-9601c7ae6054.gif" alt="vim-term.gif"></p>
<h2 id="しくみ">しくみ</h2>
<p>しくみは簡単で、bufferが作られたら <code>BufReadcmd</code> イベントが走るので、そのとき <code>s:termopen</code> を実行させるように <code>autocmd</code> を設定します。
<code>s:termopen</code>関数内ではバッファ名からterminalで実行するコマンド（<code>//</code>よりも後ろの部分）を取得してターミナルを起動します。</p>
<p><code>//</code>よりも後ろがコマンドになるので、たとえば<code>tabnew term://bash</code>でも動くし、<code>new term://docker exec -it golang bash</code>でも動きます。
設定自体はシンプルでかつ柔軟にコマンドを実行できるので個人的に便利と思っています。</p>
<h2 id="さいごに">さいごに</h2>
<p>このターミナルのカスタマイズはneovimから着想を得ました。neovimでは標準で同じようなことができます（ヘルプより抜粋）。</p>
<pre><code>- Edit a file with a name matching `term://(.{-}//(\d+:)?)?\zs.*`.
  For example:

    :edit term://bash
    :vsplit term://top
</code></pre>]]></content></item><item><title>VimでWorld Wide Web</title><link>https://skanehira.github.io/blog/posts/20200706-vim-www/</link><pubDate>Mon, 06 Jul 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200706-vim-www/</guid><description>初めに こんにちは ゴリラです 普段Vimを使ってコーディングしていると、「あれ、あの関数名なんだっけ？」とか「引数何を受け取るんだっけ？」とかで</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>こんにちは
ゴリラです</p>
<p>普段Vimを使ってコーディングしていると、「あれ、あの関数名なんだっけ？」とか「引数何を受け取るんだっけ？」とかで思い出せないことが多々あると思います。
そういう時、たいていの人はブラウザを使うと思いますが、アプリケーションを切り替えないといけないので効率が悪いなとずっと思っていました。</p>
<p>そこで、この度<a href="https://ja.wikipedia.org/wiki/W3m">w3m</a>を導入してみました。ちょっとQOL（Quality Of Life）上がった感があるので紹介してきます。</p>
<h2 id="w3mとは"><code>w3m</code>とは</h2>
<p>簡単に言うとテキストベースブラウザです。一応<code>sixel</code>対応できるので画像表示もできます。（ただレイアウト崩れるので実用的ではなかった）
テキストベースゆえ、とても軽快で<code>cookie</code>や<code>openssl</code>も使えるので<code>Twitter</code>などのサービスにログインもできます。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/1e017600-c9bf-d1d0-3e2c-63920ae527d3.png" alt="image.png"></p>
<p>がっつりいろいろと調査するなら普通にブラウザを使ったほうが良いですが、
冒頭で言ったような用途であれば<code>w3m</code>で十分です。</p>
<h2 id="vimでw3mを使う">Vimで<code>w3m</code>を使う</h2>
<p>Vimでは<code>terminal</code>機能があるので、それを使えばVim上で<code>w3m</code>を使用できます。たとえば次のコマンドで<code>google.com</code>を開けます。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="p">:</span><span class="nx">term</span> <span class="p">++</span><span class="nx">close</span> <span class="nx">w3m</span> <span class="nx">google</span>.<span class="nx">com</span><span class="err">
</span></code></pre></div><p>ただ、これだけだとちょっと不便です。だいたいは何かしら検索することが多いので、もう少し便利にするため<code>WWW</code>コマンドを用意します。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">www</span><span class="p">(</span><span class="nx">word</span><span class="p">)</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>  <span class="nx">execute</span><span class="p">(</span><span class="s1">&#39;term ++close ++shell w3m google.com/search\?q=&#34;&#39;</span> . <span class="nx">a</span>:<span class="nx">word</span> . <span class="s1">&#39;&#34;&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nx">command</span><span class="p">!</span> <span class="p">-</span><span class="nx">nargs</span><span class="p">=</span><span class="m">1</span> <span class="nx">WWW</span> <span class="nx">call</span> <span class="nx">s</span>:<span class="nx">www</span><span class="p">(&lt;</span><span class="nx">f</span><span class="p">-</span><span class="nx">args</span><span class="p">&gt;)</span><span class="err">
</span></code></pre></div><p>上記の設定を<code>vimrc</code>に追加すれば<code>:WWW ゴリラ vim</code>って実行するとGoogleの検索結果画面が表示されます。
とても良き。</p>
<p>検索以外に、ぼくは普段Goを書いたりするので<code>pkg.go.dev</code>を簡単に開く関数も用意しました。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">gg</span><span class="p">(</span><span class="nx">package</span><span class="p">)</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>  <span class="nx">execute</span><span class="p">(</span><span class="s1">&#39;term ++close ++shell w3m pkg.go.dev/&#39;</span> . <span class="nx">a</span>:<span class="nx">package</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nx">command</span><span class="p">!</span> <span class="p">-</span><span class="nx">nargs</span><span class="p">=</span><span class="m">1</span> <span class="nx">GG</span> <span class="nx">call</span> <span class="nx">s</span>:<span class="nx">gg</span><span class="p">(&lt;</span><span class="nx">f</span><span class="p">-</span><span class="nx">args</span><span class="p">&gt;)</span><span class="err">
</span></code></pre></div><p>上記設定をすると<code>:GG path/filepath</code>次のように<code>pkg.go.dev/path/filepath</code>が開きます。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/8c6be7cf-4440-3ac4-77ce-44967c49d793.png" alt="image.png"></p>
<h2 id="vimでw3mのメリット">Vimで<code>w3m</code>のメリット</h2>
<p>ズバリ、翻訳できることです。ゴリラ製<a href="https://github.com/skanehira/translate.vim">翻訳プラグイン</a>を使って、<code>godoc</code>の英語ドキュメントを翻訳しながら読めます。
英語苦手ですので、こうやって翻訳しながらじゃないと読めないです（ツライ）</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/7bd5f475-ed04-e8ad-fab3-0d6291d9acbf.png" alt="image.png"></p>
<h2 id="w3mのキーマップ設定"><code>w3m</code>のキーマップ設定</h2>
<p>デフォルトのキーマップでしっくり来ないところがあったので、<code>~/.w3m/keymap</code>に次の設定をしてなるべく使用感をVimに近付けています。</p>
<pre><code>keymap C-u PREV_PAGE
keymap C-d NEXT_PAGE
keymap C-h BACK
keymap C-l NEXT
keymap ] NEXT_TAB
keymap [ PREV_TAB
keymap C-w CLOSE_TAB
keymap b PREV_WORD
keymap H HISTORY
keymap ? HELP
keymap C-n NEXT_LINK
keymap C-p PREV_LINK
keymap C-q EXIT
keymap C-k GOTO
</code></pre><h2 id="さいごに">さいごに</h2>
<p>導入したばっかりですので、しばらく使ってみています。
みなさんもぜひ使ってみてください。</p>
]]></content></item><item><title>ブラウザのテキスト入力をVim化</title><link>https://skanehira.github.io/blog/posts/20200621-vim-input-in-browser/</link><pubDate>Sun, 21 Jun 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200621-vim-input-in-browser/</guid><description>初めに こんにちは ゴリラです 仕事に限らず、普段はブラウザでテキストを入力することも多々あると思います。 ぼくは、その度にVimのキーバインドを使</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>こんにちは
ゴリラです</p>
<p>仕事に限らず、普段はブラウザでテキストを入力することも多々あると思います。
ぼくは、その度にVimのキーバインドを使えたらなと思ったことがこれまで何度もありました。</p>
<p>そこで、<a href="http://appsweets.net/wasavi/">wasavi</a>というChromeの拡張を教えてもらいました。
試してみた結果とても良かったので紹介します。</p>
<p>Chromeは<a href="https://chrome.google.com/webstore/detail/wasavi/dgogifpkoilgiofhhhodbodcfgomelhe?hl=ja">こちら</a>からインストールできます。</p>
<h2 id="どんな感じ">どんな感じ？</h2>
<p>こんな感じです。
<img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/9969098a-225a-b73c-b3f8-c1392de16987.gif" alt="wasavi.gif"></p>
<h2 id="使い方">使い方</h2>
<p>デフォルトは<code>CTRL-Enter</code>でViに切り替わります。
<code>:w</code>で入力が反映され、<code>:wq</code>で反映してViを終了します。</p>
<p>他にもオプションなどを設定できます。</p>
<h2 id="設定">設定</h2>
<p>いくつかの<code>ex</code>コマンドが使用できます。
<img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/89b155b0-bc81-2484-3066-84cc5344340e.png" alt="image.png"></p>
<p>デフォルトではbellが鳴るのでそれをオフにすると良いです。（bellのオプションがあるが、なぜか効かなかったので）</p>
<pre><code>set bellvolume=0
</code></pre><p>デフォルトは<code>textarea</code>のみ対象になっていますが、<code>input</code>系も入れておくと便利です。
<img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/fb1ebfdb-e878-5122-be35-16a33bfc7483.png" alt="image.png"></p>
<p>Vimに切り替えるキーをいくつか設定できます。デフォルトは<code>CTRL-Enter</code>です。
<img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/1eb7b914-aac1-938a-6367-6182514bf7c7.png" alt="image.png"></p>
<h2 id="さいごに">さいごに</h2>
<p>日本語入力の削除の挙動が若干変ですが、とても便利なのでVimmerの方はぜひ試して見ください
ぼくはQOLが上りまくりです</p>
]]></content></item><item><title>Vimでタブ文字を可視化する</title><link>https://skanehira.github.io/blog/posts/20200606-vim-show-tab/</link><pubDate>Sat, 06 Jun 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200606-vim-show-tab/</guid><description>初めに こんにちは ゴリラです みなさんVimではタブ、空白文字を可視化できることは知っていますか？ タブ、空白文字を可視化することによって、空白と</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>こんにちは
ゴリラです</p>
<p>みなさんVimではタブ、空白文字を可視化できることは知っていますか？
タブ、空白文字を可視化することによって、空白とタブ文字が混在するのを事前に察知できるので、コーディングするときに役に立つことがあるかと思います。</p>
<p>今日はVimでのタブ、空白文字の可視化のやり方について解説していきます。</p>
<h2 id="やり方">やり方</h2>
<p>Vimには<code>listchars</code>というオプションがあります。
このオプションにタブや空白をどんな文字で可視化するか、という設定ができます。</p>
<p><code>listchars</code>に設定できる値は次になっています。（ヘルプ抜粋）
ほかにも設定値がいくつかあるので気になる人は<code>:h listchars</code>でヘルプを参照してください。</p>
<table>
<thead>
<tr>
<th>設定値</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>eol:文字</td>
<td>行末の表示に使われる文字を指定</td>
</tr>
<tr>
<td>tab:xy[z]</td>
<td>タブ文字の表示に使われる文字を指定</td>
</tr>
<tr>
<td>space:文字</td>
<td>空白の表示に使われる文字を指定</td>
</tr>
<tr>
<td>trail:文字</td>
<td>行末のスペースの表示に使われる文字を指定</td>
</tr>
</tbody>
</table>
<p>たとえば、タブ文字を<code>&gt;-</code>で可視化したい場合は<code>set listchars=tab:&gt;-</code>、
複数の設定値を適用したい場合は<code>set listchars=tab:&gt;-,space:-</code>というふうに設定します。</p>
<p>例の説明では次の画像のようになります。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/dec5832f-c5ec-64a3-ca14-78bb0f6704ef.png" alt="image.png"></p>
<h2 id="さいごに">さいごに</h2>
<p>このオプションは地味ですが、可視化して見やすくなるのに役立ちますので、ぜひ試してみてください。
ちなみに、ぼくはタブと空白文字を<code>ｳﾎ</code>にしています。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/eea9cadc-d404-d6b2-5528-03836ef72e1d.png" alt="image.png"></p>
]]></content></item><item><title>プロセスをあいまい検索してkillするツールをGoで作った</title><link>https://skanehira.github.io/blog/posts/20200524-go-fuzzy-kill-process/</link><pubDate>Sun, 24 May 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200524-go-fuzzy-kill-process/</guid><description>初めに 仕事しているとプロセスをkillすることがたまにあると思います。 だいたいはps、awk、grepで必要なプロセスIDを抽出してkill</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>仕事しているとプロセスをkillすることがたまにあると思います。</p>
<p>だいたいは<code>ps</code>、<code>awk</code>、<code>grep</code>で必要なプロセスIDを抽出して<code>kill</code>コマンドに渡していますが、
ぼくはそれがとても面倒に感じているので、あいまい検索してプロセスをkillしたいなと思って<code>fk(fuzzy-finder-killer)</code>ってコマンドを作りました。</p>
<p><img src="https://i.imgur.com/Q6ONFRz.gif" alt=""></p>
<h2 id="導入と使い方">導入と使い方</h2>
<p><code>go get github.com/skanehira/fk</code>もしくは<a href="https://github.com/skanehira/fk/releases">releases</a>からバイナリをダウンロードしてください。</p>
<p>使い方は <code>fk</code> を実行するだけです。
<code>fk</code> を実行するとあいまい検索できる状態になるので、任意の単語を入力して、<code>CTRL-i</code>で選択します。
<code>Enter</code>で選択済みのプロセスをkillします。</p>
<p>キーバインドは次になります。</p>
<table>
<thead>
<tr>
<th>key</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CTRL-i</td>
<td>select/unselect</td>
</tr>
<tr>
<td>CTRL-j</td>
<td>go to next</td>
</tr>
<tr>
<td>CTRL-k</td>
<td>go to prev</td>
</tr>
<tr>
<td>CTRL-c</td>
<td>abort</td>
</tr>
<tr>
<td>Enter</td>
<td>kill</td>
</tr>
</tbody>
</table>
<h2 id="しくみ">しくみ</h2>
<p>あいまい検索のUIは<a href="github.com/ktr0731/go-fuzzyfinder">go-fuzzyfinder</a>というライブラリを使っています。
こちらのライブラリは<code>fzf</code>と似たインタフェースを持っていてかつとてもシンプルですので、GoでfzfのようなUIを使いたい場合はぜひ使ってみてください。</p>
<p>プロセス一覧は<a href="github.com/mitchellh/go-ps">go-ps</a>というライブラリを使っています。このライブラリでプロセスIDとコマンド名を取得できるので、それを<code>go-fuzzyfinder</code>に渡します。</p>
<p>メインの処理は次の部分になります。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">processes</span><span class="p">()</span> <span class="p">([]</span><span class="nx">process</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">processes</span> <span class="p">[]</span><span class="nx">process</span>
	<span class="nx">procs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ps</span><span class="p">.</span><span class="nf">Processes</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">procs</span> <span class="p">{</span>
		<span class="c1">// skip pid 0
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Pid</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">processes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">processes</span><span class="p">,</span> <span class="nx">process</span><span class="p">{</span>
			<span class="nx">Pid</span><span class="p">:</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Pid</span><span class="p">(),</span>
			<span class="nx">Cmd</span><span class="p">:</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Executable</span><span class="p">(),</span>
		<span class="p">})</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">processes</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nx">procs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">processes</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintln</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">idx</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fuzzyfinder</span><span class="p">.</span><span class="nf">FindMulti</span><span class="p">(</span>
		<span class="nx">procs</span><span class="p">,</span>
		<span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%d: %s&#34;</span><span class="p">,</span> <span class="nx">procs</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Pid</span><span class="p">,</span> <span class="nx">procs</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Cmd</span><span class="p">)</span>
		<span class="p">},</span>
	<span class="p">)</span>
	<span class="o">...</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">idx</span> <span class="p">{</span>
		<span class="nx">pid</span><span class="p">,</span> <span class="nx">cmd</span> <span class="o">:=</span> <span class="nx">procs</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Pid</span><span class="p">,</span> <span class="nx">procs</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Cmd</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">pid</span><span class="p">,</span> <span class="nx">cmd</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">kill</span><span class="p">(</span><span class="nx">pid</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintln</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div><h2 id="おわり">おわり</h2>
<p>小さなツールですが、プロセスをkillする面倒さから開放されます。
ぜひ試してみてください</p>
]]></content></item><item><title>エディタで複数のファイルを簡単にコピーするコマンドをGoで作った</title><link>https://skanehira.github.io/blog/posts/20200523-mcp/</link><pubDate>Sat, 23 May 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200523-mcp/</guid><description>エディタを使って複数のファイルを簡単にコピーするコマンドmcpを作りました。 このコマンドはファイルをエディターで一括リネームするツールをGo</description><content type="html"><![CDATA[<p>エディタを使って複数のファイルを簡単にコピーするコマンド<a href="https://github.com/skanehira/mcp">mcp</a>を作りました。</p>
<p><img src="https://i.imgur.com/2D9S6WW.gif" alt=""></p>
<p>このコマンドは<a href="https://itchyny.hatenablog.com/entry/2020/01/10/100000">ファイルをエディターで一括リネームするツールをGo言語で作った！ ― 機能を増やさない信念と、OSSとの付き合い方</a>で<code>mmv</code>を知ってしばらく使っていたら、リネームではなくコピーもほしいなと思い作りました。</p>
<h2 id="使い方">使い方</h2>
<p>ファイル名を引数で渡すと<code>$EDITOR</code>に設定されているエディタが起動、ファイル名を編集して保存することで編集後のパスにファイルがコピーされます。
ファイル名だけではなく、ワイルドカードも使えます。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ mcp *
</code></pre></div><p>コピー元がディレクトリの場合はそのディレクトリをまるごとコピーします。<code>cp -r</code>に相当します。</p>
<h2 id="さいごに">さいごに</h2>
<p>ブログに記載されている機能を増やさない信念は個人的にともて感銘を受けた言葉です。
これまでツールをいくつか作ってきましたが、どれも機能をたくさん盛り込んできました。ひとつのツールでなるべくたくさんのことができたほうがよいと思っていたからです。</p>
<p>しかし、ツールが多機能になっていくとそのぶんメンテナンスがめちゃくちゃたいへんになっていきます。
便利さとたいへんさは比例するんだなってこのブログを読んでから気付きました。</p>
<p>今後は新しいものを作るとき、機能を増やさない信念を念頭に入れていこうと思います。</p>
]]></content></item><item><title>docker-composeの仕様であるCompose Specificationについて</title><link>https://skanehira.github.io/blog/posts/20200506-docker-compose-specification/</link><pubDate>Wed, 06 May 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200506-docker-compose-specification/</guid><description>初めに こんにちは。 ゴリラです。 先日、Docker社がdocker-composeが提供していた機能の仕様をCompose Specificat</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>こんにちは。
ゴリラです。</p>
<p>先日、Docker社が<code>docker-compose</code>が提供していた機能の仕様を<a href="https://compose-spec.io/">Compose Specification</a>としてオープンな仕様にしていく発表がありました。</p>
<p><code>docker-compose</code>自体はオープンソースとして<a href="https://github.com/docker/compose">GitHub.ocm/docker/compose</a>に公開されてはいますが、
具体的な仕様については定まっていなかったので、今後はそれらの機能の仕様を標準化をしていくそうです。</p>
<p>現時点決まっている仕様は<a href="https://github.com/compose-spec/compose-spec">compose-spec/compose-spec</a>で公開されています。
仕様に沿ってリファレンス実装である<a href="https://github.com/compose-spec/compose-ref">compose-ref</a>も公開されています。</p>
<p>本記事は<code>compose-ref</code>を試してわかったことを共有するのが目的です。
気になる方はぜひ最後まで読んでみてください。</p>
<h2 id="compose-refのインストール"><code>compose-ref</code>のインストール</h2>
<p><code>compose-ref</code>はGoで書かれていますので、Goをあらかじめ用意して次の手順でインストールします。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ git clone https://github.com/compose-spec/compose-ref.git
$ <span class="nb">cd</span> compose-ref
$ go install
$ compose-ref

 .---.
<span class="o">(</span>     <span class="o">)</span>
 <span class="o">)</span>@ @<span class="o">(</span>
//<span class="o">||</span><span class="p">|</span><span class="se">\\</span>

NAME:
   compose-ref - Reference Compose Specification implementation

USAGE:
   compose-ref <span class="o">[</span>global options<span class="o">]</span> <span class="nb">command</span> <span class="o">[</span><span class="nb">command</span> options<span class="o">]</span> <span class="o">[</span>arguments...<span class="o">]</span>

COMMANDS:
   up       Create and start application services
   down     Stop services created by <span class="sb">`</span>up<span class="sb">`</span>
   help, h  Shows a list of commands or <span class="nb">help</span> <span class="k">for</span> one <span class="nb">command</span>

GLOBAL OPTIONS:
   --file FILE, -f FILE          Load Compose file FILE <span class="o">(</span>default: <span class="s2">&#34;compose.yaml&#34;</span><span class="o">)</span>
   --project-name NAME, -n NAME  Set project name NAME <span class="o">(</span>default: Compose file<span class="err">&#39;</span>s folder name<span class="o">)</span>
   --help, -h                    show <span class="nb">help</span> <span class="o">(</span>default: <span class="nb">false</span><span class="o">)</span>
</code></pre></div><h2 id="compose-fileについて"><code>Compose file</code>について</h2>
<p><code>docker-compose</code>ではデフォルトで<code>docker-compose.yaml</code>もしくは<code>docker-compose.yml</code>を読み込むようになっていますが、
本仕様では<code>compose.yaml</code>もしくは<code>compose.yml</code>をデフォルトで読み込みます。</p>
<p>ただ、後方互換を維持するために<code>docker-compose.yaml</code>もサポートするとのことです。
これについては<a href="https://github.com/compose-spec/compose-spec/blob/master/spec.md#compose-file">こちら</a>に記述されています。</p>
<h2 id="動作確認">動作確認</h2>
<p>現時点では<code>up</code>と<code>down</code>しか実装されていませんが、最低限コンテナの作成と削除はできますので、試してみましょう。
まず次の<code>compose.yaml</code>を用意します。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ cat compose.yaml
version: <span class="s1">&#39;3.7&#39;</span>

services:
   wordpress:
     image: wordpress:latest
     container_name: wordpress
     depends_on:
       - db
     ports:
       - <span class="s2">&#34;8000:80&#34;</span>
     environment:
       WORDPRESS_DB_HOST: db:3306
       WORDPRESS_DB_USER: wordpress
       WORDPRESS_DB_PASSWORD: wordpress
       WORDPRESS_DB_NAME: wordpress
     restart: always
   db:
     image: mysql:5.7
     container_name: wordpress_db
     restart: always
     environment:
       MYSQL_ROOT_PASSWORD: root
       MYSQL_DATABASE: wordpress
       MYSQL_USER: wordpress
       MYSQL_PASSWORD: wordpress
</code></pre></div><p>用意できたら次にイメージをpullしてきます。<code>docker-compose</code>ではイメージがなければ自動でpullしてくれますが、残念ながらこのリファレンス実装では自動でイメージをpullする実装になっていないです。
イメージがないと次のように<code>No suc image: wordpress:latest</code>というメッセージが出ます。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ compose-ref up

 .---.
<span class="o">(</span>     <span class="o">)</span>
 <span class="o">)</span>@ @<span class="o">(</span>
//<span class="o">||</span><span class="p">|</span><span class="se">\\</span>

Creating container <span class="k">for</span> service db ... 4f50328e447116aebe091c150607eb5dee1bee83b01e622785c8141c4dbf5a09
Creating container <span class="k">for</span> service wordpress ... 2020/05/06 15:35:05 Error response from daemon: No such image: wordpress:latest
</code></pre></div><p>イメージを用意できたら<code>up</code>しましょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ compose-ref up

 .---.
<span class="o">(</span>     <span class="o">)</span>
 <span class="o">)</span>@ @<span class="o">(</span>
//<span class="o">||</span><span class="p">|</span><span class="se">\\</span>

Creating container <span class="k">for</span> service wordpress ... 12cee476290011aae97abe9982dc43be164449adade2cdb55467828d92362cf6
Stopping containers <span class="k">for</span> service hello-world ... 3135cb302bba563ee4da9c54428d5083d45487727b41c2a28f7c4abbb2273aea

$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                          PORTS                  NAMES
12cee4762900        wordpress:latest    <span class="s2">&#34;docker-entrypoint.s…&#34;</span>   <span class="m">47</span> seconds ago      Up <span class="m">46</span> seconds                   0.0.0.0:8000-&gt;80/tcp   blissful_edison
4f50328e4471        mysql:5.7           <span class="s2">&#34;docker-entrypoint.s…&#34;</span>   <span class="m">4</span> minutes ago       Restarting <span class="o">(</span>1<span class="o">)</span> <span class="m">11</span> seconds ago                          inspiring_blackwell
</code></pre></div><p>現時点ではまだ、<code>container_name</code>は適用されないようですね。
ちなみに、<code>compose-ref</code>で作られたコンテナは<code>Config.Labels</code>にいくつかラベルが貼られます。確認してみましょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ docker inspect -f <span class="s2">&#34;{{ .Config.Labels }}&#34;</span> blissful_edison inspiring_blackwell
map<span class="o">[</span>io.compose-spec.config:container_name: wordpress
depends_on:
- db
environment:
  WORDPRESS_DB_HOST: db:3306
  WORDPRESS_DB_NAME: wordpress
  WORDPRESS_DB_PASSWORD: wordpress
  WORDPRESS_DB_USER: wordpress
image: wordpress:latest
ports:
- mode: ingress
  target: <span class="m">80</span>
  published: <span class="m">8000</span>
  protocol: tcp
restart: always
 io.compose-spec.project:compose-ref io.compose-spec.service:wordpress<span class="o">]</span>
map<span class="o">[</span>io.compose-spec.config:container_name: wordpress_db
environment:
  MYSQL_DATABASE: wordpress
  MYSQL_PASSWORD: wordpress
  MYSQL_ROOT_PASSWORD: root
  MYSQL_USER: wordpress
image: mysql:5.7
restart: always
 io.compose-spec.project:compose-ref io.compose-spec.service:db<span class="o">]</span>
</code></pre></div><p>ちゃんとありますね。</p>
<p>次に<code>down</code>の動作を見てみましょう。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">compose-ref down

 .---.
<span class="o">(</span>     <span class="o">)</span>
 <span class="o">)</span>@ @<span class="o">(</span>
//<span class="o">||</span><span class="p">|</span><span class="se">\\</span>

Stopping containers <span class="k">for</span> service wordpress ... 12cee476290011aae97abe9982dc43be164449adade2cdb55467828d92362cf6
Stopping containers <span class="k">for</span> service db ... 4f50328e447116aebe091c150607eb5dee1bee83b01e622785c8141c4dbf5a09
Deleting network compose-ref-default ... compose-ref-default

$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</code></pre></div><p>ちゃんと消えてますね。ネットワークまで消してくれています。</p>
<p>以上、簡単ではありますがリファレンス実装の動作確認です。まだ実装途中ですが仕様を流し読みした感じではこれまでと大きく変わることはなさそうです。</p>
<h2 id="おまけ">おまけ</h2>
<p><code>compose-ref up</code>するとき、イメージがなければpullしてくれないのは不便なのでPRを投げました</p>
<p><a href="https://github.com/compose-spec/compose-ref/pull/46">https://github.com/compose-spec/compose-ref/pull/46</a></p>
<h2 id="まとめ">まとめ</h2>
<p><code>Compose Specification</code>で仕様がある程度定まったらいろいろとおもしろくなりそうだなというのが個人的な感想です。
せっかくですので、この仕様を元に実用的なCLIを作ろうと思っています。できあたらそのうち公開します。</p>
]]></content></item><item><title>dockerのイメージ一覧APIのfiltersパラメータについて</title><link>https://skanehira.github.io/blog/posts/20200506-docker-api-filters/</link><pubDate>Wed, 06 May 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200506-docker-api-filters/</guid><description>初めに こんにちは。 ゴリラです。 dockerのイメージAPIをcurlで叩いた時にイメージをフィルタしたいが、詰まっていたのでそのやり方を備忘</description><content type="html"><![CDATA[<h2 id="初めに">初めに</h2>
<p>こんにちは。
ゴリラです。</p>
<p>dockerのイメージAPIを<code>curl</code>で叩いた時にイメージをフィルタしたいが、詰まっていたのでそのやり方を備忘録として残しておきます。</p>
<h2 id="やりたいこと">やりたいこと</h2>
<p><code>curl</code>でdockerのイメージ一覧を絞り込みたい。
<code>docker</code>コマンドだとこんな感じ。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ docker images -f <span class="nv">reference</span><span class="o">=</span>mysql
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
mysql               5.7                 84164b03fa2e        <span class="m">2</span> months ago        456MB
</code></pre></div><h2 id="やり方">やり方</h2>
<p>筆者はfishをつかっているため、<code>urlenc</code>コマンドの実行結果を<code>()</code>で取得していますがbashなどの方は<code>$()</code>に置き換えてください。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">curl -s --unix-socket /var/run/docker.sock <span class="o">(</span>urlenc -e <span class="s1">&#39;http://localhost/images/json?filters={&#34;reference&#34;: [&#34;mysql&#34;]}&#39;</span><span class="o">)</span> <span class="p">|</span> jq
<span class="o">[</span>
  <span class="o">{</span>
    <span class="s2">&#34;Containers&#34;</span>: -1,
    <span class="s2">&#34;Created&#34;</span>: 1583343003,
    <span class="s2">&#34;Id&#34;</span>: <span class="s2">&#34;sha256:84164b03fa2ecb33e8b4c1f2636ec3286e90786819faa4d1c103ae147824196a&#34;</span>,
    <span class="s2">&#34;Labels&#34;</span>: null,
    <span class="s2">&#34;ParentId&#34;</span>: <span class="s2">&#34;&#34;</span>,
    <span class="s2">&#34;RepoDigests&#34;</span>: <span class="o">[</span>
      <span class="s2">&#34;mysql@sha256:f4a5f5be3d94b4f4d3aef00fbc276ce7c08e62f2e1f28867d930deb73a314c58&#34;</span>
    <span class="o">]</span>,
    <span class="s2">&#34;RepoTags&#34;</span>: <span class="o">[</span>
      <span class="s2">&#34;mysql:5.7&#34;</span>
    <span class="o">]</span>,
    <span class="s2">&#34;SharedSize&#34;</span>: -1,
    <span class="s2">&#34;Size&#34;</span>: 455508074,
    <span class="s2">&#34;VirtualSize&#34;</span>: <span class="m">455508074</span>
  <span class="o">}</span>
<span class="o">]</span>
</code></pre></div><h2 id="解説">解説</h2>
<p><a href="https://docs.docker.com/engine/api/v1.40/#operation/ImageList">公式のAPI定義</a>には
<code>A JSON encoded value of the filters (a map[string][]string) to process on the images list. Available filters:</code>
と書いてあって、なるほどわからんって状態だったので、わかったことを解説します。</p>
<p>以下がポイントです</p>
<ol>
<li>検索条件は<code>filters</code>クエリパラメータで指定</li>
<li>指定する時のJSONの形は<code>{&quot;key&quot;: [xxx, yyy]}</code>という形でなければいけない（goの<code>go[string][]string}</code>をJSONにエンコードした形）</li>
</ol>
<p>今回はイメージ名をつかって絞り込みたいので<code>filters</code>には<code>{&quot;reference&quot;: [&quot;イメージ名&quot;]}</code>をエンコードした値を渡しています。</p>
<p>ちなみに、<code>urlenc -e 'http://localhost/images/json?filters={&quot;reference&quot;: [&quot;mysql&quot;]}'</code>はエンコードしたURLを取得できます。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ urlenc -e <span class="s1">&#39;http://localhost/images/json?filters={&#34;reference&#34;: [&#34;mysql&#34;]}&#39;</span>
http://localhost/images/json?filters<span class="o">=</span>%7B%22reference%22%3A+%5B%22mysql%22%5D%7D
</code></pre></div><p>検証に使った<code>urlenc</code>はこちらに置いてあります</p>
<p><a href="https://github.com/skanehira/go-enc">https://github.com/skanehira/go-enc</a></p>
]]></content></item><item><title>Vimで高速コーディングする方法</title><link>https://skanehira.github.io/blog/posts/20200312-high-speed-coding-with-vim/</link><pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20200312-high-speed-coding-with-vim/</guid><description>こんにちは、ゴリラです。 Vimといえば高速でコーディングできるという印象を持っている方が多いのではないでしょうか？ 今日は、Postfix Code C</description><content type="html"><![CDATA[<p>こんにちは、ゴリラです。</p>
<p>Vimといえば高速でコーディングできるという印象を持っている方が多いのではないでしょうか？
今日は、Postfix Code Completionという手法をつかって早くコーディングする方法紹介します。</p>
<p>この方法を使えば次のgifのように、さくっとJSONを返すHTTPサーバを立てられます。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/69080d5a-bef8-c0d3-c1cc-99efb061bbe5.gif" alt="sonictemplate-vim-sample.gif"></p>
<h2 id="postfix-code-completionとは">Postfix Code Completionとは</h2>
<p>後置補完という補完手法です。
たとえば、<code>(a == b)</code>に対して<code>if</code>を使いたい場合は<code>(a == b).if</code>と入力して展開すると<code>if (a == b) {  }</code>というふうに補完してくれます。</p>
<p>後ろのコード<code>if</code>が前のコード<code>(a == b)</code>に作用するという考え方です。
これを積極的に使用していくとより高速にコーディングできます。</p>
<p>僕の場合は、割と後置補完だけではなくスニペットのように使っています。</p>
<h2 id="vimでpostfix-code-completionを使う方法">VimでPostfix Code Completionを使う方法</h2>
<p>Vimでは<a href="https://github.com/mattn/sonictemplate-vim">sonictemplate.vim</a>というプラグインがサポートしています。
デフォルトではPostfixのパターンファイルが用意されています。<code>&lt;C-y&gt;&lt;C-b&gt;</code>でパターンを展開できます。
もちろん自分でパターンファイルを用意することもできます。</p>
<p>まず、自前のテンプレートディレクトリを設定します。僕の場合は<code>~/.vim/sonictemplate</code> しています。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">let</span> <span class="nx">g</span>:<span class="nx">sonictemplate_vim_template_dir</span> <span class="p">=</span> <span class="nx">expand</span><span class="p">(</span><span class="s1">&#39;~/.vim/sonictemplate&#39;</span><span class="p">)</span><span class="err">
</span></code></pre></div><p>次に、言語のディレクトリを作成します。ディレクトリ名はファイルタイプ名と同じにする必要があります。
<code>js</code>なら<code>javascript</code>というディレクトリを作成します。本記事ではGo言語のテンプレートを作っていきます。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ mkdir ~/.vim/sonictemplate/go
</code></pre></div><p>次に、Postfixのパターンファイルを作ります。こちらもファイル名はファイルタイプと同じです。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ vim ~/.vim/sonictemplate/go/go.stpl
</code></pre></div><p>この<code>go.stpl</code>にパターンを追記していきます。</p>
<h2 id="パターンの記述方法">パターンの記述方法</h2>
<p>次のように、1行目にパターンを2行目以降に展開後のコードを記述します。2行目以降はタブが必要です。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">\(\S\+\)\.var$
	var {{$1}} = {{_cursor_}}
</code></pre></div><p>複数のパターンは空白行で区切られています。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">\(\S\+\)\.var$
	var {{$1}} = {{_cursor_}}

\(\S\+\)\.iferr$
	if {{$1}} != nil {
		return {{$1}}
	}
	{{_cursor_}}
</code></pre></div><p>パターンは正規表現を使用できます。そして展開したコードでは<code>{{}}</code>で囲ったプラグイン独自の構文を使用できます。
上記の例では<code>{{$1}}</code>は後方参照（<code>\(\S\+\)</code>の部分）しています。<code>{{_cursor_}}</code>は展開後カーソルの位置を指定しています。
<code>{{}}</code>を使った構文はほかにもあります。ヘルプを参照してください。</p>
<h2 id="パターンの例">パターンの例</h2>
<p>ぼくが使っているパターンをいくつか紹介します。</p>
<h3 id="dbを開く">dbを開く</h3>
<ul>
<li>パターン</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">db.open\.\(&#34;.*&#34;\)\.\(&#34;.*&#34;\)$
	db, err := sql.Open({{$1}}, {{$2}})
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()
	{{_cursor_}}
</code></pre></div><ul>
<li>コード</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 展開前
</span><span class="c1"></span><span class="nx">db</span><span class="p">.</span><span class="nx">open</span><span class="p">.</span><span class="s">&#34;sqlite3&#34;</span><span class="p">.</span><span class="s">&#34;test.db&#34;</span>

<span class="c1">// 展開後
</span><span class="c1"></span><span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sql</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;sqlite3&#34;</span><span class="p">,</span> <span class="s">&#34;test.db&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</code></pre></div><h3 id="クエリを発行">クエリを発行</h3>
<ul>
<li>パターン</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">db\.query\.\(.*\)$
	rows, err := db.Query({{$1}})
	if err != nil {
		log.Fatal(err)
	}
	defer rows.Close()
	{{_cursor_}}
</code></pre></div><ul>
<li>コード</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 展開前
</span><span class="c1"></span><span class="nx">db</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="s">&#34;select * from todos&#34;</span>

<span class="c1">// 展開後
</span><span class="c1"></span><span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;select * from todos&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">defer</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</code></pre></div><h3 id="jsonのエンコード">JSONのエンコード</h3>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">json\.encode\.\(\S\+\)\.\(\S\+\)$
	if err := json.NewEncoder({{$1}}).Encode({{$2}}); err != nil {
		{{_cursor_}}
	}
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 展開前
</span><span class="c1"></span><span class="nx">json</span><span class="p">.</span><span class="nx">encode</span><span class="p">.</span><span class="nx">writer</span><span class="p">.</span><span class="o">&amp;</span><span class="nx">gorilla</span>

<span class="c1">// 展開後
</span><span class="c1"></span><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">NewEncoder</span><span class="p">(</span><span class="nx">writer</span><span class="p">).</span><span class="nf">Encode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gorilla</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	
<span class="p">}</span>
</code></pre></div><h3 id="jsonのデコード">JSONのデコード</h3>
<ul>
<li>パターン</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">json\.decode\.\(\S\+\)\.\(\S\+\)$
	if err := json.NewDecoder({{$1}}).Decode({{$2}}); err != nil {
		{{_cursor_}}
	}
</code></pre></div><ul>
<li>コード</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 展開前
</span><span class="c1"></span><span class="nx">json</span><span class="p">.</span><span class="nx">decode</span><span class="p">.</span><span class="nx">reader</span><span class="p">.</span><span class="o">&amp;</span><span class="nx">gorilla</span>

<span class="c1">// 展開後
</span><span class="c1"></span><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">reader</span><span class="p">).</span><span class="nf">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gorilla</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	
<span class="p">}</span>
</code></pre></div><h3 id="append">append</h3>
<ul>
<li>パターン</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">\(\S\+\)\.append\.\(\S\+\)$
	{{$1}} = append({{$1}}, {{$2}})
	{{_cursor_}}
</code></pre></div><ul>
<li>コード</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 展開前
</span><span class="c1"></span><span class="nx">gorillas</span><span class="p">.</span><span class="nx">append</span><span class="p">.</span><span class="nx">gorilla</span>

<span class="c1">// 展開後
</span><span class="c1"></span><span class="nx">gorillas</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">gorillas</span><span class="p">,</span> <span class="nx">gorilla</span><span class="p">)</span>
</code></pre></div><h3 id="httpサーバ">HTTPサーバ</h3>
<ul>
<li>パターン</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">http\.server\.\(\S\+\)$
	http.HandleFunc(&#34;/&#34;, func(w http.ResponseWriter, r *http.Request) {
		{{_cursor_}}
	})
	log.Println(&#34;start http server :{{$1}}&#34;)
	log.Fatal(http.ListenAndServe(&#34;:{{$1}}&#34;, nil))
</code></pre></div><ul>
<li>コード</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 展開前
</span><span class="c1"></span><span class="nx">http</span><span class="p">.</span><span class="nx">server</span><span class="mf">.8080</span>

<span class="c1">// 展開後
</span><span class="c1"></span><span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	
<span class="p">})</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;start http server :8080&#34;</span><span class="p">)</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
</code></pre></div><h4 id="main">main</h4>
<ul>
<li>パターン</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">^main$
	package main
	
	func main() {
		{{_cursor_}}
	}
</code></pre></div><ul>
<li>コード</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 展開前
</span><span class="c1"></span><span class="nx">main</span>

<span class="c1">// 展開後
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	
<span class="p">}</span>
</code></pre></div><h2 id="最後に">最後に</h2>
<p>いかがですか？
この記事を見て少しでも早くコーディングできるようになったらうれしいです。</p>
<p>では良いコーディングライフを〜</p>
]]></content></item><item><title>2019年の振り返り</title><link>https://skanehira.github.io/blog/posts/20191230-look-back-2019/</link><pubDate>Tue, 31 Dec 2019 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20191230-look-back-2019/</guid><description>今年は個人的に人生の転機の年と感じているいます。 一年間振り返りつつ、来年の目標は自分の中である程度固まってのでそれも整理していきます。 今年の</description><content type="html"><![CDATA[<p>今年は個人的に人生の転機の年と感じているいます。
一年間振り返りつつ、来年の目標は自分の中である程度固まってのでそれも整理していきます。</p>
<h2 id="今年の目標">今年の目標</h2>
<p>今年だけの目標というわけではないのですが、やりたいと思っていたことを1つを除き、残りはすべて達成できました。
その1つはGoのカンファレンスに登壇することです。</p>
<table>
<thead>
<tr>
<th>目標</th>
<th>達成</th>
</tr>
</thead>
<tbody>
<tr>
<td>技術本の執筆</td>
<td>○</td>
</tr>
<tr>
<td>記事連載</td>
<td>○</td>
</tr>
<tr>
<td>商業誌出版</td>
<td>○</td>
</tr>
<tr>
<td>カンファレンス登壇</td>
<td>△</td>
</tr>
<tr>
<td>開発合宿</td>
<td>○</td>
</tr>
<tr>
<td>コミュニティ活動</td>
<td>○</td>
</tr>
<tr>
<td>OSS活動</td>
<td>○</td>
</tr>
</tbody>
</table>
<p>それぞれについて軽く振り返っていきます。</p>
<h3 id="技術本の執筆">技術本の執筆</h3>
<p>技術本を執筆したいのが1つの夢でした。ちょうど年に2度開催される<a href="https://techbookfest.org/">技術書典</a>というイベントがあって、そちらは2回とも執筆、販売しました。</p>
<p>春では<a href="https://golangtokyo.github.io/">golang.tokyo</a>で合同執筆しました。初めての執筆で文章についてたくさん指摘をいただいたのはとても良い経験になりました。</p>
<p>秋では一人で<a href="https://gorilla0513.booth.pm/items/1513974">Vimが好きになる本</a>を執筆しました。こちらはたくさんの反響があり、累計600冊以上を販売できました。書いた本がこんなにもたくさんの方に届くのはとてもうれしいことです。</p>
<p>そして、本を1冊書き上げることのたいへんさがわかりました。たった130ページくらいのボリュームですが、数ヵ月間の間ほぼ毎日コツコツ書いていました。オライリー・ジャパンあのぶん厚い本の凄さがよくわかりました（笑）</p>
<p>個人的に今年一番たいへんだったのは執筆業でした。もっと効率良く本を書く技術を身に着けたいですね。</p>
<h3 id="記事連載">記事連載</h3>
<p>春の技術書典が終わったあとに、<a href="https://twitter.com/kameneko1004">かめねこ</a>さんから声をかけていただいたことがきっかけで<a href="https://knowledge.sakura.ad.jp/">さくらのナレッジ</a>でVimの連載をもつことができました。
前から連載やりたいなと思っていたので、それができてとてもうれしかったです。</p>
<p>Vimの連載も残り1回になり、2020/01で最後になります。最後なので気合を入れようと思っています。</p>
<h3 id="商業誌出版">商業誌出版</h3>
<p>Twitterでも軽く報告させていただきましたが、
来年にVimが好きになる本の商業誌を出版することになりました。</p>
<p>エンジニアとして自分の書いた本を本屋に並べたらどれほどうれしいことか、それを想像しながらワクワクして本を執筆しました。
そしてこの本をベースとして出版社に企画を持ち込もうと考えていましたが、なんと出版社の方から声をかけていただいて、商業誌を出版することになりました。
本を書くことはけっして簡単なことじゃないし、出版することももちろんさらに難しいと思っていました。それがまさかこんなふうに決まるとは思わず、ただただうれしい気持ちでいっぱいです。</p>
<h3 id="カンファレンス登壇">カンファレンス登壇</h3>
<p>今年はVimの国際カンファレンスである<a href="https://vimconf.org/2019/">VimConf 2019</a>に参加、登壇しました。
ぼくは今年Vimにすごく力を入れていて、その集大成としてカンファレンス登壇をしたいとずっと思っていて、それを達成できてとてもうれしかったです。次のVimConfも登壇するのが目標です。</p>
<p>Vim以外にもGoのカンファレンスに登壇したかったのですが、残念ながらプロポーザルが不採用になったため登壇できませんでした。
プロポーザル不採用の原因はおそらくテーマにあった訴求内容ではなかったからだと思います。来年はリベンジします。</p>
<h3 id="開発合宿">開発合宿</h3>
<p>ずっと開発合宿をやりたかったので、Twitterで知り合った方たちと2泊3日の開発合宿をしてきました。
今回のテーマはGoで、みんなそれぞれGoに関してやりたいことをやって、発表したり一緒にコードリーディングしたりしました。控えめに言ってとても良かったのでまた開催します。</p>
<p>ちなみに、合宿メンバーの感想や成果物は<a href="https://github.com/gorilla-camp/camp">こちら</a>にあります。気になる方は読んでみてください。</p>
<h3 id="コミュニティ活動">コミュニティ活動</h3>
<p>ぼくは今年からいろんな勉強会に参加したりしました。勉強会で得られる知見だったり、つながりはとても多くあって、どれも有益でした。
その中で、ぼくがほしいと思っているVimのコミュニティがなかったので、<a href="https://gorillavim.connpass.com/">ゴリラ.vim</a>というVimのmeetupを立ち上げ毎月Vimのイベントをやりました。</p>
<p>ゴリラ。vimの目的はVimmerやそれ興味ある方が集まり、Vimについて知見を共有したり懇親する場です。
とにかく勢いに任せてやってきたのですが、自分が勉強したい分野に時間を割けなくなりつつあるので、来年からは毎月ではなく隔月開催にします。</p>
<p>他にも<a href="https://dockerjp.connpass.com/">Docker Meetup Tokyo</a>とgolang.tokyoの運営もやっています。これ以上増やすと勉強する時間がなくなりそうと思5つ、来年はGoのコミュニティを作ろうか悩んでいます。</p>
<h3 id="oss活動">OSS活動</h3>
<p>今年はずっとOSS活動してきました。しなければ行けないと思っているわけではないのですが、時間がない中でたいへんだなと思った時もありました。
もっとOSSを作る時間欲しいなと思っています。</p>
<p>来年は仕事の時間を少し減らしOSS活動に時間を割けるようにする予定です。それができるようになるためにも技術力をもっと磨いていきます。</p>
<p>ちなみに今年は主にこんなものを作っていました。未完成のものは来年こそ完成させたいです。特にgo-composeは作りきりたいです。</p>
<table>
<thead>
<tr>
<th>OSS</th>
<th>概要</th>
<th>カテゴリ</th>
<th>スター（2019/12/26時点）</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/skanehira/docui">docui</a></td>
<td>Dockerを直感で操作できるTUIツール</td>
<td>Go</td>
<td>1658</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/pst">pst</a></td>
<td>TUIのプロセスビューア</td>
<td>Go</td>
<td>294</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/tson">tson</a></td>
<td>TUIのJSONビューア/エディタ</td>
<td>Go</td>
<td>98</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/docker.vim">docker.vim</a></td>
<td>Vim上でDockerをインタラクティブに操作するプラグイン</td>
<td>Go</td>
<td>80</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/gjo">gjo</a></td>
<td>JSON生成コマンドラインツール</td>
<td>Go</td>
<td>69</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/ff">ff</a></td>
<td>TUIのファイラ</td>
<td>Go</td>
<td>62</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/translate.vim">translate.vim</a></td>
<td>Vim上でGoogle翻訳できるプラグイン</td>
<td>Vim</td>
<td>52</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/go-starwars">go-starwars</a></td>
<td>スターウォーズを流すコマンド</td>
<td>Go</td>
<td>33</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/gocui-component">gocui-component</a></td>
<td>gocuiのコンポーネントライブラリ</td>
<td>Go</td>
<td>23</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/docker-compose.vim">docker-compose.vim</a></td>
<td>Vim上でdocker-composeを使うためのラッパプラグイン</td>
<td>Vim</td>
<td>22</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/badapple.vim">badapple.vim</a></td>
<td>Vim上でbadappleを流すプラグイン</td>
<td>Vim</td>
<td>17</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/gtran">gtran</a></td>
<td>Google翻訳コマンド（translate.vimで使っている）</td>
<td>Go</td>
<td>14</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/go-run">go-run</a></td>
<td>パイプまたは文字列からGoのコードを実行するコマンド</td>
<td>Go</td>
<td>4</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/badapple.vim">say.vim</a></td>
<td>Macのsayコマンドのラッパプラグイン</td>
<td>Vim</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/go-compose">go-compose</a></td>
<td>docker-composeのGo移植版（未完成）</td>
<td>Go</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/generatedir.vim">generatedir.vim</a></td>
<td>JSON定義をもとにプロジェクトのテンプレートを作成するプラグイン</td>
<td>Vim</td>
<td>2</td>
</tr>
<tr>
<td><a href="https://github.com/skanehira/badapple.vim">go-enc</a></td>
<td>各種エンコード、デコードコマンド（未完成）</td>
<td>Go</td>
<td>0</td>
</tr>
</tbody>
</table>
<h2 id="来年の目標">来年の目標</h2>
<p>OSS活動だったり、イベント開催や参加だったり、今年はすごく濃い一年間でした。
いろいろなことを学んでいった中でさらにやりたいことが出てきました。それが次になります。</p>
<table>
<thead>
<tr>
<th>目標</th>
<th>概要</th>
</tr>
</thead>
<tbody>
<tr>
<td>プログラミング言語を作る</td>
<td>Go言語で作るインタプリタをやりきって理解する</td>
</tr>
<tr>
<td>Goを補完なしでかけるようになる</td>
<td>補完プラグインを使わない、GoDocをたくさん読む</td>
</tr>
<tr>
<td>Goの講師をやる</td>
<td>来年講師をやる予定ですので、それらをやりきる</td>
</tr>
<tr>
<td>Goのカンファレンスに登壇する</td>
<td>国内のGoカンファレンスに登壇する</td>
</tr>
<tr>
<td>Vimのカンファレンスに登壇する</td>
<td>来年もあれば登壇を目指す</td>
</tr>
<tr>
<td>HTTPサーバをスクラッチで作る</td>
<td><a href="https://triple-underscore.github.io/rfc-others/RFC2616-ja.html">HTTP 1.1</a>を元にGoで作る</td>
</tr>
</tbody>
</table>
<p>上記の目標は必達ですが、それ以外に努力目標としてネットワークスペシャリストの試験を合格するというのがあります。
来年は必達標をすべて達成してやるという気持ちでまた一年を突っ走ります。</p>
]]></content></item><item><title>VimConf2019に参加＆発表してきた</title><link>https://skanehira.github.io/blog/posts/20191103-vimconf-2019/</link><pubDate>Sun, 03 Nov 2019 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20191103-vimconf-2019/</guid><description>こんにちは。ゴリラです。 2019/11/03（日）にVimConf2019が開催され、そちらに発表&amp;amp;参加してきた記事です。 始めに 最高</description><content type="html"><![CDATA[<p>こんにちは。ゴリラです。</p>
<p>2019/11/03（日）に<a href="https://vimconf.org/2019/">VimConf2019</a>が開催され、そちらに発表&amp;参加してきた記事です。</p>
<h2 id="始めに">始めに</h2>
<p>最高でした！
そしてありがとうございました！
という気持ちです。</p>
<p>セッションを振り返りながら、何を得たのかをまとめて行きたいと思います。</p>
<h2 id="キーノート">キーノート</h2>
<h3 id="vim-renaissance-by-prabir-shrestha">Vim Renaissance by [Prabir Shrestha]</h3>
<h4 id="概要">概要</h4>
<p><a href="https://github.com/prabirshrestha/vim-lsp">vim-lsp</a>の作者のによるキーノート。
Vimはこれまでの、そしてこれからの数年間は進化・革命が起きている。これからも革命が続いていく話。
具体的に、float windowやpopup windowの実装、非同期ジョブ機能、ターミナル機能などがここ数年で行われてきた。</p>
<p>Prabir氏がvim-lspを作り始めたころはvimのLSP clientプラグインがなかったそう。
驚いたことに、Vim scriptを書き始めたのはここ2,3年とのこと。</p>
<p>vim-lspでの実装で苦労したのは仕様に沿って実装したLSP Serverがなくて、いろんなServerに対応したこと。</p>
<p>現在MSのプロジェクトマネージャーで、コードを書くことがあまりなく、また休日などは飛行機を飛ばしたりと趣味に時間を費やしていることが多い。</p>
<p>OSSに関しては、何かアイデアを思いついたとき、深夜までやることもあるが、
やらなきゃと思ってやっているわけではないので、毎日OSS活動に時間を費やしているわけではないとのこと。</p>
<h4 id="所感">所感</h4>
<ul>
<li><strong>多くのエンジニアが生産性を上げられるようにプラグインを作りたい</strong></li>
<li><strong>OS（Mac,Linux,Windows）エディタ（Neovim,Vim）を定期的に変えながら使っている。</strong></li>
</ul>
<p>この2点はとても個人的に刺さった。
マルチプラットフォーム対応、そしていろんなエンジニア、いろんな環境を想定したうえでOSSを作っている理念と姿勢は本当にすごいなと思った。</p>
<p>ぼくもOSS活動をしているけど、OSとエディタを切り替えながら使っているわけではないし、Windows対応もほとんどしていない。
だからこそ、彼の理念と姿勢はすごいし、あこがれるものがあった。
少しずつだけど　Windowsでもちゃんと動くものを作っていこうとあらためて思った。</p>
<h3 id="we-can-have-nice-things-by-justin-m-keyes">We can have nice things by [Justin M. Keyes]</h3>
<h4 id="概要-1">概要</h4>
<p>Neovimの話だけではなく、テキストエディタ、開発の思想などを話していた。
5年前のテキストエディタのシーンとかなり違ってきたとのこと。
NeoVimのゴールは「Vimに置き換わること」ではなく「Vimの最大化」とのこと。</p>
<p>エディタの将来を考える ＝ 過去を考えるのと同意義とのこと。
レガシーシステムはネガティブな意味しかない、というわけではなく過去に成功したプロジェクトもある。
過去の財産を活用すべきとのこと。</p>
<h4 id="所感-1">所感</h4>
<p>非常に落ち着いた雰囲気な方だった。
そしてスライドが100ページを超えて時間切れでLuaの話を聞けなかったのはとても残念だけど、
物静かな語りの下にはすごい情熱と思いがあるんだなと思った。（じゃなければ100枚のスライドを作ってくることはないでしょう）</p>
<p>セッション自体はエディタにスポットを当てた話だけではなく</p>
<ul>
<li><strong>過去の遺産（レガシ）は悪いものではなく、成功した事例もあるし、そこから学べることもある</strong></li>
<li><strong>利用できるものは利用しないという手はない</strong></li>
</ul>
<p>という考えにすごく刺さった。まさにその通りだなと思った。
ただ、個人的に意識しておきたいところは、再利用をするだけで終わらせないこと。少しでもよいから、しくみを理解すること。</p>
<p>人類の文明も、そうやって再利用の積み重ねなんだよなぁと。車輪の再利用をしなければ進化はもっと遅かったんだろうなぁと。</p>
<p>そしてキーノートを聞いたあと、Neovimも使おうとあらためて思った。というのももう少しモダンな機能を触ってみ対し、それぞれの良さを知っておきたいから。</p>
<p>現時点では、Vimはこれまで保守的で安定性を求めているのに対して、Neovimはモダンな機能を取り入れる姿勢が強いという違いくらいしか知らなくて、
もっと自分で身を持って知っていきたいという思いが強くなってきたから。</p>
<p>このセッションではものづくりをしていく上で大事な考え方、姿勢についてあらためて学べたのでとても良かった。</p>
<h2 id="セッション">セッション</h2>
<h3 id="your-vim-is-only-for-you-by-mopp">Your Vim is Only for You by [mopp]</h3>
<h4 id="概要-2">概要</h4>
<p>自分のエディタの育て方についての話。</p>
<ul>
<li>自分のvimrcを改善するには、自分のポリシーをまず見つけることが大事。</li>
<li>半年に一度vimrcを整理することをお勧めする。</li>
<li>コピー&amp;ペーストするだけは良くない、理解もしていくことが大事。</li>
<li>dotfilesを管理するツールは<a href="https://github.com/anishathalye/dotbot">dotbot</a>というOSSを使っている。</li>
<li>vimrcをどんなフローで改善していけばいけばよいのか。</li>
</ul>
<p>といった内容だった。</p>
<h4 id="所感-2">所感</h4>
<p>moppさんのvimrcの改善フローは思考整理されていてとてもよくまとめられているなぁと思った。
そして</p>
<ul>
<li><strong>自分のvimrcを改善するには、自分のポリシーをまず見つけることが大事</strong></li>
</ul>
<p>という言葉がすごく印象強く残った。
普段から意識しているわけではないけど、ポリシー大事だよなぁと思った。
ポリシーがなければ方向性がぶれてしまう上、何をしたいのかわからなくなるので、まずは「どんなエディタにしたいのか」を考えると良いんだなと思った。</p>
<p>個人的にvimrcの掃除に関しては、
月に一度やりたいと思っているけど、最近放置気味なのでそろそろメンテナンスしようと思った。</p>
<p>このセッションは、Vimを始めたばっかりのころに聞きたかったなぁと思ったので、
これからだっていう方にとってとてもためになるセッションと思った。</p>
<p>ちなみに、moppさんは一度ゴリラ。vimに参加してくれたことがあって、
また参加して今度は発表してほしいなと思った。（本人にはまだ言っていない）</p>
<h3 id="grown-up-from-vim-user-to-vim-plugin-developer-side-by-ik">Grown up from Vim User to Vim plugin developer side by [IK]</h3>
<h4 id="概要-3">概要</h4>
<p>ユーザーから開発側に成長していくお話。</p>
<ul>
<li>普段は学生をしているとのこと</li>
<li>最近Vim scriptしか書いていないとのこと（一時期の自分と同じｗ）</li>
<li>学校ではVSCodeを使っていたが、学部の先輩にVimをお勧めされて使うようになったとのこと。</li>
<li>Shougoさんのプラグインをたくさん使っていてDark side Vimmerとのこと。</li>
<li>いままでプラグインを入れてバグがあった場合、我慢して使うか、切り捨てるかしかなかったけど、
OSSコントリビュートしてから考えが変わった。</li>
<li>自分でバグを直したりという選択肢が増えた</li>
<li>いろんなプラグインにPRよく投げている</li>
<li>OSS貢献は怖くない、issueとPRは開発者が望んでいる</li>
<li><strong>一歩踏み出す勇気があればOSSコントリビューターになれる</strong></li>
</ul>
<h4 id="所感-3">所感</h4>
<p>結かまいろんなプラグインにコントリビュートしていて、行動力もあってすごいなと思った。</p>
<p>そして、自分自身が一歩を踏み出すことによって、新しい世界に飛び込んで、
自分自身も成長できたという話は若いながらそこに気付けて、やれたのはすごいなと思った。</p>
<p>個人的にこれからが楽しみだし、負けられないなと思った。</p>
<p>ちなみに、IKさんも一度ゴリラ。vimに来てくれて登壇もしてくれた。また来てほしい。</p>
<h3 id="usage-and-manipulation-of-the-tag-stack-by-daisuzu">Usage and manipulation of the tag stack by [daisuzu]</h3>
<h4 id="概要-4">概要</h4>
<p>vim-lspのタグジャンプのバグを直したのと、タグスタックのしくみの話。</p>
<ul>
<li>諸事情により、VimConfのCfPを出す必要があるので、vim-lspのバグを直してCfPを出して通った（まさに登壇駆動開発、しかもカンファレンス）</li>
<li>基本的にタグジャンプの使い方を紹介</li>
<li>タグスタックの構造体の説明</li>
<li>タグジャンプするときの構造体がどうなっているのかが細かく、わかりやすく図で説明されていた</li>
</ul>
<h4 id="所感-4">所感</h4>
<p>スライドによる説明だけだったが、ケースごとのタグスタックの動きがめっちゃくちゃわかりやすかった。</p>
<p>VimConf2018年の発表もそうだったが、すごくきれいでわかりやすい発表だったので、さすがだなぁと思った。
自分もこういった発表ができたらなぁと思えるとてもわかりやすい、すばらしい発表だった。</p>
<p>ちなみに、
daisuzuさんは普段一緒にゴリラ。vimの運営をやっていて、いつも助けられているので頭が上がらない…</p>
<h3 id="make-test-by-m-nishi">make test by [m-nishi]</h3>
<h4 id="概要-5">概要</h4>
<p>Vim本体のテストの話だけど、次が発表だったためほぼ聞いていなかった…
動画が公開されたらちゃんとあらためて見る！一応覚えている範囲内で書き出すと…</p>
<ul>
<li>これまで何回かVim本体にコントリビュートして名前が載った</li>
<li>Vimのテストの実行方法</li>
</ul>
<p>について話されていた。（はず）</p>
<h4 id="所感-5">所感</h4>
<p>僕の中で、m-nishiさんといえばテスト・翻訳という印象があった。
というのも、最初にお会いしたときにテストコードをいじったり、見たりしているという話を聞いてすごいなと思った。</p>
<p>自分はVim本体に一度だけコントリビュートしたけど、
正直テストとか1ケースしか書いていないし、実行のし方もm-nishiさんに教わったし、そういった出来こともあってその印象が残った。</p>
<p>そして、スライドの背景はVimになっていて、ちゃんとページ数が増えていくたびに行数が増えていく仕様になっていて、おしゃれでよいなと思った。</p>
<p>ちなみに、m-nishiさんも何度かゴリラ。vimに参加してくださって、過去に発表もしていただいたことがあった。
実はそのときに使っていたスライドを今回も使っていて実は見たことがあるんだぜって心の中で自慢していたのは内緒（笑）</p>
<h3 id="my-vim-life-by-gorilla0513">My Vim life by [gorilla0513]</h3>
<h4 id="概要-6">概要</h4>
<p>ゴリラがVimについてどんな活動をしてきたのか、どのように学んだのか、Vimを使ってどうやって生産性を上げてきたのかといった話。</p>
<ul>
<li>なぜVimを使い始めたのか</li>
<li>どのようにVimを学んできたのか（ヘルプを読み漁ったり、毎日Vimを使ったり、プラグイン作ったり、記事の連載だったり、本の執筆だったり）</li>
<li>どのようにVimを使って生産性を上げてきたのか（プラグイン、vimrc、プラグイン選定のポイント、お勧めのプラグインなど）</li>
</ul>
<h4 id="所感-6">所感</h4>
<p>今回の発表のターゲット層は初級者〜中級者あたりまでというイメージで話した。
Vim歴は1年だけど、1年だからこそ背中を見せられて道を示せられると思ったので、やってきたこと・考えてきたことを話した。</p>
<p>少しでもみんなの心に刺さって、刺激、モチベになれたらよいなと。</p>
<p>ちなみに、ぼくは<a href="https://gorillavim.connpass.com/">ゴリラ.vim</a>というコミュニティを運用していて、月イチでイベントを開催しているので、
興味ある方はぜひ遊びに来てください。
今月は<a href="https://gorillavim.connpass.com/event/153765/">ゴリラ.vim #10 非公式VimConf後夜祭 girls.vimと合同開催</a>です！</p>
<p>また、<a href="https://gorilla0513.booth.pm/items/1513974">Vimが好きになる本</a>も執筆して販売していて、
さくらのナレッジで<a href="https://knowledge.sakura.ad.jp/serialization/gorilla-vim/">Vimはいいぞ！ゴリラと学ぶVim講座</a>という連載を持っています。
興味ある方はぜひ覗いてみてください。</p>
<h3 id="using-vim-at-work-by-danish-prakash">Using Vim at Work! by [Danish Prakash]</h3>
<p>ごめんなさい、発表後バテてたのと翻訳レシーバー持たないまま休んでいたので全然わからなかった…
ただ、どうやら「エディタを変えないと君とは働けない」とメンターの方にいわれたらしく、そんなことあるんだっていうのが印象残った…</p>
<p>内容気になる方はVimConf2019の公式でスライドが公開されているので読んでみてください…</p>
<h3 id="lets-play-with-vanilla-vim-by-hezby-muhammad">Let&rsquo;s Play with Vanilla Vim by [Hezby Muhammad]</h3>
<h4 id="概要-7">概要</h4>
<p>バニラVim（デフォルトのVimのこと）が良いという話</p>
<ul>
<li>写真を取るのが好き、日本に来たのは2回目とのこと</li>
<li>可能な限りhjklを使うようにしている</li>
<li>ノーマルモードはワイの親友（いろんなことができるから）</li>
<li>コマンドラインモードを駆使してテキストを編集する（range指定で削除、コピーしたりする）</li>
<li>モーション（fとtなど）</li>
<li>画面分割を使う</li>
</ul>
<h4 id="所感-7">所感</h4>
<p>セッションの内容は僕も普段良く使っているコマンドの機能だったので、「お、一緒だ」と思ったのが印象に残った。
そしてバニラVimでも十分業務できるんだよなぁとあらためて思った。</p>
<p>プラグインを普段から使っている方は、一度バニラVimまでは行かなくても標準機能を使って業務をやってみると良いかもれません。
Vimってこんなことができたんだっていなるし、新しい発見があると思うので。</p>
<h3 id="13-vim-plugins-i-use-every-day-by-tatsuhiro-ujihisa">13 Vim plugins I use every day by [Tatsuhiro Ujihisa]</h3>
<h4 id="概要所感">概要&amp;所感</h4>
<p>ujihisaさんが普段業務で使っているVimのプラグインたちの紹介とライブコーディングで実際どのように使っているのかを紹介した内容。</p>
<p>何のプラグインを使っているのかあまり覚えていないけど、
ujihisaさんの相変わらず圧倒的なコーディングスピードはやはり見入ってしまう。</p>
<p>このスピードは自分の理想で、ujihisaさんに追いつくのが目標だったりする。</p>
<p>ちなみに、ujihisaさんは普段バンクーバーに住んでいているけど、約半年前までは日本で住んでいて、
ゴリラ。vimの会場を貸してくれたこともあったし、ライブコーディングしてくれたこともあった。</p>
<p>日本にいないのがとても残念だけど、また来年のVimConfでお会いしてコーディングを見たいなぁと思っている。</p>
<h3 id="my-dark-plugins-development-history--over-10-years--by-shougo">My dark plugins development history ~ over 10 years ~ by [Shougo]</h3>
<h4 id="概要-8">概要</h4>
<p>ShogoさんのVim開発の十年間の話。バテたのかあんまりはっきり覚えていないので、雑なメモで…</p>
<ul>
<li>Vimのプラグイン開発の動機は、EmacsのようにすべてをVimで行いたいというのが理由</li>
</ul>
<p><strong>第1世代</strong>
カスタマイズ可能、たくさんの機能があり、linuxのプラグインをエミュレートしている</p>
<p><strong>第2世代</strong>
if_luaを使っている（Vim scriptが遅すぎるから）</p>
<p><strong>第3世代は</strong>
if_ptyhon（channel/jobを使って非同期化した、Vim scriptが遅すぎるから）</p>
<p><strong>第4世代は</strong></p>
<ul>
<li>typeを定義して、バグを検出しやすくした</li>
<li>デフォルトマッピングは必要ない</li>
<li>他のプラグインとコンフリクト（ほかにいろいろあった）</li>
<li>設定変数を取り除いた</li>
<li>denite.nvim v3で破壊的な変更を行った</li>
</ul>
<p>開発スタイルはメモプラグインも使っているが、普段は紙ノートにいろいろ書いているとのこと。</p>
<p>なぜ紙を使うかというとPCいらないからどこでも使えるし自由にかけるからとのこと。</p>
<h4 id="所感-8">所感</h4>
<p>実は今回初めて暗黒美無王こと、Shougoさんに会った。
ゴリラとドラゴンの会合だったんだけど、優しい方だった。</p>
<p>Shougoさんのプラグイン開発に込める熱量と思いは、日本どころか世界一とぼくは思っていて、
どこからそんなに情熱と思いが溢れてくるんだろう？と疑問に思っていたが、少しだけ分かった。</p>
<p>帰りにShougoさんと少し話したが、「プラグイン開発は命を燃やして開発しているようなもの」と言っていた。
自分もなんか分かるって思ったし、たしかに自分も情熱とかを燃やしているなと思った。
情熱がなくなったらある意味、命がなくなったのと同じだなと思った。</p>
<p>Shougoさんなりの信念、そして生き様がそこにあって、それを目の前に話を聞けて話せてとても良かったしうれしかった。
ぼくはそこまでプラグインづくりに情熱を持っているわけではないが、生き様はともて尊敬できるし、あこがれでもある。陰ながら応援しています。</p>
<h2 id="lightning-talk">Lightning Talk</h2>
<h3 id="customer-support-with-vim-by-hiroaki-kadomatsu">Customer support with Vim by [Hiroaki KADOMATSU]</h3>
<h4 id="概要-9">概要</h4>
<p>カスタマーセンターで働いている方によるカスタマーによるVimの使い方の話。</p>
<ul>
<li>お客様からの質問をエディタを使って書いて、完成した文章を返信する</li>
<li>だいたいの流れは↓</li>
</ul>
<ol>
<li>タイムスタンプ</li>
<li>質問をコピーして貼り付ける</li>
<li>vim-easymotionを使って、縦移動している、</li>
<li>画面分割を使っている（回答が長いと質問が見えなくなるから</li>
<li>スニペットで定型文をよく使っている</li>
</ol>
<ul>
<li>Vimはカスタマーサポート向けのエディタ、ものを考えながら書く人にとっては便利なエディタであるとのこと。</li>
</ul>
<h4 id="所感-9">所感</h4>
<p>たしかに高速で文章を編集するための作業に向いているエディタだよなとあらためて思った。
普段Vimはメモ、開発、記事を書くときに使うけど、ビジネスメールでは使ったことがなかった。</p>
<p>中々おもしろい話だったのと、今後自分のメールをVimで書こうかなと思った。</p>
<h3 id="connect-with-many-developers-from-small-plugin-by-lighttiger2505">Connect with many developers from small plugin by [lighttiger2505]</h3>
<h4 id="概要-10">概要</h4>
<p>deoplete.nvimのlsp補完プラグインを作った話。</p>
<ul>
<li>とても小さい、putyon 175 step, Vimスクリプト32 step</li>
<li>少量のコードで高いUXになる理由 =&gt; 難しい実装はほぼdeoplete.nvimとvim-lsp.vimできていたから、あとは2つのプラグインをつなげるだけだから。</li>
<li>Neovim -&gt; deoplete.nvim -&gt; deoplete-vim-lsp -&gt; vim-lsp -&gt; language server</li>
<li>たくさんのVimmerと交流できた</li>
</ul>
<h4 id="所感-10">所感</h4>
<p>前から気になっていてlsp補完のプラグインの話を聞けてよかった。意外とコンパクトなプラグインだなぁという印象だった。
そして、deoplete.nvimとvim-lspが本当によくできているんだなぁと思った。（少ないステップ数で実装できるのがすごい）</p>
<p>ぼくは普段自動補完使わないけど、deoplete.nvimでlspを使ってみたい方は使ってみてはどうでしょうか？</p>
<p>ちなみに、lighttigerさんは何度かゴリラ。vimに参加してくれて、10月ではライブコーディングをしてくれた。
普段他人のVimの使い方をなかなか見れないのでとても勉強になった。</p>
<h3 id="can-we-do-slack-with-vim-by-higashi">Can we do Slack with Vim? by [higashi]</h3>
<h4 id="概要-11">概要</h4>
<p>Vimでslackできるプラグインを作った話</p>
<ul>
<li>普段は沖縄で学生やっている</li>
<li>VimでSlackをするためのプラグインを作った</li>
<li>Slack API、Slack Legacy Token、if_pythonを使って実装していた</li>
<li>Webapi-vimのことを知りVim scriptで実装し直した -&gt; sarahck.vim</li>
<li>ポップアップウィンドウを使ったりしている</li>
<li>問題：パフォーマンスに問題あり（ちょっと遅い、少し待たないといけない）</li>
<li>対応：キャッシュサーバを建ていることで高速化 -&gt; sleachk.vim</li>
<li>Slackの表示はできるが、画像の表示とアクションをつけることができていなけど、今後は作っていきたいと思っている</li>
</ul>
<h4 id="所感-11">所感</h4>
<p>最近の学生はすごいなと思いながらLTを聞いていた。
LTのためにわざわざ沖縄から来て、すごいなと。</p>
<p>ちなみに、以前higashiさんがゴリラ。vimに参加したことがあって、そのときにslackのプラグインを発表されていたけど、そのときおりも進化していた。
キャッシュサーバのアイデアについてはなるほどって思って、そういう手もあるねと勉強になった。</p>
<p>vimでslackしたいのは実はぼくも前から思っていて、作ろうと思ってそこで終わっていた…
これからどんどん進化させていってほしいなと思った。</p>
<p>ちなみに、higashiさんは<a href="https://okinawa-vim.connpass.com/">Okinawa.vim</a>というコミュニティを運営していて、たまにリモートでLTやったりしているので、
興味ある方はぜひ参加してみてください。</p>
<h3 id="time-script-静的型付きvim-script-by-aiya000">Time script 〜静的型付きVim script〜 by [aiya000]</h3>
<h4 id="概要-12">概要</h4>
<p>Vim scriptに強い型つき言語としてTime scriptを作っているという話。</p>
<ul>
<li>作っている理由は静的型付き言語が使いやすいから</li>
<li>Type scriptとの比較をしつつ、Time scriptの紹介をしていた</li>
<li>基本的なsyntaxはType scriptに寄せている様子（個人的な印象）</li>
</ul>
<h4 id="所感-12">所感</h4>
<p>個人的にTime scriptは楽しみにしている
というのも型があると可読性がぐーんと上がるからもっとVim scriptが書きやすくなると見込んでいるから。</p>
<p>実際Time script -&gt; Vim scriptにコンバートするっぽいけど、
ここらへんどうなっているんだっけっていう感じであいまいで記憶がないので、今度本人に聞いてみようと思う。</p>
<p>陰ながら応援しています！</p>
<h3 id="lose-weight-with-vim-and-go-by-micchiebear">Lose Weight with Vim and Go by [micchiebear]</h3>
<h4 id="概要-13">概要</h4>
<p>VimとGoで痩せる話</p>
<ul>
<li>2017からVimを使い始めて、今年で初めてLT</li>
<li>プラグインはNeovimで動作確認ずみ</li>
<li>Goのソースは同じリポジトリ内であった</li>
<li>VimでGoのコマンドを呼び出して、メインの処理をGoに任せている</li>
<li>将来的にはグラフを描画したい</li>
<li>float windowが変なところに出て、業務に支障が出ている</li>
<li>Vimのpopup windowとNeovimのfloat windowの違いを知らなくてドキュメント探しでハマっていたとのこと</li>
</ul>
<h4 id="所感-13">所感</h4>
<p>micchieさんのVimプラグインの話ずっと気になっていたので、内容がわかってスッキリした。
yasetaiという世界的日本語があるのは知らなかったので、へぇっていなった。</p>
<p>ちなみに、micchieさんとはぼくが始めたアキバ。vimというクローズドなコミュニティで一緒にVimを勉強していた方で、
VimConfで一緒にVimの発表をする日が来るとは、とちょっとジーンとしたというのは内緒（笑）</p>
<h3 id="vim-as-a-text-processor-by-うさみけんた">Vim as a text processor by [うさみけんた]</h3>
<h4 id="概要-14">概要</h4>
<p>Vimのバッチモードを使って、Vim scriptでリファクタリングした話。</p>
<ul>
<li>リファクタリングするときに、sedではなくVim scriptを使った</li>
<li>Vim scriptを作るために、実践Vimを読む</li>
<li>バニラVimのセッションで話したようなテクニックを駆使してリファクタリングのスクリプトを作っていた。</li>
<li>Vim scriptを使うことでテキスト編集のスクリプトを作れるし便利</li>
</ul>
<h4 id="所感-14">所感</h4>
<p>Vimのバッチモードまともに使ったことがないので、使い方によってはこういうこともできるんだなぁと実例を聞けてよかった。
今度バッチモードで何かやって記事を書こうかなぁと思った。</p>
<h3 id="vimのリポジトリがgitに移ったときに知られざるはなしのlt-by-koron">VimのリポジトリがGitに移ったときに知られざるはなしのLT by [KoRoN]</h3>
<h4 id="概要-15">概要</h4>
<ul>
<li>VimがGoogle Codeの閉鎖により、GitHubに移行した</li>
<li>GitHubとBitbucketのVim争奪戦があったとのこと</li>
<li>最終的にGitHub</li>
<li>プライベートなメールチェインに巻き込まれた（KoRoNさん）</li>
<li>vimというユーザーがいて、譲ってもらうための交渉があった</li>
<li>vim-jpがmercurial -&gt; Gitへミラーリングを行った</li>
<li>vim-jpがci用のリポジトリを作った</li>
<li>GitHubに移行したことでパッチを書く敷居がめっちゃ低くなった</li>
<li>ぜひパッチをチャンレンジしてみてください</li>
<li>不安ならvim-jp/issuesへ</li>
</ul>
<h4 id="所感-15">所感</h4>
<p>KoRoNさんのVimの歴史系の話は結構好きで、今回もへぇ、そんなことがあったんだって思って、とてもおもしろかった。
欲をいえばもっと話を聞きたかった（笑）</p>
<h4 id="アフターパーティー">アフターパーティー</h4>
<p>VimConfが終わり、アフターパーティールームでみんなで談笑しながら、LTをやったりした。
とてもカジュアルな感じで、たくさんの方と話できてとても良かった。</p>
<p>ちなみに、ぼくはずっとお会いしたかったmattnさんにお会いできて、
握手もできて、懇親会で話もできて、目の前でライブコーディングも見れて、とても満足した。</p>
<p>生mattnさんはslackのときと同様とても優しい方だった。これまでたくさん質問をmattnさんが教えてくれて、
その御礼をずっと言いたくて、それをいえてとても良かった。</p>
<p>mattnさんはぼくにとって、あこがれのエンジニアで目指したい背中、それを目の前で見れてとてもうれしかった。
うれしかった、の一言に尽きる。</p>
<h4 id="hub会">HUB会</h4>
<p>アフターパーティーが終わったあと、HUBで参加者と複数人で飲んでいた。その中にujihisaさんもいた。
いろいろ話をしていた中で、個人的に</p>
<ul>
<li>遊びは本気でやる</li>
<li>仕事は妥協しない</li>
<li>自分で選択すれば基本なんでもできる</li>
</ul>
<p>といったujihisaさんの生き方、そして生き様、考え方にとても感銘を受けた。</p>
<h2 id="全体を通して">全体を通して</h2>
<p>去年のVimConfはぼくがまだVimを始めたてのころで、存在を知らなくて気付くのが遅かったので行けなかった。
けど今年はVimConfにちゃんと行けてしかも発表できて、そこでたくさんのものを得られて最高だった。</p>
<p>このカンファレンスで得られたものを簡潔にまとめると以下になります。</p>
<ul>
<li>情熱（最最ものづくりをたくさんしたい）</li>
<li>モチベ（最もっとたくさん学びたい）</li>
<li>知見（車輪の再利用の話、妥協しないOSSづくりなど）</li>
<li>輪（たくさんのエンジニアと話せて知り合えた）</li>
<li>エンジニアとしての考え方、生き方、矜持（ujihisaさんとか、mattnさんとか、Prabir氏、Justin氏などの話）</li>
</ul>
<p>Vimの国際カンファレンスだけど、Vimだけではなく本当にエンジニアとして、人として大事なことをたくさん学ばせていただきました。
長い間、カンファレンスのために準備してくださった運営の方々、そしてスポンサーをしていただいた企業様、本当にありがとうございました。</p>
<p>そして参加していただいたみなさんもありがとうございました。イベントは主催ではなく、参加者がいて初めて成り立つものです。
ぼくもコミュニティを運営している身として、本当にすごいなと思ったし、とってもありがたかったです。
この恩は、ぼくなりのやり方でVim、ひいてはIT業界全体に返していこうと思っています。</p>
<p>ぼくは来年も登壇を目指しますので、またみなさんにとって利益になるような内容を発表できるように頑張ります！</p>
<p>あらためて、運営も参加者の方もスポンサーの企業様も、みなさんありがとうございました。</p>
]]></content></item><item><title>技術書典7の感想</title><link>https://skanehira.github.io/blog/posts/20191001-gisho7-after/</link><pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20191001-gisho7-after/</guid><description>始めに こんにちは。 ゴリラです。 ちょっと時間が経ってしまいましたが、技術書典7の感想ブログを書きました。 今回はじめて一人で本を書く〜サークル参</description><content type="html"><![CDATA[<h2 id="始めに">始めに</h2>
<p>こんにちは。
ゴリラです。</p>
<p>ちょっと時間が経ってしまいましたが、技術書典7の感想ブログを書きました。
今回はじめて一人で本を書く〜サークル参加しました。
本を出すまでの振り返りも含めて書いていこうと思います。</p>
<h2 id="どんな本を書いたのか">どんな本を書いたのか</h2>
<p>「Vimが好きになる本」を書きました。
全部で132ページのボリュームになっています。</p>
<p>この本の特徴を上げると主に次の通りになります。</p>
<ul>
<li>Vimの基本的な操作から、オペレーター、モーション、テキストオブジェクトなどを使った高速編集のし方について解説</li>
<li>Vimを触ったことがない方でも分かるように解説</li>
<li>プラグインの作り方を実例を交えながら解説</li>
</ul>
<p>現在物理本は販売していなくて、<a href="https://gorilla0513.booth.pm/items/1513974">BOOTH</a>の方で電子版のみを販売しています。
Vimに興味ある方や、もっと高速で編集・コーディングしたいという方がいましたら、<a href="https://gorilla0513.booth.pm/items/1514005">無料版</a>がありますので、まずはそちらを読んでいただければと思います。</p>
<h2 id="本を書いて苦労した点">本を書いて苦労した点</h2>
<p>本を書くにあたり、特に意識したのは「初心者でも分かるように解説」というところです。
本来並ば操作を動画で見せるのが一番わかりやすいのですが、物理本だと動画は無理ですので、
操作前、操作後のカーソルの位置やテキストの変化を次のように、なるべくわかりやすいように意識して書きました。</p>
<p><img src="https://i.gyazo.com/3c76f447b54f439b8a87d069955e1109.png" alt=""></p>
<h2 id="技術書典7の前日">技術書典7の前日</h2>
<p>前日は当日で使用する道具などを100均で購入しました。
また、物理本は1500円で販売予定だったので、みなさんが困らないようにお釣りを用意しようとしました。
そしてあることに気付いたのです。そう、500円硬貨がない。。。
困りました。休日なのでどこの銀行もやっていなくて、Twitterで聞いた換金できる場所も全滅でした。</p>
<p>困り果てたところ、心優しいフォロワーさんが500円硬貨たくさんあるので交換しますよと言ってくださったので、
素直に力を借りることにしました。あらためてお礼を申し上げます。ありがとうございました。</p>
<p>ちゃんと当日のことを考えないとだめだなぁってあらためて思いました。
もし、次の技術書典に本を出したいという方は、お釣りの用意を忘れずに。</p>
<h2 id="技術書典7の当日">技術書典7の当日</h2>
<p>当日は1時間前くらいに会場に着きましたが、当然開場していないので入れなく、近くにいたフォロワーさんと談笑していました。
開場が予定より少し遅れていましたが、おおむね順調だったのではないかと思います。</p>
<p>ちなみに、一人サークルだとトイレも行けないので、事前に知人に売り子をお願いしました。おかげ様で当日は開場内を回ることができ、
知り合いにご挨拶できました。</p>
<p>入場後、自分のサークルスペースがわからず探し回っていました（入り口のすぐ横だったけど…）ことは内緒です。
一派参加者入場までの時間があまりなかったので、隣のサークルさんにご挨拶をして、ぱぱっと準備してあとはドキドキしながら待っていました。</p>
<p>そして入場が開始して、一気に慌ただしくなり始めました。
今回技術書典向けに物理本を144冊（取り置き分を除き）用意しましたが、一時間半ほどで完売しました。
自分でもびっくりしました。なぜなら「Vim」は結構コアのジャンルなのでそんなに売れないと思っていたからです。
それがなんと昼前に完売しました。</p>
<p>とてもありがたいです。自分が2ヵ月間コツコツ書いてきた本、そして本に込めた思いがこんなにもたくさんの人にの手に取ってもらえた。とてもうれしかったです。
あらためて、本を購入していただいたみなさんにお礼を申し上げます。ありがとうございました。</p>
<h2 id="当日を振り返って">当日を振り返って</h2>
<p>さきほど書いたとおり、物理本はすぐ完売しました。そのため物理本がほしいという方に本を渡せませんでした。
技術書典終わったあとでもTwitter上で物理本がないかという連絡をいただき、とても申し訳ない気持ちが強くなっていきました。</p>
<p>いろいろ考えた結果、物理本を再販することにしました。物理本が欲しかったけど、し方なく電子版を買った方もいるので、
そういった方にはBOOTHの購入履歴もしくはダウンロードカードを見せていただければ差分（500円）の額だけで物理本をお渡しすることにしました。
それ以外の方はこれまで通り1500円で販売させていただく予定です。
おそらく次の技術書典（当選すれば）で出すと思います。</p>
<h2 id="最後に">最後に</h2>
<p>はじめて一人で本を書いて、物理本を作ってたくさんの方の手に届けました。
とても良い経験になりました。</p>
<p>「Vimの本を出す」というのは今年の目標のひとつで、それが達成できて一安心です。
そして、実はもうひとつの目標があり、それが「商業本を出す」ことです。</p>
<p>さくらのナレッジでのVimの連載も、技術ブログも、本も、実はすべて「商業本を出す」というゴールのための目標です。
ぼくにとって「出版社で技術本を出す」ことが夢のひとつです。それが技術者としてのアイデンティティでもあり、自分の存在意義でもあるからです。</p>
<p>そして、とてもありがたいことに出版社の方から商業本化の打診をいただきました。
こちらについては進展があったらTwitterで報告する予定ですが、
商業本を出すとなると、さらにパワーアップすることになると思うので、楽しみにしていただければと思います。</p>
]]></content></item><item><title>「Vimが好きになる本」の執筆したお話</title><link>https://skanehira.github.io/blog/posts/20190916-vim-book/</link><pubDate>Mon, 16 Sep 2019 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20190916-vim-book/</guid><description>始めに ウホウホ ウホウホっウホ ウホウホっウホウホウホウホ ウホウホウホウホ「ウホウホっウホ」ウホウホウホウホウホウホウホウホっウホウホっ ウウホウ</description><content type="html"><![CDATA[<h2 id="始めに">始めに</h2>
<p>ウホウホ</p>
<p>ウホウホっウホ</p>
<p>ウホウホっウホウホウホウホ</p>
<p>ウホウホウホウホ「ウホウホっウホ」ウホウホウホウホウホウホウホウホっウホウホっ</p>
<p>ウウホウホウウホホホ</p>
<h2 id="vimが好きになる本とは">「Vimが好きになる本」とは？</h2>
<p>2019/09/22（日）の<a href="https://techbookfest.org/event/tbf07">技術書典7</a>で配布する本です。
タイトル通り、読んだらVimが好きになる本です。</p>
<p>初心者と中級者向けに、Vimの基本操作から、オペレーター、モーション、テキストオブジェクトといった機能を使った高速編集のやり方や、
Vim scriptの入門とプラグインの作り方まで一通り解説した本になります。</p>
<p>現在、BOOTHにて<a href="https://gorilla0513.booth.pm/items/1514005">無料版</a>を公開しています。
ぜひダウンロードして読んでみてください。「無料でもよいから読んでほしい」と思った章をピックアップしています。</p>
<h2 id="なぜ本を執筆しようと思ったのか">なぜ本を執筆しようと思ったのか</h2>
<p>なぜ本を書こうと思ったのか、そこにはいくつか理由があります。</p>
<ul>
<li>本を出すことは自分にとってのあこがれ、そして夢でもある</li>
<li>Vimの良さをもっといろんな人に知ってほしい</li>
<li>今まで学んできたことを腹に落としたい</li>
</ul>
<p>特に「本を出すことは自分にとってのあこがれ、そして夢でもある」は一番の理由です。
ぼくにとって、本を出す = その分野を熟知していると同意義です。</p>
<p>どのような分野でも、熟知していて本を出せるくらいの知見とノウハウを持っている人はすごいし、あこがれます。</p>
<p>そんな思いでVimの本を書きました。</p>
<h2 id="執筆でたいへんだったこと">執筆でたいへんだったこと</h2>
<p>いろいろとたいへんなことはありました。
主なところをあげると</p>
<ul>
<li>ターゲット層とその層に向けの内容の選定</li>
<li>内容の順番をどうするか</li>
<li>執筆の時間をどう確保するか</li>
<li>Vimの動きをどのように表現するか</li>
<li>レビュアーどうするか</li>
</ul>
<p>といったところです。
一部たいへんなところについて考えたことを書いていきます。</p>
<h3 id="ターゲット層とその層に響く内容の選定と順番">ターゲット層とその層に響く内容の選定と順番</h3>
<p>本を書くにあたり、みなさんに絶対読んでほしい部分、つまり幹の部分があります。
それは「オペレーター、モーション、テキストオブジェクト、カウンタ、リピート」の機能を解説した章です。</p>
<p>なぜこれを絶対読んでほしいかと言うと、ぼくがVimにのめり込んだのはこれらことを知ったからです。
それだけ、ぼくにとって魅力的だったのです。なぜVimは慣れたら高速で編集できるのか、その答えがこれら機能だったのです。</p>
<p>ただ、これだけの内容ではとてもじゃないけど、本として出せないし、きっとそれだけ読んでもVimの良さが分からないでしょう。
ですので、幹に肉付けをして、より価値がある本にしなければいけません。</p>
<p>そこで、Vimを始めたばっかりの方でも「Vimってこんなことができたのか」と思える内容、
そして、ある程度Vimを使ってきた方がもう少しだけレベルアップできるような内容にすればよいのでは？と考えました。</p>
<p>これでターゲット層の大枠が決まったので、
次に「初心者」と「ある程度Vimを使ってきた」といったvimmerのレベルの定義を明確にする必要があります。
Vimmerのレベルの公式定義はないので、まず定義をするところから始めなければ行けないのです。</p>
<p>人によって考え方が異なるので、ここは自分の主観で次のように決めました。</p>
<ul>
<li>
<p>Level 1</p>
<ul>
<li>a. Vimの操作がまだ不慣れ、最低限の操作しかできない</li>
</ul>
</li>
<li>
<p>Level 2</p>
<ul>
<li>a. Vimの操作に慣れてきて、基本的な編集が一通りできる</li>
<li>b. Vimの良さを少しずつ理解してきている</li>
</ul>
</li>
<li>
<p>Level 3</p>
<ul>
<li>a. オペレーター、モーション、テキストオブジェクト、カウントを駆使して編集できる</li>
<li>b. 簡単なプラグインを作れる</li>
<li>c. コーディングやメモなどもVimを使っている</li>
</ul>
</li>
<li>
<p>Level 4</p>
<ul>
<li>a. Vimの機能や動作、Vim scriptついて深く知っていて実践できている</li>
</ul>
</li>
<li>
<p>Level 5</p>
<ul>
<li>a. 本体によくパッチを送る</li>
<li>b. 思考スピードで編集できる</li>
</ul>
</li>
</ul>
<p>この定義は正直、大雑把なものではありますが、厳密に定義できないのと、あくまで指標でしかないので、こだわるポイントでもないと思っています。</p>
<p>上記のレベル分けをもとに、初心者（level1）の方には「Vimの基本操作と幹の部分」、
中級者（Level2〜3）の方には「Vimの設定やVim scriptの基本、プラグインの作り方」というように内容にしました。</p>
<h3 id="執筆の時間はどう確保するか">執筆の時間はどう確保するか</h3>
<p>これはもう気合しかないです。</p>
<p>毎月ゴリラ。vimの開催をしたり、連載したり、その合間を縫って使える時間はすべて使いました。
もちろん土日とかも使って書いたりしました。</p>
<p>これに関してはTwitterのTLを見る限り、みんな同じ感じですので、まぁそうだよねと思いました。
特別なことは何もしていなく、ただ気合だけでした。</p>
<h3 id="レビュアーどうするか">レビュアーどうするか</h3>
<p>もちろん本を書いていくと、内容が正しいのか、誤字脱字がないのかといったチェックしてくれる人が必要です。
とってもありがたいことに本書をレビューしていただいたのは<a href="https://twitter.com/mattn_jp">mattnさん</a>と<a href="https://twitter.com/dice_zu">daisuzuさん</a>でした。</p>
<p>mattnさんは<a href="https://gihyo.jp/magazine/SD">Software Desgin</a>で「Vimの細道」の連載をされていたり、Vim本体にパッチを送ったりしている方で、
daisuzuさんはこれまでに数回に渡り<a href="vimconf.org/">Vim Conf</a>で登壇をされたり、Software DesginのVim特集に寄稿した方です。
どちらもvimmerとして頼れる方たちです。</p>
<p>この場を借りてあらためてお礼を申し上げます。
お忙しい中、時間を割いていただきありがとうございました。</p>
<h2 id="執筆を通して感じたこと">執筆を通して感じたこと</h2>
<h3 id="感謝">感謝</h3>
<p>ぼく一人の力では到底本を出すことができませんでした。</p>
<p>レビューに協力していただいたmattnさん、daisuzuさんを始め、
執筆で使用した<a href="https://kauplan.org/reviewstarter/">Re:VIEW Starter</a>を作っていただいた<a href="https://twitter.com/_kauplan">カウプラン</a>さん、
<a href="https://www.nikko-pc.com/index/top.html">日光印刷所</a>の担当者の方、みなさんにはとても感謝しています。ありがとうございます。</p>
<h3 id="たいへん">たいへん</h3>
<p>1冊の本を書いて思ったことは「本を書くのってたいへんだな」でした。
そんなの当たり前じゃんって言われるかもしれないのですが、
ぼくはやりたいことがあったらたいへんさを考えずにとにかくやるという性格ですので、やって初めて身を持って「たいへんさ」を知れたという意味ではとても良い経験になりました。</p>
<h3 id="不安">不安</h3>
<p>今回は物理本を140冊用意したのですが、本当に全部売れるかどうかの不安はあります。
特にVimというマニアックなジャンルですので、母数は他の技術と比べると少ないでしょう。</p>
<p>本を書いたからといって、売れるわけではないので、まず本の存在を知ってもらう必要ための宣伝が必要です。</p>
<p>宣伝という意味ではこのブログ、そして無料版はその役割を担っていますね。</p>
<p>そして一番の宣伝になるのはやはりTwitterです。残念ながらぼくはTwitterでバズる才能はないので、ただただ思ったことをつぶやいてみなさんに拡散していただいています。</p>
<p>リツイート、よいねをくれたみなさん、ありがとうございます。</p>
<p>ありがたいことに取り置きしたいという声をいただいたり、とても良かったという感想をいただいています。とてもうれしく思っています。
それでも不安はありますが、これ以上は考えてもし方がない領域ですので、当日はたくさんの方にこの本を試読していただけるようにがんばります。</p>
<h3 id="開放感">開放感</h3>
<p>当たり前ですが、やるべきことが終わって、ほっとしました。
2ヵ月間ずっとソワソワしていましたが、無事に入稿できてとても気持ちが楽になりました。
あとは当日楽しむだけですね。</p>
<h2 id="ちょっとしたお話">ちょっとしたお話</h2>
<p>ご縁があって、<a href="https://twitter.com/authyasan">Auth屋さん</a>の「<a href="https://twitter.com/authyasan/status/1165951861506990080?s=20">OAuth、OAuth認証、OpenID Connectの違いを整理して理解できる本</a>」と、
カウプランさんの「<a href="https://twitter.com/_kauplan/status/1170371432104116224?s=20">わかりみSQL</a>」のレビューをさせていただきました。</p>
<p>人様の本をレビューしたのはじめてですが、とても勉強になりました。
自分には思いつかなかった様な表現のし方や注力しているポイントなど、たくさん学ぶことができました。</p>
<p>お二人の本は、わかりやすさを重視しているという共通点があって、
全体を通してどちらもとても丁寧でわかりやすかったです。</p>
<p>レビューの指摘、こんなのでよいのかなって不安はありましたが、
おふたりとも、レビューには満足していただいているようで、役に立てよかったと思いました。</p>
<p>今後も余裕があれば本のレビューをやってみようかなと思いました。</p>
<p>タイミングによってはできないこともありますが、もし本をレビューしてほしい方いましたら、ぜひ声をかけていただければと思います。</p>
<h2 id="最後に">最後に</h2>
<p>多くは語りませんので、技術書典当日は「き47D」でお待ちしています。
ぜひ立ち読みしてみてください。</p>
<p>また、来られない方は<a href="https://gorilla0513.booth.pm/items/1513974">こちら</a>（当日公開）でお買い求めいただけますので、
興味ある方はぜひ買ってみてください。</p>
<p>みなさんにVimの良さを伝わることを願っています。</p>
]]></content></item><item><title>Vimのターミナルの真の力お見せしますよ</title><link>https://skanehira.github.io/blog/posts/20190812-vim-terminal/</link><pubDate>Mon, 12 Aug 2019 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20190812-vim-terminal/</guid><description>始めに みなさん、こんにちは 個人ブログにVimの記事しかないゴリラです。 そして今回、またしてもVimです。 Vimの高度な編集を行うことができる</description><content type="html"><![CDATA[<h2 id="始めに">始めに</h2>
<p>みなさん、こんにちは</p>
<p>個人ブログにVimの記事しかない<a href="https://twitter.com/gorilla0513">ゴリラ</a>です。
そして今回、またしてもVimです。</p>
<p>Vimの高度な編集を行うことができる上、ターミナルを操作することもできてしまいます。
エディタでありながら端末でもある、夢のようなエディタです。</p>
<p>そんなVimのターミナル機能について触れている記事をあまり見かけたことがないので、
今回はVimのターミナルの便利な使い方についていくつか紹介していきます。</p>
<h2 id="端末の起動">端末の起動</h2>
<p><code>:term</code>でターミナルを起動できます。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/891c526f-47f4-1f82-dba1-eb56a5d7bffe.png" alt="image.png"></p>
<p>デフォルトでは画面上部にターミナルウィンドウを表示します。
分割方向を変えたい場合は次のようにします。</p>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:vert term</td>
<td>垂直分割して開く</td>
</tr>
<tr>
<td>:bo term</td>
<td>水平分割して画面最下部にウィンドウを開く</td>
</tr>
<tr>
<td>:top term</td>
<td>水平分割して画面最上部にウィンドウを開く</td>
</tr>
</tbody>
</table>
<p>他にもいくつかコマンドがありますので、<code>:h vert</code>でヘルプを引いてそのあたりを参照してください。</p>
<h2 id="ターミナルでの操作">ターミナルでの操作</h2>
<p>ターミナルでは入力したキーはそのまま端末に送られます。
ウィンドウのフォーカスの移動などに関しては特別な操作が必要です。
最低限の操作は次になります。<code>CTRL-W</code>が接頭辞キーになっています。</p>
<table>
<thead>
<tr>
<th>キーマップ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CTRL-W w</td>
<td>次のウィンドウにフォーカスを当てる</td>
</tr>
<tr>
<td>CTRL-W N</td>
<td>ターミナルノーマルモードに移行</td>
</tr>
<tr>
<td>CTRL-W .</td>
<td>端末にCTRL-Wを送る</td>
</tr>
<tr>
<td>CTRL-W :</td>
<td>コマンドラインモードに移行</td>
</tr>
<tr>
<td>CTRL-W &quot; {reg}</td>
<td>レジスタの中身を貼り付ける</td>
</tr>
</tbody>
</table>
<h2 id="端末の内容をヤンク">端末の内容をヤンク</h2>
<p>Vimのターミナルウィンドウで<code>CTRL-W N</code>を押下するとターミナルの出力を一時的に保留します。
この状態をターミナルノーマルモードと言います。このモードは普通のウィンドウと同様カーソル移動、ヤンク、検索を行うことができます。</p>
<p>ただ、<code>i</code>や<code>A</code>などのコマンドは挿入モードではなく、通常のターミナルモードに戻るようになっています。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/b91812b1-6d5e-dd2d-8109-226af23b59f2.gif" alt="vim-terminal-yank.gif"></p>
<p>ターミナルノーマルモードを使用することで、<code>less</code>や<code>tail</code>コマンドの出力、また作業ログを簡単にメモに残すことができます。</p>
<h2 id="外部コマンドとの連携">外部コマンドとの連携</h2>
<p>Vimでは<code>:!echo gorilla</code>というように<code>:!</code>を使用することで外部コマンドを実行できます。しかし、それだとコマンドの実行が完了するまでVimを操作できないです。とてもツライ。</p>
<p>そこでターミナルを使えば非同期で外部コマンドを実行できます。
コマンドを実行している間にVimの操作がブロックされないのはとても大きいですね。
では、いくつか例を紹介します。</p>
<h3 id="git-log">Git log</h3>
<p><code>:vert term ++close git log</code>でGitのログを確認できます。
単にターミナル上で動いているので、いつも通り<code>q</code>で<code>git log</code>を終了できます。
この例だと<code>++close</code>というオプションを私ていますが、これは外部コマンドが終了するとウィンドウを自動で閉じるオプションです。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/fcfaaba5-53b8-9414-cca5-f8fea634481a.gif" alt="vim-terminal-git-log.gif"></p>
<h3 id="git-blame">Git blame</h3>
<p><code>:term ++close git blame %</code>でファイルの変更履歴を確認できます。
<code>%</code>は現在開いているファイル名になります。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/22b3faab-16bc-e035-8d74-066cf13e0639.gif" alt="vim-terminal-git.gif"></p>
<h3 id="インタラクティブにgitを操作">インタラクティブにGitを操作</h3>
<p>Gitコマンドの実行方法を紹介しましたが、Gitをインタラクティブに操作できる<a href="https://github.com/jesseduffield/lazygit">lazygit</a>というTUIツールがあります。
こちらも同様に<code>:vert term ++close lazygit</code>で実行できます。
こちらのツールはとても便利ですので、ぜひ試してみてください。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/a79a7356-ce1d-3d07-427f-44ce78526547.gif" alt="vim-terminal-lazygit.gif"></p>
<h3 id="replを使う">REPLを使う</h3>
<p>コーディング中に言語の細かい動きやちょっとしたサンプルコードの実行をしたいときがあります。
REPL<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>を使用することで、インタラクティブにコードを実行できます。
有名ところだと、<code>PHP -a</code>や<code>node</code>などがあります。</p>
<p>ぼくは普段Goを書いたりするので、<a href="https://github.com/motemen/gore">gore</a>を使っています。
goreの場合、<code>:vert term ++close gore</code>で起動できます。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/f23a0021-2b72-16e1-313a-f1d963b1bde7.gif" alt="vim-terminal-repl.gif"></p>
<h3 id="コンテナを管理">コンテナを管理</h3>
<p>コンテナ技術がインフラを支える様になった昨今、開発も環境もコンテナを使用することが増えていきました。
コーディング中にコンテナを操作したいことがあります。</p>
<p>そこで、ぼくが作った<a href="https://github.com/skanehira/docui">docui</a>というTUIツールを使用することでターミナル上でインタラクティブにコンテナやイメージなどを管理できます。
lazygitと同様<code>:vert term ++close docui</code>でコンテナを操作しつつコーディングできます。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/6f0ce6d8-34d6-3a77-0fc0-a1ff56b5a5aa.gif" alt="vim-terminal-docui.gif"></p>
<p>ちなみに、コンテナを操作するだけなら<a href="https://github.com/skanehira/docker.vim">docker.vim</a>というプラグインがあります。
こちらはターミナルを使わずにVimのインタフェースのみで操作できるようになっています。
興味ある方はぜひ使ってみてください。</p>
<h3 id="スターウォーズ">スターウォーズ</h3>
<p>コーディング中にスターウォーズを見たくなるときがあります。
そんなときは<a href="https://github.com/skanehira/go-starwars">go-starwars</a>を導入して、<code>:term ++close go-starwars -s 20</code>を実行してコーディングしながら見ます。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/14038dad-0b31-603b-9731-97f2b90d202e.gif" alt="vim-terminal-starwars.gif"></p>
<h3 id="tmuxの代わりに使う">tmuxの代わりに使う</h3>
<p><a href="https://github.com/tmux/tmux/wiki">tmux</a>を使うことで、画面を分割したり、ターミナルソフトを終了してもセッションを復帰することで状態を復元できます。
Vimはセッションと言う機能があり、ターミナルと組み合わせることでtmuxと近いことができます。</p>
<p>こちらについては先日に<a href="https://gorilla.netlify.com/articles/20190803-vim-tmux.html">Vimをtmuxの代わりに使う</a>という記事を書いたので、そちらを参照してください。</p>
<h2 id="補足">補足</h2>
<p>本記事で紹介した内容は<a href="https://techbookfest.org/event/tbf07">技術書典7</a>で出す予定の「Vimが好きになる本」の一部です。
<img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/3ddaf388-8cb9-6ad7-39e5-6ffc66c6da6b.png" alt="image.png"></p>
<p>本書はVim初心者から中級者向けにVimの基本機能から便利なコマンドについて解説しています。
現在執筆中のため、一部の目次を紹介します。無料版も有料版もオンラインと会場で配布する予定です。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/9fb8ea31-c5b8-d348-73e8-b15dc5eb4a04.png" alt="image.png">
<img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/c3542225-0302-ea2d-7197-532dd315e0e3.png" alt="image.png"></p>
<h2 id="まとめ">まとめ</h2>
<p>Vimのターミナルは便利です。
そのままターミナルを使うのも良いですが、外部コマンドと連携するのもまた便利です。
つまりVim最高！</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Read-Eval-Print Loopの略、入力・評価・出力のループのこと。 <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></item><item><title>Vimをtmuxの代わりに使う</title><link>https://skanehira.github.io/blog/posts/20190803-vim-tmux/</link><pubDate>Sat, 03 Aug 2019 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20190803-vim-tmux/</guid><description>始めに ぼくは普段開発する時、必ずtmuxとVimを併用しています。tmuxは本当に便利で、画面分割したり、セッションを繰り替えたりながら作業</description><content type="html"><![CDATA[<p><a href="https://asciinema.org/a/260659"><img src="https://asciinema.org/a/260659.svg" alt="asciicast"></a></p>
<h2 id="始めに">始めに</h2>
<p>ぼくは普段開発する時、必ずtmuxとVimを併用しています。tmuxは本当に便利で、画面分割したり、セッションを繰り替えたりながら作業をするのに必須と言ってよいほどです。</p>
<p>しかしVim使いのぼくはやはりVimだけで生活したいので、tmuxをやめてVimだけでtmuxの機能を一部実現してみました。
意外となんとかなったので、そのやり方を解説していきます。</p>
<h2 id="しくみの概要">しくみの概要</h2>
<p>tmuxの画面分割してターミナルを開くのは、Vimの画面分割とターミナルを組み合わせて実現できます。
たとえば<code>:vert terminal ++close bash</code>で縦二分割してターミナルを開くことができます。</p>
<p>tmuxのセッションに関しては、Vimのセッション機能を使用します。
セッションについては<a href="https://gorilla.netlify.com/articles/20190620-vim-session-plugin.html">こちらの記事</a>を参照してください。</p>
<p>ただ、Vimではターミナルウィンドウの位置、サイズを復元できますが、状態までは復元できません。
仕様上どうしてもここは完全代用が難しいので、ここは無理せず使い方でカバーすればよいです。</p>
<h2 id="画面分割">画面分割</h2>
<p><a href="https://asciinema.org/a/260715"><img src="https://asciinema.org/a/260715.svg" alt="asciicast"></a></p>
<p>tmux使用していた時は<code>CTRL-S + \</code>で縦、<code>CTRL-S + -</code>で横で画面分割、<code>CTRL-S + c</code>でタブを開くようにしていました。
Vimでは<code>OpenTermianl</code>コマンドを定義して、そのコマンド内でバッファを作成して、バッファでターミナルを開くようにしています。
コマンドをキーマッピングすれば、tmuxと同じことができます。</p>
<p>ソースは次になります。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="c">&#34; ターミナルを開く</span><span class="err">
</span><span class="err"></span><span class="c">&#34; a:1 new or vnew or tabnew(default is new)</span><span class="err">
</span><span class="err"></span><span class="c">&#34; a:2 path (default is current)</span><span class="err">
</span><span class="err"></span><span class="c">&#34; a:3 shell (default is &amp;shell)</span><span class="err">
</span><span class="err"></span><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">open_terminal</span><span class="p">(</span>...<span class="p">)</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>	<span class="k">let</span> <span class="nx">open_type</span> <span class="p">=</span> <span class="s1">&#39;new&#39;</span><span class="err">
</span><span class="err"></span>	<span class="k">let</span> <span class="nx">shell</span> <span class="p">=</span> &amp;<span class="nx">shell</span><span class="err">
</span><span class="err"></span>	<span class="k">let</span> <span class="nx">path</span> <span class="p">=</span> <span class="nx">getcwd</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="k">if</span> <span class="nx">a</span>:<span class="m">0</span> <span class="p">&gt;</span> <span class="m">0</span> &amp;&amp; <span class="nx">a</span>:<span class="m">0</span> <span class="p">!=</span># <span class="s1">&#39;&#39;</span><span class="err">
</span><span class="err"></span>		<span class="k">let</span> <span class="nx">open_type</span> <span class="p">=</span> <span class="nx">a</span>:<span class="m">1</span><span class="err">
</span><span class="err"></span>	<span class="k">endif</span><span class="err">
</span><span class="err"></span>	<span class="k">if</span> <span class="nx">a</span>:<span class="m">0</span> <span class="p">&gt;</span> <span class="m">1</span> &amp;&amp; <span class="nx">a</span>:<span class="m">2</span> <span class="p">!=</span># <span class="s1">&#39;&#39;</span><span class="err">
</span><span class="err"></span>		<span class="k">let</span> <span class="nx">path</span> <span class="p">=</span> <span class="nx">a</span>:<span class="m">2</span><span class="err">
</span><span class="err"></span>	<span class="k">endif</span><span class="err">
</span><span class="err"></span>	<span class="k">if</span> <span class="nx">a</span>:<span class="m">0</span> <span class="p">&gt;</span> <span class="m">2</span> &amp;&amp; <span class="nx">a</span>:<span class="m">3</span> <span class="p">!=</span># <span class="s1">&#39;&#39;</span><span class="err">
</span><span class="err"></span>		<span class="k">let</span> <span class="nx">shell</span> <span class="p">=</span> <span class="nx">a</span>:<span class="m">3</span><span class="err">
</span><span class="err"></span>	<span class="k">endif</span><span class="err">
</span><span class="err"></span>	<span class="k">if</span> <span class="nx">open_type</span> <span class="p">==</span># <span class="s1">&#39;new&#39;</span><span class="err">
</span><span class="err"></span>		<span class="k">let</span> <span class="nx">open_type</span> <span class="p">=</span> <span class="s1">&#39;bo &#39;</span> .. <span class="nx">open_type</span><span class="err">
</span><span class="err"></span>	<span class="k">endif</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="nx">exe</span> <span class="nx">printf</span><span class="p">(</span><span class="s1">&#39;%s | lcd %s&#39;</span><span class="p">,</span> <span class="nx">open_type</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nx">exe</span> <span class="nx">printf</span><span class="p">(</span><span class="s1">&#39;term ++curwin ++close %s&#39;</span><span class="p">,</span> <span class="nx">shell</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nx">exe</span> <span class="s1">&#39;call term_setrestore(&#34;%&#34;, printf(&#34;++close bash -c \&#34;cd %s &amp;&amp; bash\&#34;&#34;, getcwd()))&#39;</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nx">command</span><span class="p">!</span> <span class="p">-</span><span class="nx">nargs</span><span class="p">=</span>* <span class="nx">OpenTerminal</span> <span class="nx">call</span> <span class="nx">s</span>:<span class="nx">open_terminal</span><span class="p">(&lt;</span><span class="nx">f</span><span class="p">-</span><span class="nx">args</span><span class="p">&gt;)</span><span class="err">
</span><span class="err"></span><span class="c">
</span><span class="c">&#34; ターミナルを開く</span><span class="err">
</span><span class="err"></span><span class="nx">noremap</span> <span class="p">&lt;</span><span class="nx">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nx">C</span><span class="p">-</span><span class="nx">s</span><span class="p">&gt;</span>\ :<span class="nx">OpenTerminal</span> <span class="nx">vnew</span><span class="p">&lt;</span><span class="nx">CR</span><span class="p">&gt;</span><span class="err">
</span><span class="err"></span><span class="nx">noremap</span> <span class="p">&lt;</span><span class="nx">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nx">C</span><span class="p">-</span><span class="nx">s</span><span class="p">&gt;-</span> :<span class="nx">OpenTerminal</span><span class="p">&lt;</span><span class="nx">CR</span><span class="p">&gt;</span><span class="err">
</span><span class="err"></span><span class="nx">noremap</span> <span class="p">&lt;</span><span class="nx">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nx">C</span><span class="p">-</span><span class="nx">s</span><span class="p">&gt;</span>^ :<span class="nx">OpenTerminal</span> <span class="nx">tabnew</span><span class="p">&lt;</span><span class="nx">CR</span><span class="p">&gt;</span><span class="err">
</span><span class="err"></span><span class="nx">tnoremap</span> <span class="p">&lt;</span><span class="nx">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nx">C</span><span class="p">-</span><span class="nx">s</span><span class="p">&gt;</span>\ <span class="p">&lt;</span><span class="nx">C</span><span class="p">-</span><span class="nx">w</span><span class="p">&gt;</span>:<span class="nx">OpenTerminal</span> <span class="nx">vnew</span><span class="p">&lt;</span><span class="nx">CR</span><span class="p">&gt;</span><span class="err">
</span><span class="err"></span><span class="nx">tnoremap</span> <span class="p">&lt;</span><span class="nx">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nx">C</span><span class="p">-</span><span class="nx">s</span><span class="p">&gt;-</span> <span class="p">&lt;</span><span class="nx">C</span><span class="p">-</span><span class="nx">w</span><span class="p">&gt;</span>:<span class="nx">OpenTerminal</span><span class="p">&lt;</span><span class="nx">CR</span><span class="p">&gt;</span><span class="err">
</span><span class="err"></span><span class="nx">tnoremap</span> <span class="p">&lt;</span><span class="nx">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nx">C</span><span class="p">-</span><span class="nx">s</span><span class="p">&gt;</span>^ <span class="p">&lt;</span><span class="nx">C</span><span class="p">-</span><span class="nx">w</span><span class="p">&gt;</span>:<span class="nx">OpenTerminal</span> <span class="nx">tabnew</span><span class="p">&lt;</span><span class="nx">CR</span><span class="p">&gt;</span><span class="err">
</span></code></pre></div><p><code>noremap</code>はノーマルモード、<code>tnoremap</code>はターミナルで動作するマッピングです。</p>
<p>ターミナルのオプションですが、<code>++close</code>はターミナルを終了する時にバッファを閉じる、<code>++curwin</code>は現在のバッファでターミナルを開くという動きになります。</p>
<p>ターミナルを開いた後に実行している<code>term_setrestore</code>はかなり重要で、これはセッションでターミナルを復元する時に実行するコマンドです。</p>
<p>デフォルト、ターミナルを復元する時はカレントディレクトリになってしまいます。
ですので、セッション保存時のディレクトリで復元するように設定する必要があります。</p>
<p>上記のコードを<code>vimrc</code>に追記すれば、そのまま動くはずです。</p>
<h2 id="セッション保存復元">セッション保存/復元</h2>
<p>セッション機能を使用することで、画面の状態をそのまま保持できます。
ですので、基本的セッションを保存、起動時or起動後にセッションを読み込むことで復元できます。</p>
<p>しかし、セッションを使う上でいくつか注意する必要があります。</p>
<ul>
<li>
<p>なるべくプレーンの状態でセッションを復元する<br>
だいたい復元するタイミングはVimを再起動した後だと思うので、それほど意識する必要はないですが、
たとえばターミナルを開いた状態でセッションを復元しようとするとエラーが出ます。
ですので、基本的に起動後にセッションを読み込むようにします。</p>
</li>
<li>
<p>セッションを保存する時のオプションに<code>globals</code>を外す<br>
セッションの保存対象を設定する <code>sessionoptions</code>というオプションがありますが、
デフォルではフローバル変数を復元します。それだとvimrcの一部の設定などが復元してしまいます。
保存時のvimrcの状態を戻すよりも、最新vimrcを適用したいケースが多いので、ここではオプションから外します。</p>
</li>
</ul>
<p>ちなみに、ぼくの設定は次になっています。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="nx">set</span> <span class="nx">sessionoptions</span><span class="p">=</span><span class="nx">blank</span><span class="p">,</span><span class="nx">buffers</span><span class="p">,</span><span class="nx">curdir</span><span class="p">,</span><span class="nx">folds</span><span class="p">,</span><span class="nx">help</span><span class="p">,</span><span class="nx">tabpages</span><span class="p">,</span><span class="nx">winsize</span><span class="p">,</span><span class="nx">terminal</span><span class="err">
</span></code></pre></div><h2 id="タブページの移動">タブページの移動</h2>
<p>Vimのタブをプロジェクトごとで分けて使うため、タブ移動＝プロジェクト移動にしています。
デフォルト<code>gt</code>と<code>gT</code>でタブを切り替えられますが、個人的に使いづらいので、次のようにしています。</p>
<p>このキーマップはtmuxの設定と同じにしています。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="nx">nnoremap</span> <span class="p">&lt;</span><span class="nx">C</span><span class="p">-</span><span class="nx">s</span><span class="p">&gt;</span><span class="nx">n</span> <span class="nx">gt</span><span class="err">
</span><span class="err"></span><span class="nx">nnoremap</span> <span class="p">&lt;</span><span class="nx">C</span><span class="p">-</span><span class="nx">s</span><span class="p">&gt;</span><span class="nx">p</span> <span class="nx">gT</span><span class="err">
</span><span class="err"></span><span class="nx">tnoremap</span> <span class="p">&lt;</span><span class="nx">C</span><span class="p">-</span><span class="nx">s</span><span class="p">&gt;</span><span class="nx">p</span> <span class="p">&lt;</span><span class="nx">C</span><span class="p">-</span><span class="nx">w</span><span class="p">&gt;</span>:<span class="nx">tabprevious</span><span class="p">&lt;</span><span class="nx">CR</span><span class="p">&gt;</span><span class="err">
</span><span class="err"></span><span class="nx">tnoremap</span> <span class="p">&lt;</span><span class="nx">C</span><span class="p">-</span><span class="nx">s</span><span class="p">&gt;</span><span class="nx">n</span> <span class="p">&lt;</span><span class="nx">C</span><span class="p">-</span><span class="nx">w</span><span class="p">&gt;</span>:<span class="nx">tabnext</span><span class="p">&lt;</span><span class="nx">CR</span><span class="p">&gt;</span><span class="err">
</span></code></pre></div><h2 id="ghqとfzfvimとと組み合わせる">ghqとfzf.vimとと組み合わせる</h2>
<h3 id="リポジトリを開く">リポジトリを開く</h3>
<p><a href="https://asciinema.org/a/260717"><img src="https://asciinema.org/a/260717.svg" alt="asciicast"></a>:</p>
<p>基本的にVimを開くときは何かしらプロジェクトに移動して作業する時ですので、
<a href="https://github.com/motemen/ghq">ghq</a>と<a href="https://github.com/junegunn/fzf.vim">fzf.vim</a>を組み合わせてプロジェクトに簡単に移動した後にターミナルを開く<code>Repo</code>コマンドを用意しました。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">cd_repo</span><span class="p">(</span><span class="nx">shell</span><span class="p">,</span> <span class="nx">repo</span><span class="p">)</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>	<span class="nx">exe</span> <span class="s1">&#39;lcd&#39;</span> <span class="nx">trim</span><span class="p">(</span><span class="nx">system</span><span class="p">(</span><span class="s1">&#39;ghq root&#39;</span><span class="p">))</span> .. <span class="s1">&#39;/&#39;</span> .. <span class="nx">a</span>:<span class="nx">repo</span><span class="err">
</span><span class="err"></span>	<span class="nx">call</span> <span class="nx">s</span>:<span class="nx">open_terminal</span><span class="p">(</span><span class="s1">&#39;new&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="nx">a</span>:<span class="nx">shell</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nx">exe</span> <span class="s1">&#39;wincmd k&#39;</span><span class="err">
</span><span class="err"></span>	<span class="nx">pwd</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">repo</span><span class="p">(</span><span class="nx">multi</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>	<span class="k">if</span> <span class="nx">executable</span><span class="p">(</span><span class="s1">&#39;ghq&#39;</span><span class="p">)</span> &amp;&amp; <span class="nx">exists</span><span class="p">(</span><span class="s1">&#39;*fzf#run()&#39;</span><span class="p">)</span> &amp;&amp; <span class="nx">executable</span><span class="p">(</span><span class="s1">&#39;fzf&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nx">call</span> <span class="nx">fzf</span>#<span class="nx">run</span><span class="p">(</span>{<span class="err">
</span><span class="err"></span>					\ <span class="s1">&#39;source&#39;</span>: <span class="nx">systemlist</span><span class="p">(</span><span class="s1">&#39;ghq list&#39;</span><span class="p">),</span><span class="err">
</span><span class="err"></span>					\ <span class="s1">&#39;sink&#39;</span>: <span class="nx">a</span>:<span class="nx">cb</span><span class="p">,</span><span class="err">
</span><span class="err"></span>					\ <span class="s1">&#39;options&#39;</span>: <span class="nx">a</span>:<span class="nx">multi</span><span class="p">,</span><span class="err">
</span><span class="err"></span>					\ <span class="s1">&#39;down&#39;</span>: <span class="s1">&#39;40%&#39;</span>}<span class="p">,</span><span class="err">
</span><span class="err"></span>					\ <span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="k">else</span><span class="err">
</span><span class="err"></span>		<span class="nx">echo</span> <span class="s2">&#34;doesn&#39;t installed ghq or fzf.vim(require fzf)&#34;</span><span class="err">
</span><span class="err"></span>	<span class="k">endif</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nx">command</span><span class="p">!</span> <span class="nx">Repo</span> <span class="nx">call</span> <span class="nx">s</span>:<span class="nx">repo</span><span class="p">(</span><span class="s1">&#39;+m&#39;</span><span class="p">,</span> <span class="k">function</span><span class="p">(</span><span class="s1">&#39;s:cd_repo&#39;</span><span class="p">,</span> [&amp;<span class="nx">shell</span>]<span class="p">))</span><span class="err">
</span></code></pre></div><p><code>ghq list</code>でリポジトリ一覧を取得して、<code>fzf.vim</code>であいまい検索できるようにしています。</p>
<h3 id="リポジトリを複数開く">リポジトリを複数開く</h3>
<p><a href="https://asciinema.org/a/260719"><img src="https://asciinema.org/a/260719.svg" alt="asciicast"></a></p>
<p>ときに複数のプロジェクトを同時に開きたいことがあります。
何度も<code>:Repo</code>を実行しても良いですが、面倒です。
ですので、<code>NewTab</code>コマンドというのを用意しました。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">open_tabs</span><span class="p">(</span><span class="nx">shell</span><span class="p">,</span> <span class="nx">repo</span><span class="p">)</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>	<span class="nx">exe</span> <span class="nx">printf</span><span class="p">(</span><span class="s1">&#39;tabnew | lcd %s/%s&#39;</span><span class="p">,</span> <span class="nx">trim</span><span class="p">(</span><span class="nx">system</span><span class="p">(</span><span class="s1">&#39;ghq root&#39;</span><span class="p">)),</span> <span class="nx">a</span>:<span class="nx">repo</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nx">exe</span> <span class="nx">printf</span><span class="p">(</span><span class="s1">&#39;bo term ++rows=20 ++close %s&#39;</span><span class="p">,</span> <span class="nx">a</span>:<span class="nx">shell</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nx">exe</span> <span class="s1">&#39;call term_setrestore(&#34;%&#34;, printf(&#34;++close bash -c \&#34;cd %s &amp;&amp; bash\&#34;&#34;, getcwd()))&#39;</span><span class="err">
</span><span class="err"></span>	<span class="nx">exe</span> <span class="s1">&#39;wincmd k&#39;</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nx">command</span><span class="p">!</span> <span class="nx">NewTab</span> <span class="nx">call</span> <span class="nx">s</span>:<span class="nx">repo</span><span class="p">(</span><span class="s1">&#39;-m&#39;</span><span class="p">,</span> <span class="k">function</span><span class="p">(</span><span class="s1">&#39;s:open_tabs&#39;</span><span class="p">,</span> [&amp;<span class="nx">shell</span>]<span class="p">))</span><span class="err">
</span></code></pre></div><p><code>fzf.vim</code>は<code>-m</code>オプション使うと複数の項目を選択できるので、それを使用します。
ここで1点注意ですが<code>fzf.vim</code>のcallbackでは<code>&amp;shell</code>が<code>sh</code>になってしまうので、呼び出し元の<code>shell</code>を渡す必要があります。</p>
<h2 id="残作業">残作業</h2>
<h3 id="タブのラベル">タブのラベル</h3>
<p>タブのラベルを自由に決めれるようにしたいのです、ラベルのしくみが思ったよりもややこしく途中で諦めました。
ラベルを簡単に変えれれば一番良いですが、なくてもそこまで問題ないです。</p>
<h3 id="画面最大化のトグル">画面最大化のトグル</h3>
<p>tmuxでは<code>prefix+z</code>で画面の最大化のトグルができます。Vimでもそれをやろうと思えば実現はできると思いますが、まだ試せていないです。
ターミナルがある状態で<code>&lt;C-w&gt;o</code>でターミナルが残るので、その問題が解決できればという感じです。</p>
<h2 id="まとめ">まとめ</h2>
<p>ターミナルとセッションの機能で、なんとかtmuxっぽいことはできました。
今の所それほど困ってはいないのですが、やはりtmuxはすごいなとあらためて思いました。</p>
<p>ただ、Vimだけでもここまできるこを知れたので大きいですね。
興味ある方はぜひvimrcに追加して試してみてください。</p>
]]></content></item><item><title>VimでBad Apple!!</title><link>https://skanehira.github.io/blog/posts/20190721-vim-bad-apple/</link><pubDate>Sun, 21 Jul 2019 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20190721-vim-bad-apple/</guid><description>こんにちは。 ゴリラ.vimを運営しているゴリラです。 最近Vimのプラグインを作るのにハマっています。先日もdocker.vimというVimか</description><content type="html"><![CDATA[<p>こんにちは。
<a href="https://gorillavim.connpass.com/">ゴリラ.vim</a>を運営している<a href="https://twitter.com/gorilla0513">ゴリラ</a>です。</p>
<p>最近Vimのプラグインを作るのにハマっています。先日も<a href="https://qiita.com/gorilla0513/items/1c756fd3aba8e68b9575">docker.vim</a>というVimからdockerコンテナを操作するプラグインを作りました。
良かった試してみてください。</p>
<p>さて、本題ですがみなさんは<code>Bad Apple!!</code>をご存じでしょうか？
多分ニコニコユーザーならほぼ知っているのではないかと思います。
そうです。かの有名な動画です。</p>
<p>その動画のAscii版があり、それならVimで再生できるのでは？と思い帰りの電車の中で作ってみました。</p>
<p><a href="https://github.com/skanehira/badapple.vim"><img src="https://github-link-card.s3.ap-northeast-1.amazonaws.com/skanehira/badapple.vim.png" width="460px"></a></p>
<h1 id="どんな感じ">どんな感じ？</h1>
<p>こんな感じです。
少しちらつきますが、まぁ見れなくはないかなと言った感じです。</p>
<p><img src="https://github.com/skanehira/badapple.vim/raw/master/screenshots/screenshot.gif?raw=true" alt=""></p>
<h1 id="しくみは">しくみは？</h1>
<p>とっても簡単です。簡潔に言うとテキストファイルを読み込み、フレーム分のテキストを配列に格納して、あとはfor分で回して画面に描写します。</p>
<p>もう少し細かく解説します。</p>
<h2 id="asciiテキストファイルの読み込み">Asciiテキストファイルの読み込み</h2>
<p>Bad Apple!のAsciiテキストファイルは<a href="https://github.com/Chion82/ASCII_bad_apple">こちら</a>にあるので、それを借用しました。</p>
<details>
<summary>テキストファイル</summary>
```
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$SPLIT$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$SPLIT$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
```
</details>
<p>見て分かる通り、<code>SPLIT</code>で区切っています。ですので、<code>SPLIT</code>までを1フレームとしてます。
処理は次になります。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="c">&#34; read file to create frames</span><span class="err">
</span><span class="err"></span><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">read_file</span><span class="p">()</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>    <span class="k">let</span> <span class="nx">file</span> <span class="p">=</span> <span class="nx">globpath</span><span class="p">(</span>&amp;<span class="nx">rtp</span><span class="p">,</span> <span class="s1">&#39;resources/badapple.txt&#39;</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="c">	&#34; 全frameを格納</span><span class="err">
</span><span class="err"></span>    <span class="k">let</span> <span class="nx">frames</span> <span class="p">=</span> []<span class="err">
</span><span class="err"></span><span class="c">	&#34; 1frame分のテキストを格納</span><span class="err">
</span><span class="err"></span>    <span class="k">let</span> <span class="nx">frame</span> <span class="p">=</span> []<span class="err">
</span><span class="err">
</span><span class="err"></span>    <span class="nx">for</span> <span class="nx">line</span> <span class="nx">in</span> <span class="nx">readfile</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="c">		&#34; 現在行に`SPLIT`が含まれていなければframeに追加</span><span class="err">
</span><span class="err"></span>        <span class="k">if</span> <span class="nx">line</span> <span class="p">!~</span># <span class="s2">&#34;SPLIT&#34;</span><span class="err">
</span><span class="err"></span>            <span class="nx">call</span> <span class="nx">add</span><span class="p">(</span><span class="nx">frame</span><span class="p">,</span> <span class="nx">line</span><span class="p">)</span><span class="err">
</span><span class="err"></span>        <span class="k">else</span><span class="err">
</span><span class="err"></span><span class="c">			&#34; frameをframes追加</span><span class="err">
</span><span class="err"></span>            <span class="nx">call</span> <span class="nx">add</span><span class="p">(</span><span class="nx">frames</span><span class="p">,</span> <span class="nx">frame</span><span class="p">)</span><span class="err">
</span><span class="err"></span>            <span class="k">let</span> <span class="nx">frame</span> <span class="p">=</span> []<span class="err">
</span><span class="err"></span>        <span class="k">endif</span><span class="err">
</span><span class="err"></span>    <span class="nx">endfor</span><span class="err">
</span><span class="err">
</span><span class="err"></span>    <span class="nx">return</span> <span class="nx">frames</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span></code></pre></div><p>なぜframeを配列にしているかというと、vimではバッファにテキストを書き込む<code>setline()</code>とpopup windowのバッファに書き込む<code>popup_settext()</code>という関数がありますが、
引数に配列を渡すと配列の1要素が1行として画面に出力します。そうすることで改行文字をわざわざ追加しなくて済むのでコードがスッキリします。</p>
<h2 id="画面に出力する">画面に出力する</h2>
<p>フレームを作る関数を用意したので、それを使用してフレーム情報を変数に格納し、forで1frameずつ画面に出力します。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="nx">for</span> <span class="nx">frame</span> <span class="nx">in</span> <span class="nx">frames</span><span class="err">
</span><span class="err"></span><span class="c">	&#34; ここで画面にframeを出力する</span><span class="err">
</span><span class="err"></span>	<span class="nx">call</span> <span class="nx">popup_settext</span><span class="p">(</span><span class="nx">winid</span><span class="p">,</span> <span class="nx">frame</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="c">	&#34; redraw!で画面を再描写する&#34;</span><span class="err">
</span><span class="err"></span>	<span class="nx">redraw</span><span class="p">!</span><span class="err">
</span><span class="err"></span><span class="c">	&#34; 一瞬で出力が終わってしまうので少し待つ</span><span class="err">
</span><span class="err"></span>	<span class="nx">sleep</span> <span class="m">50</span>ms<span class="err">
</span><span class="err"></span><span class="c">	&#34; qで終了できるように`getchar()`で入力した文字を取得</span><span class="err">
</span><span class="err"></span><span class="c">	&#34; キー入力を待たないように、引数に`0`を渡す</span><span class="err">
</span><span class="err"></span>	<span class="k">let</span> <span class="nx">key</span> <span class="p">=</span> <span class="nx">getchar</span><span class="p">(</span><span class="m">0</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="k">if</span> <span class="nx">key</span> <span class="p">==</span># <span class="m">113</span><span class="err">
</span><span class="err"></span>		<span class="nx">break</span><span class="err">
</span><span class="err"></span>	<span class="k">endif</span><span class="err">
</span><span class="err"></span><span class="nx">endfor</span><span class="err">
</span><span class="err"></span><span class="c">&#34; for分を抜けたらウィンドウを閉じる&#34;</span><span class="err">
</span><span class="err"></span><span class="nx">call</span> <span class="nx">popup_close</span><span class="p">(</span><span class="nx">winid</span><span class="p">)</span><span class="err">
</span></code></pre></div><h2 id="まとめ">まとめ</h2>
<p>動画をAsciiテキストに変換して、フレームを定義すれば、どんなものでも同じようなロジックでVim再生できます。
興味ある方はぜひチャレンジしてみてください。</p>
]]></content></item><item><title>Vimのセッション管理プラグイン</title><link>https://skanehira.github.io/blog/posts/20190620-vim-session-plugin/</link><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20190620-vim-session-plugin/</guid><description>こんにちは。 ゴリラ.vimを運営しているゴリラです。 Vimを始めたてのころにこちらの記事でセッション管理プラグインを作りましたが、最近Vim</description><content type="html"><![CDATA[<p>こんにちは。
<a href="https://gorillavim.connpass.com/">ゴリラ.vim</a>を運営しているゴリラです。</p>
<p>Vimを始めたてのころに<a href="https://gorilla.netlify.com/articles/20181215-vim-session.html">こちらの記事</a>で<a href="https://github.com/skanehira/vsession">セッション管理プラグイン</a>を作りましたが、最近Vimにポップアップウィンドウが入ったのでその機能を使ってアップデートしてみました。</p>
<h2 id="セッションとは">セッションとは</h2>
<p>Vimの日本語マニュアルより引用</p>
<blockquote>
<p>セッションとは、全てのウィンドウのビューとグローバルな設定のことである。セッ
ションを保存しておいて、あとからそれを復元することで、各ウィンドウのレイアウト
を元に戻すことができる。</p>
</blockquote>
<p>つまりセッションを保存すれば開いているファイル、ウィンドウのサイズ、vimrcの設定などがそのまま復元<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>できます。かなり強力な機能です。</p>
<h2 id="セッションの基本">セッションの基本</h2>
<ul>
<li>
<p>セッションの保存<br>
<code>:mksession {filename}</code></p>
</li>
<li>
<p>セッションの復元<br>
<code>:s {filename}</code> or <code>vim -S {filename}</code></p>
</li>
</ul>
<p>これだけです、とても簡単です。</p>
<h2 id="セッション管理プラグイン">セッション管理プラグイン</h2>
<p>vsessionの使い方はREADMEを読んでいただければと思います。
今回は保存したセッションを読み込むときにポップアップウィンドウで選べるようにしました。</p>
<p><img src="https://github.com/skanehira/vsession/blob/master/screenshots/vsession.gif?raw=true" alt=""></p>
<p>しくみとしては簡単で、vsessionはデフォルト<code>~/.vim/sessions</code>配下にセッションファイルを保存する様になっています。
ディレクトリ配下のファイル一覧を<code>readdir</code> 組込み数で取得してそれをポップアップウィンドウに渡します。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="c">&#34; [&#39;blog&#39;, &#39;docker.vim&#39;]</span><span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">l</span>:<span class="nx">sessions</span> <span class="p">=</span> <span class="nx">readdir</span><span class="p">(</span><span class="nx">g</span>:<span class="nx">session_path</span><span class="p">)</span><span class="err">
</span></code></pre></div><p>ポップアップウィンドウを作成に関しては簡易ではあるが<a href="https://gorilla.netlify.com/articles/20190605-vim-popup-window.html">こちらの記事</a>を書いたので軽く読んでおくと理解しやすいかもしれないです。
<code>filter</code>オプションに<code>popup_filter_menu</code>コールバックを指定するとメニュー選択画面を作成できます。では選択したアイテムをどう特定するかというと<code>callback</code>オプションを使います。
こちらはウィンドウが閉じられたときに呼ばれるコールバックを指定します。<code>popup_filter_menu</code>を使用した場合、コールバック関数の第2引数に選択したメニューのインデックス（1番目か2番目か。..）が渡ってくるのでそれを利用します。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">let</span> <span class="nx">s</span>:<span class="nx">result</span> <span class="p">=</span> [<span class="s2">&#34;banana&#34;</span><span class="p">,</span> <span class="s2">&#34;apple&#34;</span><span class="p">,</span> <span class="s2">&#34;gorilla&#34;</span>]<span class="err">
</span><span class="err"></span><span class="c">
</span><span class="c">&#34; popup_filter_menuではxで画面を閉じ、idxが-1で渡ってくるので</span><span class="err">
</span><span class="err"></span><span class="c">&#34; -1の場合は何もしない</span><span class="err">
</span><span class="err"></span><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">cb</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">idx</span><span class="p">)</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>    <span class="k">if</span> <span class="nx">a</span>:<span class="nx">idx</span> <span class="p">!=</span># <span class="m">-1</span><span class="err">
</span><span class="err"></span>        <span class="nx">return</span><span class="err">
</span><span class="err"></span>    <span class="k">endif</span><span class="err">
</span><span class="err"></span>    <span class="nx">echo</span> <span class="nx">s</span>:<span class="nx">result</span>[<span class="nx">a</span>:<span class="nx">idx</span><span class="m">-1</span>]<span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span><span class="err"></span><span class="c">
</span><span class="c">&#34; popup_filter_menuを使用する場合</span><span class="err">
</span><span class="err"></span><span class="c">&#34; enter でウィンドウを閉じ選択したメニューのインデックスとウィンドウIDをcallbackで指定した関数にわたす</span><span class="err">
</span><span class="err"></span><span class="nx">call</span> <span class="nx">popup_create</span><span class="p">(</span><span class="nx">s</span>:<span class="nx">result</span><span class="p">,</span> {<span class="err">
</span><span class="err"></span>            \ <span class="s2">&#34;filter&#34;</span>: <span class="s2">&#34;popup_filter_menu&#34;</span><span class="p">,</span><span class="err">
</span><span class="err"></span>            \ <span class="s2">&#34;callback&#34;</span>: <span class="k">function</span><span class="p">(</span><span class="s2">&#34;s:cb&#34;</span><span class="p">),</span><span class="err">
</span><span class="err"></span>            \ <span class="s1">&#39;borderchars&#39;</span>: [<span class="s1">&#39;-&#39;</span><span class="p">,</span><span class="s1">&#39;|&#39;</span><span class="p">,</span><span class="s1">&#39;-&#39;</span><span class="p">,</span><span class="s1">&#39;|&#39;</span><span class="p">,</span><span class="s1">&#39;+&#39;</span><span class="p">,</span><span class="s1">&#39;+&#39;</span><span class="p">,</span><span class="s1">&#39;+&#39;</span><span class="p">,</span><span class="s1">&#39;+&#39;</span>]<span class="p">,</span><span class="err">
</span><span class="err"></span>            \ }<span class="p">)</span><span class="err">
</span></code></pre></div><p>基本なロジックは上記通りで、選択したファイルを取得し<code>source</code>で読み込むことでセッションを復元しています。</p>
<h2 id="最後に">最後に</h2>
<p>セッションは便利ですね。ぜひプラグイン使ってみてください。
ポップアップウィンドウを駆使すれば<code>filter</code>と<code>callback</code>でカレントディレクトリのファイルをポップアップウィンドウで表示し選択して開くこともできます。
興味ある方はぜひチャレンジしてみてください。</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>ターミナルは状態を保存できない <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></item><item><title>Vimにポップアップウィンドウが入りました</title><link>https://skanehira.github.io/blog/posts/20190605-vim-popup-window/</link><pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20190605-vim-popup-window/</guid><description>こんにちは。 ゴリラ.vimを運営しているゴリラです。 Vim 8.1.1391でポップアップウィンドウという機能が入りました。 これは名前の通り、ポッ</description><content type="html"><![CDATA[<p>こんにちは。
<a href="https://gorillavim.connpass.com/">ゴリラ.vim</a>を運営している<a href="https://twitter.com/gorilla0513">ゴリラ</a>です。</p>
<p>Vim 8.1.1391でポップアップウィンドウという機能が入りました。
これは名前の通り、ポップアップウィンドウを出すという機能です。</p>
<p>現在も実装が進められていてまだ完成ではないのですが、良い感じになってきたので紹介していこうと思います。</p>
<h1 id="どんな感じか">どんな感じか？</h1>
<p>こんな感じでポップアップウィンドウを出せます。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/e1f307ce-d56a-1fa5-fbc7-11768c32e22e.gif" alt="popup.gif"></p>
<p>こちらはゴリラ製翻訳プラグインです。
<a href="https://github.com/skanehira/translate.vim"><img src="https://github-link-card.s3.ap-northeast-1.amazonaws.com/skanehira/translate.vim.png" width="460px"></a></p>
<p>翻訳結果をポップアップウィンドウに表示し、カーソルを動かしたら自動で閉じる様になっています。
わざわざバッファを作成して表示しなくて済むのはめちゃくちゃ便利です。</p>
<h1 id="ポップアップウィンドウの作り方">ポップアップウィンドウの作り方</h1>
<p>とっても簡単です。
これだけで作れます。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="k">let</span> <span class="nx">winid</span> <span class="p">=</span> <span class="nx">popup_create</span><span class="p">(</span><span class="s2">&#34;hello gorilla&#34;</span><span class="p">,</span> {}<span class="p">)</span><span class="err">
</span></code></pre></div><p>第一引数は文字列、文字列の配列を渡します。
第二引数はポップアップウィンドウのオプションになります。</p>
<p>ポップアップウィンドウを閉じるには<code>popup_clear()</code>か<code>popup_close(winid)</code>で閉じれます。</p>
<h2 id="オプション">オプション</h2>
<p>詳しくはヘルプを引いていただいたほうがわかりやすいので、ここでは軽く紹介します。</p>
<table>
<thead>
<tr>
<th style="text-align:left">オプション</th>
<th style="text-align:left">設定値</th>
<th style="text-align:left">説明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">LINE</td>
<td style="text-align:left">1, &ldquo;corsor+1&rdquo;</td>
<td style="text-align:left">ポップアップの位置（横）,&ldquo;corsor+1&quot;だと現在のカーソルから1セル下になります</td>
</tr>
<tr>
<td style="text-align:left">col</td>
<td style="text-align:left">1,&ldquo;cursor+1&rdquo;</td>
<td style="text-align:left">ポップアップの位置（縦）、&ldquo;cursor+1&quot;だと現在のカーソルから1セル横になります</td>
</tr>
<tr>
<td style="text-align:left">border</td>
<td style="text-align:left">[1,1,1,1]</td>
<td style="text-align:left">ポップアップをボーダーで囲う、数値はボーダーの太さになります</td>
</tr>
<tr>
<td style="text-align:left">moved</td>
<td style="text-align:left">&ldquo;any&rdquo;,&ldquo;word&rdquo;</td>
<td style="text-align:left">カーソルを動かしたときに自動で閉じるときに使用します</td>
</tr>
<tr>
<td style="text-align:left">filter</td>
<td style="text-align:left">function（&lsquo;filter_func&rsquo;）</td>
<td style="text-align:left">ポップアップウィンドウが表示されている間にキーを取得するためのコールバック、特定キーが押されたら閉じるといった処理をしたいときに指定します</td>
</tr>
</tbody>
</table>
<h1 id="最後に">最後に</h1>
<p>ポップアップウィンドウは現在も絶賛実装中でまだまだ良くなっていきます。
今後が楽しみですね。</p>
<p>ちなみに<a href="https://github.com/thinca/vim-quickrun">vim-quickrun</a>もポップアップウィンドウ対応していたので興味ある方はアップデートして試してみてください。</p>
]]></content></item><item><title>お勧めVimヘルプ</title><link>https://skanehira.github.io/blog/posts/20190520-vim-quick-manual/</link><pubDate>Mon, 20 May 2019 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20190520-vim-quick-manual/</guid><description>こんにちは。 ゴリラ.vimを運営しているゴリラです。 みなさんVimでヘルプ引いていますか？ Vimは機能が多いのでそのぶんヘルプの量も多く、ど</description><content type="html"><![CDATA[<p>こんにちは。
<a href="https://gorillavim.connpass.com/">ゴリラ.vim</a>を運営しているゴリラです。</p>
<p>みなさんVimでヘルプ引いていますか？
Vimは機能が多いのでそのぶんヘルプの量も多く、どこに欲しい情報があるのかわからないことが多いです。</p>
<p>本記事は<a href="https://vim-jp.org/">vim-jp</a>のメンバーによるお勧めヘルプについてまとめた内容となっています。
Vimについて詳しく知りたい方はぜひお勧めのヘルプを読んでみてください。</p>
<p>ぼくもまだ読んでいないのがたくさんあるので、じっくり読んでいきます。</p>
<h2 id="お勧めvimヘルプ">お勧めVimヘルプ</h2>
<table>
<thead>
<tr>
<th>ヘルプ</th>
<th>概要</th>
</tr>
</thead>
<tbody>
<tr>
<td>help-summary</td>
<td>ヘルプの引き方</td>
</tr>
<tr>
<td>helphelp</td>
<td>ヘルプのヘルプ</td>
</tr>
<tr>
<td>index</td>
<td>各モードのすべてのコマンド一覧</td>
</tr>
<tr>
<td>quickref</td>
<td>よく使うコマンドのクイックリファレンス</td>
</tr>
<tr>
<td>ex-cmd-index</td>
<td>VimのExコマンド一覧</td>
</tr>
<tr>
<td>function-list</td>
<td>組込み数の機能別一覧</td>
</tr>
<tr>
<td>option-list</td>
<td>オプション（cursolineなど）一覧</td>
</tr>
<tr>
<td>map-overview</td>
<td>マップコマンドとモードの対応表</td>
</tr>
<tr>
<td>usr_41</td>
<td>Vim scriptの基本</td>
</tr>
<tr>
<td>eval</td>
<td>Vim scriptの仕様相当の内容</td>
</tr>
</tbody>
</table>
]]></content></item><item><title>翻訳プラグイン作りました</title><link>https://skanehira.github.io/blog/posts/20190512-vim-translate/</link><pubDate>Sun, 12 May 2019 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20190512-vim-translate/</guid><description>こんにちは。 ゴリラ.vimを運営しているゴリラです。 みなさんはプラグイン使っていますか？ ぼくはプラグイン使っていますが、全然作ったことがない</description><content type="html"><![CDATA[<p>こんにちは。
<a href="https://gorillavim.connpass.com/">ゴリラ.vim</a>を運営しているゴリラです。</p>
<p>みなさんはプラグイン使っていますか？
ぼくはプラグイン使っていますが、全然作ったことがないので初めて実用的なものを作りました。</p>
<p>普段OSSのソースを読んだり、作ったOSSのREADMEを英語で書いたりするのですが、
英語力がないため都度ブラウザを開いてGoogle翻訳を使ってはVimに戻る日々でした。</p>
<p>画面の切り替えは時間ロスなのでVim上で翻訳できるプラグインを作りました。</p>
<p>このプラグインがあればVimは翻訳エディタへと生まれ変わります。
どうぞお試してください。</p>
<p><a href="https://github.com/skanehira/translate.vim"><img src="https://github-link-card.s3.ap-northeast-1.amazonaws.com/skanehira/translate.vim.png" width="460px"></a></p>
<h2 id="機能">機能</h2>
<p>状況に応じて、次のことができます。</p>
<ol>
<li>動的に翻訳する</li>
<li>選択した範囲を翻訳する</li>
<li>現在行翻訳する</li>
</ol>
<p>どれも多分よく使うと思います。
設定項目は次になります。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="c">&#34; 翻訳元言語</span><span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">g</span>:<span class="nx">translate_source</span> <span class="p">=</span> <span class="s2">&#34;en&#34;</span><span class="err">
</span><span class="err"></span><span class="c">&#34; 翻訳先言語</span><span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">g</span>:<span class="nx">translate_target</span> <span class="p">=</span> <span class="s2">&#34;ja&#34;</span><span class="err">
</span><span class="err"></span><span class="c">&#34; 翻訳結果ウィンドウのサイズ</span><span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">g</span>:<span class="nx">translate_winsize</span> <span class="p">=</span> <span class="m">10</span><span class="err">
</span></code></pre></div><h3 id="動的に翻訳する">動的に翻訳する</h3>
<p><img src="https://i.imgur.com/ezLCrSG.gif" alt=""></p>
<p><code>:AutoTranslateModeToggle</code>で動的に翻訳するモードに切り替えます。
再度実行するとモードがOFFになります。
自動翻訳モードになると、バッファ上の文字がすべて翻訳されます。</p>
<p>翻訳の契機は<code>&lt;CR&gt;</code>になっていて、改行するとその行を翻訳します。</p>
<p><code>:AutoTranslateModeToggle!</code>では、翻訳元と翻訳先の言語が入れ替わった状態でモードを切り替ります。</p>
<p>ぼくは自動翻訳READMEを書く時に日本語が変になっていないかを確認するときに使います。
控えめに言って、便利です。</p>
<h3 id="選択した範囲を翻訳する">選択した範囲を翻訳する</h3>
<p><img src="https://i.imgur.com/maB2QXI.gif" alt=""></p>
<p>ビジュアルモードで選択した状態で<code>:Translate</code>で翻訳できます。
こちらはソースのコメントを読む時などに便利です。</p>
<p>ちなみに、<code>:Translate!</code>で翻訳元と翻訳先の言語がに入れ替わります。
控えめに言って、便利です。</p>
<h2 id="しくみ">しくみ</h2>
<h3 id="翻訳api">翻訳API</h3>
<p>一番大事な翻訳処理ですが、
GAS<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>の<a href="https://developers.google.com/apps-script/reference/language/language-app">LanguageApp</a>クラスを使用しています。</p>
<p>GASではプロジェクトをWebアプリケーションとして公開できます。
HTTPリクエストは<code>doPost(e)</code>、<code>doGet(e)</code>を用意することで受け取りことが可能です。</p>
<p>HTTPリクエストJSONを取得し、それをもとにLanguageAppクラスで翻訳してその結果を返却します。
こうすることで簡易の翻訳APIを作ることができます。</p>
<p>ちなみに、次が翻訳APIの処理になります。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">doPost</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">postData</span><span class="p">.</span><span class="nx">getDataAsString</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">text</span> <span class="o">==</span> <span class="s2">&#34;&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">ContentService</span><span class="p">.</span><span class="nx">createTextOutput</span><span class="p">(</span><span class="s2">&#34;text is empty&#34;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">source</span> <span class="o">==</span> <span class="s2">&#34;&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">ContentService</span><span class="p">.</span><span class="nx">createTextOutput</span><span class="p">(</span><span class="s2">&#34;source is empty&#34;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">target</span> <span class="o">==</span> <span class="s2">&#34;&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">ContentService</span><span class="p">.</span><span class="nx">createTextOutput</span><span class="p">(</span><span class="s2">&#34;target is empty&#34;</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="kd">var</span> <span class="nx">translatedText</span> <span class="o">=</span> <span class="nx">LanguageApp</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">text</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">source</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">target</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">ContentService</span><span class="p">.</span><span class="nx">createTextOutput</span><span class="p">(</span><span class="nx">translatedText</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>ちなみに、プラグインが使用しているAPIのEndpointは次になります。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">https://script.google.com/macros/s/AKfycbywwDmlmQrNPYoxL90NCZYjoEzuzRcnRuUmFCPzEqG7VdWBAhU/exec
</code></pre></div><p>次のようにcurlコマンドでJSONをPOSTすれば翻訳結果が返ってきます。
<a href="https://github.com/skanehira/gjo">gjo</a>はゴリラ製OSSのひとつで<code>key=value</code>形式で引数を渡すことで簡単にJSON文字列を生成できます。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ curl -L https://script.google.com/macros/s/AKfycbywwDmlmQrNPYoxL90NCZYjoEzuzRcnRuUmFCPzEqG7VdWBAhU/exec -d <span class="k">$(</span>gjo <span class="nv">text</span><span class="o">=</span><span class="s2">&#34;my name is gorilla&#34;</span> <span class="nv">source</span><span class="o">=</span>en <span class="nv">target</span><span class="o">=</span>ja<span class="k">)</span>
私の名前はゴリラです⏎
</code></pre></div><h3 id="翻訳cli">翻訳CLI</h3>
<p>翻訳APIがあればそれに本文と翻訳する言語のオプションを渡すだけです。
もともとVim scriptのみでHTTP通信を行い、翻訳するつもりでしましたが、
Goの勉強もしたいためCLIを作りそれをVimで呼び出すしくみにしました。</p>
<p>CLIに関してはGoの標準パッケージ<code>net/http</code>を使用して、
引数で渡したオプションと本文をJSONに変換し翻訳APIをコールしています。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">post</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Text</span>   <span class="kt">string</span> <span class="s">`json:&#34;text&#34;`</span>
	<span class="nx">Source</span> <span class="kt">string</span> <span class="s">`json:&#34;source&#34;`</span>
	<span class="nx">Target</span> <span class="kt">string</span> <span class="s">`json:&#34;target&#34;`</span>
<span class="p">}</span>

<span class="c1">// translate language
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">translate</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">source</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">postData</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">post</span><span class="p">{</span><span class="nx">text</span><span class="p">,</span> <span class="nx">source</span><span class="p">,</span> <span class="nx">target</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">req</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewRequest</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">MethodPost</span><span class="p">,</span> <span class="o">*</span><span class="nx">endpoint</span><span class="p">,</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">NewBuffer</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">postData</span><span class="p">)))</span>

	<span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">,</span> <span class="s">&#34;application/json&#34;</span><span class="p">)</span>

	<span class="nx">client</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{}</span>
	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">body</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">body</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h3 id="vimプラグイン">Vimプラグイン</h3>
<p>Vimのプラグインは<code>autoload</code>と<code>plugin</code>ディレクトリがあります。
それぞれの違いは次になります。</p>
<table>
<thead>
<tr>
<th>ディレクトリ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>autoload</td>
<td>使用するときに初めて読み込まれるスクリプトファイルを置く</td>
</tr>
<tr>
<td>plugin</td>
<td>Vim起動時に読み込まれるスクリプトファイルを置く</td>
</tr>
</tbody>
</table>
<p>基本的に読み込みに時間がかかるスクリプトは<code>autoload</code>に置きますが、今回は特に重たい処理をするわけではないので<code>plugin</code>ディレクトリのみで物足ります。</p>
<p>プラグインのメイン処理についてざっくり紹介していきます。</p>
<h4 id="cli実行コマンド生成">CLI実行コマンド生成</h4>
<p>まずCLIの実行コマンドを生成します。
<code>ban</code>は<code>!</code>のことを指していて<code>!</code>のときは翻訳元・先の設定を逆転させています。</p>
<p><code>let source_ = get(g:, &quot;translate_source&quot;, &quot;en&quot;)</code>ではグローバルスコープの設定値がなければ、デフォルト値を取得するようにしています。
<code>target</code>の処理も同様になります。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="c">&#34; create gtran command with text and bang</span><span class="err">
</span><span class="err"></span><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">create_cmd</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">bang</span><span class="p">)</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>    <span class="k">if</span> <span class="nx">a</span>:<span class="nx">text</span> <span class="p">==</span> <span class="s2">&#34;&#34;</span><span class="err">
</span><span class="err"></span>        <span class="nx">return</span><span class="err">
</span><span class="err"></span>    <span class="k">endif</span><span class="err">
</span><span class="err">
</span><span class="err"></span>    <span class="k">let</span> <span class="nx">source_</span> <span class="p">=</span> <span class="nx">get</span><span class="p">(</span><span class="nx">g</span>:<span class="p">,</span> <span class="s2">&#34;translate_source&#34;</span><span class="p">,</span> <span class="s2">&#34;en&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="k">let</span> <span class="nx">target</span> <span class="p">=</span> <span class="nx">get</span><span class="p">(</span><span class="nx">g</span>:<span class="p">,</span> <span class="s2">&#34;translate_target&#34;</span><span class="p">,</span> <span class="s2">&#34;ja&#34;</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>    <span class="k">let</span> <span class="nx">cmd</span> <span class="p">=</span> [<span class="s2">&#34;gtran&#34;</span><span class="p">,</span> <span class="s2">&#34;-text=&#34;</span>.<span class="nx">a</span>:<span class="nx">text</span><span class="p">,</span> <span class="s2">&#34;-source=&#34;</span>.<span class="nx">source_</span><span class="p">,</span> <span class="s2">&#34;-target=&#34;</span>.<span class="nx">target</span>]<span class="err">
</span><span class="err"></span>    <span class="k">if</span> <span class="nx">a</span>:<span class="nx">bang</span> <span class="p">==</span> <span class="s1">&#39;!&#39;</span><span class="err">
</span><span class="err"></span>        <span class="k">let</span> <span class="nx">cmd</span> <span class="p">=</span> [<span class="s2">&#34;gtran&#34;</span><span class="p">,</span> <span class="s2">&#34;-text=&#34;</span>.<span class="nx">a</span>:<span class="nx">text</span><span class="p">,</span> <span class="s2">&#34;-source=&#34;</span>.<span class="nx">target</span><span class="p">,</span> <span class="s2">&#34;-target=&#34;</span>.<span class="nx">source_</span>]<span class="err">
</span><span class="err"></span>    <span class="k">endif</span><span class="err">
</span><span class="err"></span>    <span class="nx">return</span> <span class="nx">cmd</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span></code></pre></div><h4 id="コマンド実行">コマンド実行</h4>
<p><code>job_start</code>で外部コマンドを非同期で実行します。
Vimでは外部コマンドを実行する方法として、<code>system()</code>と<code>systemlist()</code>がありますが、
これらは実行が完了するまでVimを操作できないので、翻訳を待ちながらその間に作業をしたいため<code>job_start()</code>にしました。</p>
<p><code>job_start</code>ではオプションを指定できます。</p>
<p><code>callback</code>で指定したcallback関数ではコマンド実行結果の出力を取得します。
callback関数では出力の行数分呼ばれるので、<code>s:result</code>変数に結果を格納していきます。</p>
<p><code>exit_cb</code>で指定したcallback関数ではコマンド実行完了後に呼び出されるので、
<code>s:result</code>に格納した結果出力をバッファに出力する処理を実装しています。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="c">&#34; translate</span><span class="err">
</span><span class="err"></span><span class="k">function</span><span class="p">!</span> <span class="nx">translate</span>#<span class="nx">translate</span><span class="p">(</span><span class="nx">bang</span><span class="p">,</span> <span class="nx">line1</span><span class="p">,</span> <span class="nx">line2</span><span class="p">,</span> ...<span class="p">)</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>    <span class="k">let</span> <span class="nx">ln</span> <span class="p">=</span> <span class="s2">&#34;\n&#34;</span><span class="err">
</span><span class="err"></span>    <span class="k">if</span> &amp;<span class="nx">ff</span> <span class="p">==</span> <span class="s2">&#34;dos&#34;</span><span class="err">
</span><span class="err"></span>        <span class="k">let</span> <span class="nx">ln</span> <span class="p">=</span> <span class="s2">&#34;\r\n&#34;</span><span class="err">
</span><span class="err"></span>    <span class="k">endif</span><span class="err">
</span><span class="err">
</span><span class="err"></span>    <span class="k">let</span> <span class="nx">s</span>:<span class="nx">result</span> <span class="p">=</span> []<span class="err">
</span><span class="err"></span>    <span class="k">let</span> <span class="nx">start</span> <span class="p">=</span> <span class="nx">a</span>:<span class="nx">line1</span><span class="err">
</span><span class="err"></span>    <span class="k">let</span> <span class="nx">end</span> <span class="p">=</span> <span class="nx">a</span>:<span class="nx">line2</span><span class="err">
</span><span class="err">
</span><span class="err"></span>    <span class="k">if</span> <span class="nx">s</span>:<span class="nx">current_mode</span> <span class="p">==</span> <span class="nx">s</span>:<span class="nx">real_time_mode</span><span class="err">
</span><span class="err"></span>        <span class="k">let</span> <span class="nx">start</span> <span class="p">=</span> <span class="m">1</span><span class="err">
</span><span class="err"></span>        <span class="k">let</span> <span class="nx">end</span> <span class="p">=</span> <span class="nx">getpos</span><span class="p">(</span><span class="s2">&#34;$&#34;</span><span class="p">)</span>[<span class="m">1</span>]<span class="err">
</span><span class="err"></span>        <span class="k">let</span> <span class="nx">cmd</span> <span class="p">=</span> <span class="nx">s</span>:<span class="nx">create_cmd</span><span class="p">(</span><span class="nx">s</span>:<span class="nx">getline</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">,</span> <span class="nx">ln</span><span class="p">,</span> <span class="nx">a</span>:<span class="m">000</span><span class="p">),</span> <span class="nx">s</span>:<span class="nx">bang</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="k">else</span><span class="err">
</span><span class="err"></span>        <span class="k">let</span> <span class="nx">cmd</span> <span class="p">=</span> <span class="nx">s</span>:<span class="nx">create_cmd</span><span class="p">(</span><span class="nx">s</span>:<span class="nx">getline</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">,</span> <span class="nx">ln</span><span class="p">,</span> <span class="nx">a</span>:<span class="m">000</span><span class="p">),</span> <span class="nx">a</span>:<span class="nx">bang</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="k">endif</span><span class="err">
</span><span class="err">
</span><span class="err"></span>    <span class="nx">echo</span> <span class="s2">&#34;Translating...&#34;</span><span class="err">
</span><span class="err"></span>    <span class="k">let</span> <span class="nx">job</span> <span class="p">=</span> <span class="nx">job_start</span><span class="p">(</span><span class="nx">cmd</span><span class="p">,</span> {<span class="err">
</span><span class="err"></span>                \<span class="s2">&#34;callback&#34;</span>: <span class="k">function</span><span class="p">(</span><span class="s2">&#34;s:tran_out_cb&#34;</span><span class="p">),</span><span class="err">
</span><span class="err"></span>                \<span class="s2">&#34;exit_cb&#34;</span>: <span class="k">function</span><span class="p">(</span><span class="s2">&#34;s:tran_exit_cb&#34;</span><span class="p">),</span><span class="err">
</span><span class="err"></span>                \}<span class="p">)</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span><span class="err"></span><span class="c">
</span><span class="c">&#34; get command result</span><span class="err">
</span><span class="err"></span><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">tran_out_cb</span><span class="p">(</span><span class="nx">ch</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">add</span><span class="p">(</span><span class="nx">s</span>:<span class="nx">result</span><span class="p">,</span> <span class="nx">a</span>:<span class="nx">msg</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span><span class="err"></span><span class="c">
</span><span class="c">&#34; set command result to translate window buffer</span><span class="err">
</span><span class="err"></span><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">tran_exit_cb</span><span class="p">(</span><span class="nx">job</span><span class="p">,</span> <span class="nx">status</span><span class="p">)</span> <span class="nx">abort</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">s</span>:<span class="nx">create_tran_window</span><span class="p">()</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">setline</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="nx">s</span>:<span class="nx">result</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">s</span>:<span class="nx">focus_window</span><span class="p">(</span><span class="nx">bufnr</span><span class="p">(</span><span class="nx">s</span>:<span class="nx">currentw</span><span class="p">))</span><span class="err">
</span><span class="err"></span>    <span class="nx">echo</span> <span class="s2">&#34;&#34;</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span></code></pre></div><p>ざっくりですがプラグインが動くしくみについて紹介しました。
もっと知りたい方はぜひソースを読んでみてください。
大したことしていないので読みやすいと思います。</p>
<h3 id="既知の問題点">既知の問題点</h3>
<p><a href="https://github.com/cohama/lexima.vim">lexima.vim</a>では<code>&lt;CR&gt;</code>のマッピングがあるので、
leximaが入っていると自動翻訳が動かなくなります。</p>
<p>この問題を修正する予定です。</p>
<h3 id="今後について">今後について</h3>
<p>現在プラグインはVimのみ対応しているのでNeoVimでも動くようにしたいと考えています。
また、NeoVimで実装されたフロートウィンドウを使用して翻訳結果をポップアップウィンドウとして表示させ方がより便利かなと思っています。</p>
<h2 id="最後に">最後に</h2>
<p>Vimを始めたてのころにセッション管理のプラグインを作ったことがありましたが、正直よくわかりませんでした。
はじめてちゃんとプラグインを作って、まだまだ知らないことがたくさんあるなぁと実感しました。</p>
<p>ただ、Vim scriptはbashと似ていて個人的にそんなにとっつきにくい印象はなく楽しかったです。</p>
<p>このきっかけに今後もプラグインをコツコツ作っていこうと思えました。</p>
<p>次のプラグインは<code>電車乗り換え乗案内.vim</code>を作ります。
乞うご期待！</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Google Apps Script <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></item><item><title>Vimヘルプを日本語化</title><link>https://skanehira.github.io/blog/posts/20190427-vim-help-jp/</link><pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20190427-vim-help-jp/</guid><description>こんにちは。 ゴリラ.vimを運営しているゴリラです。 みなさん普段vimのヘルプを使っていますか？ vimでは:h text-objectsという</description><content type="html"><![CDATA[<p>こんにちは。
<a href="https://gorillavim.connpass.com/">ゴリラ.vim</a>を運営しているゴリラです。</p>
<p>みなさん普段vimのヘルプを使っていますか？
vimでは<code>:h text-objects</code>というようにヘルプコマンドを使用することですばやくヘルプを引くことができます。</p>
<p>本記事ではそのヘルプを日本語にする方法を紹介します。</p>
<p>なお、ぼくの環境は次になっています。</p>
<table>
<thead>
<tr>
<th>OS</th>
<th>Vim</th>
<th>プラグインマネージャー</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mac Mojave</td>
<td>8.1</td>
<td><a href="https://github.com/Shougo/dein.vim">dein.vim</a></td>
</tr>
</tbody>
</table>
<h2 id="プラグインに日本語マニュアルを追加">プラグインに日本語マニュアルを追加</h2>
<p>dein.tomlに次の行を追加してvimを再起動します。
再起動後、日本語マニュアルのダウンロードが始まります。</p>
<div class="highlight"><pre class="chroma"><code class="language-toml" data-lang="toml"><span class="p">[[</span><span class="nx">plugins</span><span class="p">]]</span>
<span class="nx">repo</span> <span class="p">=</span> <span class="s1">&#39;vim-jp/vimdoc-ja&#39;</span>
</code></pre></div><h2 id="ヘルプ言語の優先順位を設定する">ヘルプ言語の優先順位を設定する</h2>
<p>vimrcに次の設定を追加してvimを再起動することヘルプが日本語になります。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="c">&#34; ヘルプの言語を日本語優先にする</span><span class="err">
</span><span class="err"></span><span class="nx">set</span> <span class="nx">helplang</span><span class="p">=</span><span class="nx">ja</span><span class="err">
</span></code></pre></div><h2 id="終わりに">終わりに</h2>
<p>たった2ステップでヘルプを日本語化できるんだと感心しました。
とても簡単なのでぜひみなさんも日本語化してヘルプを引いて見てください。
想像以上に快適でした。</p>
<p>では、よいvimライフを〜</p>
]]></content></item><item><title>Vimモード入門</title><link>https://skanehira.github.io/blog/posts/20190427-vim-mode/</link><pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20190427-vim-mode/</guid><description>こんにちは。 ゴリラ.vimを運営しているゴリラです。 vimを初めて半年過ぎましたが、いまだにvimの底が見えていないのでvimは沼ではなくブ</description><content type="html"><![CDATA[<p>こんにちは。
<a href="https://gorillavim.connpass.com/">ゴリラ.vim</a>を運営しているゴリラです。</p>
<p>vimを初めて半年過ぎましたが、いまだにvimの底が見えていないのでvimは沼ではなくブラックホールであることに気付きました。
道のりは遠いですが、楽しみながら旅していこうと思います。</p>
<p>さて、vimを初めて触る方は最初にモードがあることに戸惑う方が多くいるかと思います。
本記事は次のことについて触れていきます。</p>
<ul>
<li>モードによる恩恵は何か</li>
<li>モード一覧</li>
<li>モードごとにできること</li>
</ul>
<p>この記事を読み終わるころにはきっとvimはなぜモードがあるのかを理解できると思います。
理解できなかったら、ぼくが面と向かって3時間語りますのでご連絡ください。</p>
<h2 id="モードによる恩恵は何か">モードによる恩恵は何か</h2>
<p>テキストエディタはモードレスが一般的かと思います。
ではvimはなぜモードがあるのでしょうか？</p>
<p>それは「操作性・機能性」の幅が広がるからとぼくは考えています。</p>
<p>Windowsのメモ帳では<code>A~Z0~9</code>や<code>/@</code>といった記号や文字はそのまま入力でき、<code>Ctrl+C</code>で文字列コピー、<code>Ctrl+S</code>でファイル保存を行います。</p>
<p>対してvimでは入力モードでは文字列の入力、ノーマルモードでは<code>h,j,k,l</code>でカーソル移動、<code>y</code>で文字列ヤンク<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>、<code>dw</code>で単語の削除を行います。
モードがあることより同じキーがまったく異なる動きをします。</p>
<p>そう、これがモードがもたらす恩恵です。</p>
<h2 id="モード一覧">モード一覧</h2>
<p>vimでは以下のモードがあり、それぞれのモードできることは大まか次の表になります。</p>
<table>
<thead>
<tr>
<th>モード</th>
<th>機能</th>
</tr>
</thead>
<tbody>
<tr>
<td>ノーマルモード</td>
<td>カーソル移動、ヤンク、プット<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>、削除、など</td>
</tr>
<tr>
<td>入力モード</td>
<td>文字入力、プットなど</td>
</tr>
<tr>
<td>ビジュアルモード</td>
<td>範囲選択、選択範囲のヤンク、削除など</td>
</tr>
<tr>
<td>コマンドラインモード</td>
<td>変更の保存、vim終了、文字列置換など</td>
</tr>
</tbody>
</table>
<p>他にオペレーター待機モード、端末ジョブモード、選択モードがありますが、
こちらに関しては別の機会に紹介します。</p>
<h2 id="モードの切り替え方">モードの切り替え方</h2>
<p>vimでは基本的にモードを切り替えながら編集します。
次がモードの移行方法です。</p>
<table>
<thead>
<tr>
<th>現在のモード</th>
<th>移行先モード</th>
<th>キー</th>
</tr>
</thead>
<tbody>
<tr>
<td>ノーマル</td>
<td>入力</td>
<td><code>i</code>、<code>I</code>、<code>a</code>、<code>A</code>、<code>s</code>、<code>S</code></td>
</tr>
<tr>
<td>ノーマル</td>
<td>コマンドライン</td>
<td><code>:</code></td>
</tr>
<tr>
<td>ノーマル</td>
<td>ビジュアル</td>
<td><code>v</code>、<code>V</code>、<code>ctr-v</code></td>
</tr>
<tr>
<td>入力</td>
<td>ノーマル</td>
<td><code>esc</code>、<code>ctrl-c</code></td>
</tr>
<tr>
<td>コマンドライン</td>
<td>ノーマル</td>
<td><code>esc</code>、<code>ctrl-c</code></td>
</tr>
<tr>
<td>ビジュアル</td>
<td>ノーマル</td>
<td><code>esc</code>、<code>ctrl-c</code></td>
</tr>
</tbody>
</table>
<p>モード移行キーがいくつかありますが、違いについては<a href="#%E3%83%8E%E3%83%BC%E3%83%9E%E3%83%AB%E3%83%A2%E3%83%BC%E3%83%89">ノーマルモード</a>で説明します。</p>
<h2 id="モードごとにできること">モードごとにできること</h2>
<p>それぞれのモードできることを一部ピックアップして紹介します。</p>
<h3 id="ノーマルモード">ノーマルモード</h3>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>h</code></td>
<td>カーソルを左に移動</td>
</tr>
<tr>
<td><code>j</code></td>
<td>カーソルを下に移動</td>
</tr>
<tr>
<td><code>k</code></td>
<td>カーソルを上に移動</td>
</tr>
<tr>
<td><code>l</code></td>
<td>カーソルを右に移動</td>
</tr>
<tr>
<td><code>yy</code></td>
<td>行ヤンク</td>
</tr>
<tr>
<td><code>Y</code></td>
<td>行ヤンク</td>
</tr>
<tr>
<td><code>dd</code></td>
<td>行削除</td>
</tr>
<tr>
<td><code>D</code></td>
<td>現在のカーソルから行末まで削除</td>
</tr>
<tr>
<td><code>p</code></td>
<td>カーソルの後にプット</td>
</tr>
<tr>
<td><code>P</code></td>
<td>カーソルの前にプット</td>
</tr>
<tr>
<td><code>c</code></td>
<td>削除して入力モードに移行</td>
</tr>
<tr>
<td><code>C</code></td>
<td>現在のカーソルから後ろをすべて削除して入力モードに移行</td>
</tr>
<tr>
<td><code>w</code></td>
<td>次の単語の先頭に移動</td>
</tr>
<tr>
<td><code>W</code></td>
<td>空白と改行で区切られた次の単語の先頭に移動</td>
</tr>
<tr>
<td><code>e</code></td>
<td>単語の末尾に移動</td>
</tr>
<tr>
<td><code>E</code></td>
<td>空白と改行で区切られた単語の最後尾に移動</td>
</tr>
<tr>
<td><code>b</code></td>
<td>前の単語移動</td>
</tr>
<tr>
<td><code>B</code></td>
<td>空白と改行で区切られた前の単語に移動</td>
</tr>
<tr>
<td><code>ZZ</code></td>
<td>保存してvimを終了する</td>
</tr>
</tbody>
</table>
<p>モード移行のコマンドは次になります。</p>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s</code></td>
<td>カーソル上の文字削除して入力モードに移行</td>
</tr>
<tr>
<td><code>S</code></td>
<td>行を削除して入力モードに移行</td>
</tr>
<tr>
<td><code>i</code></td>
<td>入力モードに移行</td>
</tr>
<tr>
<td><code>I</code></td>
<td>カーソルを行先頭に移動して入力モードに移行</td>
</tr>
<tr>
<td><code>a</code></td>
<td>カーソルの後ろに移動して入力モードに移行</td>
</tr>
<tr>
<td><code>A</code></td>
<td>カーソルを行末尾に移動して入力モードに移行</td>
</tr>
<tr>
<td><code>v</code></td>
<td>文字単位ビジュアルモードに移行</td>
</tr>
<tr>
<td><code>V</code></td>
<td>行単位ビジュアルモードに移行</td>
</tr>
<tr>
<td><code>Ctrl-v</code></td>
<td>矩形ビジュアルモードに移行</td>
</tr>
</tbody>
</table>
<p>ノーマルモードでは表通りの操作が可能ですが、その中で<code>y</code>、<code>d</code>、<code>c</code>はオペレーターコマンド、<code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>、<code>w</code>、<code>W</code>、<code>b</code>、<code>B</code>はモーションコマンドと呼ばれています。</p>
<p>モーションコマンドは範囲を指すため、オペレーターコマンドの後にモーションコマンドを続けて入力することでオペレーターの操作がその範囲に適用されます。</p>
<p>つまり、<code>dw</code>で単語を削除、<code>cw</code>で単語を削除して入力モードに移行ることができます。</p>
<p>範囲を示すコマンドはモーション以外にテキストオブジェクトがあります。
一般的によく使うと思われるテキストオブジェクトは次の表になります。</p>
<table>
<thead>
<tr>
<th>テキストオブジェクト</th>
<th>範囲</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>iw</code></td>
<td>単語</td>
</tr>
<tr>
<td><code>aw</code></td>
<td>前後の空白を含む単語</td>
</tr>
<tr>
<td><code>is</code></td>
<td>文</td>
</tr>
<tr>
<td><code>as</code></td>
<td>後の空白を含む文</td>
</tr>
<tr>
<td><code>ip</code></td>
<td>段落</td>
</tr>
<tr>
<td><code>ap</code></td>
<td>改行を含む段落</td>
</tr>
<tr>
<td><code>ib</code></td>
<td>()の内部</td>
</tr>
<tr>
<td><code>ab</code></td>
<td>()と内部を含む</td>
</tr>
</tbody>
</table>
<p>表以外のテキストオブジェクトは<a href="https://vim-jp.org/vimdoc-ja/motion.html#text-objects">こちら</a>を参照してください。</p>
<p>この通り、vimではテキストオブジェクト・モーション・オペレーターを駆使することでテキストの高速編集を実現しています。
ここから楽しくなるので、初学者の方はまずこれらに慣れることをお勧めします。</p>
<h3 id="入力モード">入力モード</h3>
<p>一部を紹介します。
ほかに何ができるか気になる方は<a href="https://gorilla.netlify.com/articles/20190123-vim-insert.html">Vimのインサートモードでできること</a>をぜひ読んでみてください。
gif付きでわかりやすく説明しています。</p>
<table>
<thead>
<tr>
<th>キー</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>esc</code></td>
<td>ノーマルモードに移行</td>
</tr>
<tr>
<td><code>Ctrl-c</code></td>
<td>ノーマルモードに移行<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></td>
</tr>
<tr>
<td><code>Ctrl-y</code></td>
<td>上の行のカーソルの位置の文字を挿入</td>
</tr>
<tr>
<td><code>Ctrl-e</code></td>
<td>下の行のカーソルの位置の文字を挿入</td>
</tr>
<tr>
<td><code>Ctrl-t</code></td>
<td>1タブ入力</td>
</tr>
<tr>
<td><code>Ctrl-d</code></td>
<td>1タブ削除</td>
</tr>
<tr>
<td><code>Ctrl-g</code> <code>j</code></td>
<td>下の行に移動</td>
</tr>
<tr>
<td><code>Ctrl-g</code> <code>k</code></td>
<td>上の行に移動</td>
</tr>
<tr>
<td><code>Ctrl-h</code></td>
<td>一文字削除</td>
</tr>
<tr>
<td><code>Ctrl-r</code> <code>{0-9a-z&quot;%#*:=}</code></td>
<td>指定したレジスタ<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>をプット</td>
</tr>
<tr>
<td><code>Ctrl-x</code> <code>Ctrl-n</code></td>
<td>開いているファイルないにある単語補完</td>
</tr>
</tbody>
</table>
<h3 id="ビジュアルモード">ビジュアルモード</h3>
<table>
<thead>
<tr>
<th>キー</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>y</code></td>
<td>選択した範囲をヤンク</td>
</tr>
<tr>
<td><code>d</code></td>
<td>選択した範囲を削除</td>
</tr>
<tr>
<td><code>c</code></td>
<td>選択した範囲を削除して入力モードに移行</td>
</tr>
<tr>
<td><code>=</code></td>
<td>選択した範囲を整形する</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>選択した範囲を1タブ右に移動</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>選択した範囲を1タグ右に移動</td>
</tr>
<tr>
<td><code>I</code></td>
<td>矩形選択のとき、選択範囲のすべての行先頭にテキストを入力</td>
</tr>
<tr>
<td><code>J</code></td>
<td>選択した範囲をすべて連結する</td>
</tr>
<tr>
<td><code>o</code></td>
<td>選択した範囲の先頭または末尾にカーソルを移動</td>
</tr>
</tbody>
</table>
<p>もっと詳しく知りたい方は<a href="https://vim-jp.org/vimdoc-ja/visual.html">マニュアル</a>を参照してみてください。</p>
<h3 id="コマンドラインモード">コマンドラインモード</h3>
<p>こちらの<a href="https://gorilla.netlify.com/articles/20190422-vim-cmdline.html">Vimのコマンドラインモードでできること</a>にまとめてありますので、ぜひ読んでみてください。</p>
<h2 id="最後に">最後に</h2>
<p>みなさん、なぜvimにはモードがあるのか理解できましたか？</p>
<p>本記事で紹介した内容はほんの一部をでしかなくて、ほかにもできることがたくさんあります。
ぜひ日本語マニュアルや他の方の記事を読んでみてください。</p>
<p>また、ぼくが運営しているゴリラ。vimではvimmerがたくさん集まっています。
一人ではなかなか知ることのできない知見がゴリラ。vimにあります。</p>
<p>では、よいvimライフを〜</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>コピーすることを指す <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>貼り付けのことを指す <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p><code>esc</code>と同等ではないと<a href="https://twitter.com/h_east?s=17">h_eastさん</a>より指摘をいただきました。詳細は<a href="http://neko-mac.blogspot.com/2016/07/vimvim.html?showComment=1481768895634#c2524567742061789023">こちらのコメント</a>を参照してください。 <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>ヤンクしたデータが保存されている領域のこと <a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></item><item><title>Vimのコマンドラインモードでできること</title><link>https://skanehira.github.io/blog/posts/20190422-vim-cmdline/</link><pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20190422-vim-cmdline/</guid><description>こんにちは ゴリラ.vimを運営しているゴリラです。 みなさんvimでコマンドをよく使っていますか？ ぼくは基本的にそんなにコマンドを使わないので</description><content type="html"><![CDATA[<p>こんにちは</p>
<p><a href="https://gorillavim.connpass.com/">ゴリラ.vim</a>を運営しているゴリラです。</p>
<p>みなさんvimでコマンドをよく使っていますか？
ぼくは基本的にそんなにコマンドを使わないので、どんなことができるのかを調べてみました。
<a href="https://vim-jp.org/vimdoc-ja/cmdline.html">日本語マニュアル</a>を見ればどんなことができるのか知れるので見ておくと勉強になると思います。</p>
<h2 id="コマンドラインモードとは">コマンドラインモードとは？</h2>
<p>vimでバッファをファイルに書き込むときによく<code>:w</code>を打つと思いますが、これが<code>:</code>でコマンドラインモードに移行し、続けてコマンドを入力して実行しているだけです。
コマンドラインモードで実行できるコマンドは<code>Eｘコマンド</code>です。</p>
<h2 id="よく使うexコマンド">よく使うExコマンド</h2>
<p>一般的によく使用すると思われるExコマンドは次の表になります。
<code>:</code>はモード切り替えキーなので省いてあります。</p>
<table>
<thead>
<tr>
<th style="text-align:left">コマンド</th>
<th style="text-align:left">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">new</td>
<td style="text-align:left">新規バッファを作成する</td>
</tr>
<tr>
<td style="text-align:left">tabnew</td>
<td style="text-align:left">新規タブを作成する</td>
</tr>
<tr>
<td style="text-align:left">e</td>
<td style="text-align:left">ファイルを編集する</td>
</tr>
<tr>
<td style="text-align:left">r</td>
<td style="text-align:left">入力をバッファに挿入する</td>
</tr>
<tr>
<td style="text-align:left">w</td>
<td style="text-align:left">現在のバッファを開いているファイルに書き込む</td>
</tr>
<tr>
<td style="text-align:left">q</td>
<td style="text-align:left">vimを終了する</td>
</tr>
<tr>
<td style="text-align:left">wq</td>
<td style="text-align:left">バッファをファイルに書き込んでvimを終了する</td>
</tr>
<tr>
<td style="text-align:left">q!</td>
<td style="text-align:left">vimを強制終了</td>
</tr>
<tr>
<td style="text-align:left">%s/置換対象文字/置換する文字/g</td>
<td style="text-align:left">文字を置換する</td>
</tr>
<tr>
<td style="text-align:left">reg</td>
<td style="text-align:left">レジスタ一覧を表示</td>
</tr>
<tr>
<td style="text-align:left">his</td>
<td style="text-align:left">コマンド履歴を表示</td>
</tr>
</tbody>
</table>
<p>すべてのExコマンドは<a href="https://vim-jp.org/vimdoc-ja/vimindex.html#ex-cmd-index">こちらのマニュアル</a>を参照してください。</p>
<h2 id="コマンドラインモードでの編集">コマンドラインモードでの編集</h2>
<p>コマンドラインモードでは、単語ごとの移動、削除、履歴の呼び出しなどを行うことができます。
次の表の操作を覚えておくとよいでしょう。</p>
<table>
<thead>
<tr>
<th style="text-align:left">コマンド</th>
<th style="text-align:left">操作　</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><kbd>shift</kbd> + <kbd>→</kbd></td>
<td style="text-align:left">次の単語に移動</td>
</tr>
<tr>
<td style="text-align:left"><kbd>shift</kbd> + <kbd>←</kbd></td>
<td style="text-align:left">前の単語に移動</td>
</tr>
<tr>
<td style="text-align:left"><kbd>ctrl</kbd> + <kbd>w</kbd></td>
<td style="text-align:left">1単語削除</td>
</tr>
<tr>
<td style="text-align:left"><kbd>ctrl</kbd> + <kbd>u</kbd></td>
<td style="text-align:left">カーソルより前の単語すべて削除</td>
</tr>
<tr>
<td style="text-align:left"><kbd>ctrl</kbd> + <kbd>e</kbd></td>
<td style="text-align:left">最後尾に移動</td>
</tr>
<tr>
<td style="text-align:left"><kbd>ctrl</kbd> + <kbd>b</kbd></td>
<td style="text-align:left">先頭に移動</td>
</tr>
<tr>
<td style="text-align:left"><kbd>ctrl</kbd> + <kbd>p</kbd> もしくは <kbd>n</kbd></td>
<td style="text-align:left">履歴の呼び出し</td>
</tr>
<tr>
<td style="text-align:left"><kbd>ctrl</kbd> + <kbd>f</kbd></td>
<td style="text-align:left">コマンドラインウィンドウを開く</td>
</tr>
<tr>
<td style="text-align:left"><kbd>ctrl</kbd> + <kbd>r</kbd> + レジスタ（0-9a-z&quot;%#:-=.）</td>
<td style="text-align:left">レジスタの内容を挿入する</td>
</tr>
</tbody>
</table>
<p>ちなみにぼくは次のようにキーマッピングを変えています。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="nx">cnoremap</span> <span class="p">&lt;</span><span class="nx">c</span><span class="p">-</span><span class="nx">b</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nx">S</span><span class="p">-</span><span class="nx">Left</span><span class="p">&gt;</span><span class="err">
</span><span class="err"></span><span class="nx">cnoremap</span> <span class="p">&lt;</span><span class="nx">c</span><span class="p">-</span><span class="nx">f</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nx">S</span><span class="p">-</span><span class="nx">Right</span><span class="p">&gt;</span><span class="err">
</span><span class="err"></span><span class="nx">cnoremap</span> <span class="p">&lt;</span><span class="nx">c</span><span class="p">-</span><span class="nx">a</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nx">Home</span><span class="p">&gt;</span><span class="err">
</span></code></pre></div><h2 id="コマンドラインウィンドウについて">コマンドラインウィンドウについて</h2>
<p>コマンドラインウィンドウでは、コマンド履歴選択して<kbd>enter</kbd>で再実施したり、履歴を編集して再実施が可能です。
モードが適用され、<kbd>i</kbd>で入力モードに切り替えて編集でき、<kbd>ctrl</kbd> + <kbd>c</kbd>もしくは<kbd>esc</kbd>で入力モードを抜けることができます。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/8acd5615-93e2-6df1-7fa4-954ab9a57de7.gif" alt="cmdwindow.gif"></p>
<h2 id="外部コマンド実行">外部コマンド実行</h2>
<p>よく知られていることですが、コマンドラインモードでは<code>!</code>を先頭につけることで、外部コマンド（lsコマンドなど）を実行できます。
ちなみに、<code>r!ls</code>でコマンドの実行結果をバッファに書き込むことができます。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/781d70c9-78a2-4d47-84fd-4ec2404bcb7e.gif" alt="ls.gif"></p>
<p>また、<code>w !xargs echo</code>でバッファを標準入力として外部コマンドにわたすことができます。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/932812e5-d56c-c03b-c27c-8ff5700ef6ff.gif" alt="wecho.gif"></p>
<h2 id="置換について">置換について</h2>
<p>普段、皆さんはファイル全体に対して、置換を行う時は<code>%s/{pattern}/{string}/g</code>を実行していると思います。
ぼくは完全に呪文として覚えていましたが、実はそれぞれの構文にはちゃんと意味があります。</p>
<table>
<thead>
<tr>
<th style="text-align:center">単語</th>
<th style="text-align:center">意味</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">範囲指定コマンド、ファイル全体を指定する</td>
</tr>
<tr>
<td style="text-align:center">s/{pattern}/{string}</td>
<td style="text-align:center">sはsubstituteの略で行にある{pattern}を{string}に置換するコマンド。デフォルトは最初に出現した{pattern}を置換する</td>
</tr>
<tr>
<td style="text-align:center">g</td>
<td style="text-align:center">行内で複数の{pattern}がある場合、すべて{string}に置換する</td>
</tr>
</tbody>
</table>
<p>つまり、ファイル内のすべての行に出現する{pattern}を{string}に置換するという意味になります。
<code>g</code>はフラグと呼ばれていて、ほかにもいろんなフラグがあるようです。</p>
<h2 id="範囲">範囲</h2>
<p>置換のときに使用する<code>%</code>は範囲指定と先ほど説明しましたが、
ほかにも範囲指定する方法があります。</p>
<table>
<thead>
<tr>
<th style="text-align:center">コマンド</th>
<th style="text-align:center">範囲</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">現在行を指定する</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">10行目を指定する</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:center">ファイル最終行を指定する</td>
</tr>
<tr>
<td style="text-align:center">10,20</td>
<td style="text-align:center">10行から20行を指定する</td>
</tr>
<tr>
<td style="text-align:center">&lsquo;&lt;,'&gt;&rsquo;</td>
<td style="text-align:center">選択モード（visual）で選択した範囲</td>
</tr>
</tbody>
</table>
<p>このように、範囲と置換を組み合わせることで、任意の範囲内の文字列を置換できます。
たとえば<code>'&lt;,'&gt;s/world/gorilla/g</code>は選択した範囲内にある<code>world</code>を<code>gorilla</code>に置換できます。</p>
<p>もちろん置換以外もコマンドも実行できます。</p>
<h2 id="編集">編集</h2>
<p>コマンドラインモードでは置換以外にヤンク・コピー・削除・ペーストもできます。</p>
<table>
<thead>
<tr>
<th style="text-align:center">コマンド</th>
<th style="text-align:center">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">y</td>
<td style="text-align:center">指定した行をレジスタにヤンク、指定がなければ基本的に無名レジスタに保存される</td>
</tr>
<tr>
<td style="text-align:center">pu</td>
<td style="text-align:center">指定した行にレジスタからペースト、指定がなければ基本的に無名レジスタからペーストされる</td>
</tr>
<tr>
<td style="text-align:center">d</td>
<td style="text-align:center">指定した行を削除してレジスタに保存する、指定がなければ基本的に無名レジスタに保存される</td>
</tr>
<tr>
<td style="text-align:center">t</td>
<td style="text-align:center">指定した行を指定した行の下にコピーする</td>
</tr>
</tbody>
</table>
<p>コマンドとさきほど紹介した範囲指定を組み合わせることで次のようにコマンドラインモードでも任意の範囲を編集するできます。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/5cbea8e6-71b9-32ae-840f-513c4387970c.gif" alt="operate.gif"></p>
<h2 id="ノーマルモードのコマンド実行">ノーマルモードのコマンド実行</h2>
<p>コマンドラインモードでノーマルモードのコマンドを実行できます。
<code>normal</code>のあとにスペースを開けて、コマンドを入力することでコマンドを実行できます。</p>
<p>次のgifでは<code>%normal v=</code>でファイル全体を整形しています。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/4e89a963-7d46-c7d0-e0a5-a028ec0b9abc.gif" alt="normal.gif"></p>
<h2 id="笑顔になれるコマンド">笑顔になれるコマンド</h2>
<p>vimにはユーザーが笑顔になれる<code>smile</code>コマンドが用意されています。
実行すると次のようになります。
ちなみに、ぼくは笑顔になれました。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/66178/1529aa2e-a912-9c2e-66f8-da3c413cb8dc.png" alt="image.png"></p>
<h2 id="まとめ">まとめ</h2>
<p>vimには実践的なコマンドから<code>smile</code>のようなユーモアのあるコマンドまで、たくさんあっておもしろいなと思いました。
TwitterのDMでもリプでもかまわないので、ほかにこのコマンド便利だよというのがあればぜひ教えてください。</p>
<p>ではみなさん、よいvimライフを〜</p>
]]></content></item><item><title>Vimの標準ファイラnetrwは普通に良さそうな話し</title><link>https://skanehira.github.io/blog/posts/20190321-vim-netrw/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20190321-vim-netrw/</guid><description>こんにちは ゴリラ.vimを運営しているゴリラです。 みなさんvimでファイラを使っていますか？ 多分vim入門したての方はnerdtreeという</description><content type="html"><![CDATA[<p>こんにちは
<a href="https://gorillavim.connpass.com/">ゴリラ.vim</a>を運営しているゴリラです。</p>
<p>みなさんvimでファイラを使っていますか？
多分vim入門したての方は<a href="https://github.com/scrooloose/nerdtree">nerdtree</a>というプラグインを入れることが多いかと思います。
ぼくも実際IDEからのvimへ移行しましたが、ファイルツリーがないと落ち着かなくて入れていました。</p>
<p>実は、vimには標準でnetrwというファイラがあります。
そちらについて少し紹介していきます。</p>
<h2 id="netrwについて">netrwについて</h2>
<p>netrwはvim標準で用意されているプラグインになります。
netrwを使用することでファイラのように、画像のようにディレクトリをブラウジングできます。</p>
<p><img src="https://qiita-image-store.s3.amazonaws.com/0/66178/59adb3c6-9e2d-909e-a36f-626876a63e0c.png" alt="image.png"></p>
<p>いろんなオプションが用意されていて、それらをカスタマイズすることでさらに使いやすくなります。</p>
<h2 id="netrwを有効にする">netrwを有効にする</h2>
<p>netrwはプラグインですので、以下の設定がされていない方は<code>~/.vimrc</code>に設定してください。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="nx">filetype</span> <span class="nx">plugin</span> <span class="nx">on</span><span class="err">
</span></code></pre></div><h2 id="netrwの基本操作">netrwの基本操作</h2>
<p>vim起動時に使用したい場合は<code>vim .</code>でnetrwが立ち上がります。
vim起動済みの場合は<code>:Ex</code>でカレントバッファ、<code>:Ve</code>で水平分割で開きます。</p>
<p>以下が基本操作になります。</p>
<table>
<thead>
<tr>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">j</td>
<td style="text-align:left">下に移動</td>
</tr>
<tr>
<td style="text-align:left">k</td>
<td style="text-align:left">上に移動</td>
</tr>
<tr>
<td style="text-align:left">Enter</td>
<td style="text-align:left">ディレクトリの場合は移動、ファイルの場合はカレントバッファに開く</td>
</tr>
<tr>
<td style="text-align:left">o</td>
<td style="text-align:left">水平分割で開く</td>
</tr>
<tr>
<td style="text-align:left">v</td>
<td style="text-align:left">垂直分割で開く</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">ひとつ上のディレクトリに移動</td>
</tr>
<tr>
<td style="text-align:left">u</td>
<td style="text-align:left">undo、1つ前のディレクトリに戻る</td>
</tr>
<tr>
<td style="text-align:left">U</td>
<td style="text-align:left">redo、uで戻る前のディレクトリに戻る</td>
</tr>
<tr>
<td style="text-align:left">d</td>
<td style="text-align:left">ディレクトリを作成する</td>
</tr>
<tr>
<td style="text-align:left">D</td>
<td style="text-align:left">ディレクトリ・ファイルを削除する</td>
</tr>
<tr>
<td style="text-align:left">mf</td>
<td style="text-align:left">ファイルをマークする</td>
</tr>
<tr>
<td style="text-align:left">mt</td>
<td style="text-align:left">コピー・移動先のディレクトリをマークする</td>
</tr>
<tr>
<td style="text-align:left">mc</td>
<td style="text-align:left">mfしたファイルをmtしたディレクトリにコピーする</td>
</tr>
<tr>
<td style="text-align:left">mm</td>
<td style="text-align:left">mfしたファイルをmtしたディレクトリに移動する</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">ヘッダの表示トグル</td>
</tr>
<tr>
<td style="text-align:left">i</td>
<td style="text-align:left">ファイルツリーの表示形式を変更</td>
</tr>
<tr>
<td style="text-align:left">p</td>
<td style="text-align:left">ファイルをプレビューする</td>
</tr>
</tbody>
</table>
<p>ファイルのコピーと移動以外は普通に便利ですね。</p>
<h2 id="リモート編集">リモート編集</h2>
<p>netrwの目玉機能のひとつとも言えるリモート編集ですが、
以下の<a href="https://vim-jp.org/vimdoc-ja/pi_netrw.html#netrw-ref">プロトコル</a>に対応しています。</p>
<p><img src="https://qiita-image-store.s3.amazonaws.com/0/66178/7d579647-f92f-fcee-be5e-1cf16e5d996e.png" alt="image.png"></p>
<p>sshでサーバ上のファイルをちょこっと編集・確認したいときなどに使用できるので便利ですね。
ちなみに、以下のようにするとファイルを編集・保存（してからアップロード）できます。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">vim scp://remote-server//home/gorilla/.vimrc
</code></pre></div><p>これはvim内部でscpコマンドを実行している様ですので、scpコマンドは必要と思います。</p>
<h2 id="カスタマイズ">カスタマイズ</h2>
<p>標準のnetrwのファイルツリーでは、若干見づらいので、見た目を<code>ls -la</code>コマンドに近付けます。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="c">&#34; ファイルツリーの表示形式、1にするとls -laのような表示になります</span><span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">g</span>:<span class="nx">netrw_liststyle</span><span class="p">=</span><span class="m">1</span><span class="err">
</span><span class="err"></span><span class="c">&#34; ヘッダを非表示にする</span><span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">g</span>:<span class="nx">netrw_banner</span><span class="p">=</span><span class="m">0</span><span class="err">
</span><span class="err"></span><span class="c">&#34; サイズを(K,M,G)で表示する</span><span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">g</span>:<span class="nx">netrw_sizestyle</span><span class="p">=</span><span class="s2">&#34;H&#34;</span><span class="err">
</span><span class="err"></span><span class="c">&#34; 日付フォーマットを yyyy/mm/dd(曜日) hh:mm:ss で表示する</span><span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">g</span>:<span class="nx">netrw_timefmt</span><span class="p">=</span><span class="s2">&#34;%Y/%m/%d(%a) %H:%M:%S&#34;</span><span class="err">
</span><span class="err"></span><span class="c">&#34; プレビューウィンドウを垂直分割で表示する</span><span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">g</span>:<span class="nx">netrw_preview</span><span class="p">=</span><span class="m">1</span><span class="err">
</span></code></pre></div><p>上記の設定をvimrcに追加すれば、冒頭のスクショの表示になります。
個人的に上記設定が一番見やすいのですが、もっと良い設定があるかもしれないのでぜひイジって見ください。</p>
<h2 id="まとめ">まとめ</h2>
<p>公式マニュアルを見ればもっといろんなことが書かれています。
個人的に、これくらいの機能を知れば困ることはないので、これ以上深掘りはしていません。</p>
<p>興味ある方はぜひ深く掘ってみて、これよいぞってのがあれば教えていただけると幸いです。</p>
]]></content></item><item><title>Vim起動時にできること</title><link>https://skanehira.github.io/blog/posts/20190201-vim-start/</link><pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20190201-vim-start/</guid><description>こんにちは ゴリラです。 前回Vimのインサートモードでできることを書いたのですが、 思いの外需要があるだなと思ったので、Vimの起動時にできるこ</description><content type="html"><![CDATA[<p>こんにちは
ゴリラです。</p>
<p>前回<a href="https://qiita.com/gorilla0513/items/95e0d36045682a1f0123">Vimのインサートモードでできること</a>を書いたのですが、
思いの外需要があるだなと思ったので、Vimの起動時にできることを今回紹介していきます。
書く項目をクリックすればリンクに飛べます。</p>
<p>この記事で紹介した内容をすべて知っている方はすごいvimmerと思われます。</p>
<h2 id="垂直分割で開くhttpsvim-jporgvimdoc-jastartinghtml-o"><a href="https://vim-jp.org/vimdoc-ja/starting.html#-O">垂直分割で開く</a></h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">vim -O2 file1 file2
</code></pre></div><p><img src="https://qiita-image-store.s3.amazonaws.com/0/66178/ebe8e164-572c-7baf-8dbc-7c78292206d0.gif" alt="vim-O2.gif"></p>
<h2 id="水平分割開くhttpsvim-jporgvimdoc-jastartinghtml-o"><a href="https://vim-jp.org/vimdoc-ja/starting.html#-o">水平分割開く</a></h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">vim -o2 file1 file2
</code></pre></div><p><img src="https://qiita-image-store.s3.amazonaws.com/0/66178/931edd33-62da-85a8-009d-7e6abb6d1cf6.gif" alt="vim-o.gif"></p>
<h2 id="複数のファイルをタブで開くhttpsvim-jporgvimdoc-jastartinghtml-p"><a href="https://vim-jp.org/vimdoc-ja/starting.html#-p">複数のファイルをタブで開く</a></h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">vim -p2 file1 file2
</code></pre></div><p><img src="https://qiita-image-store.s3.amazonaws.com/0/66178/258d6dfa-e017-166e-545b-c490a8b45f81.gif" alt="vim-tab.gif"></p>
<h2 id="指定した行にカーソルを移動した状態で開くhttpsvim-jporgvimdoc-jastartinghtml-"><a href="https://vim-jp.org/vimdoc-ja/starting.html#-+">指定した行にカーソルを移動した状態で開く</a></h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">vim +10 file
</code></pre></div><p>コーディング時、ログからエラー箇所がわかっている場合に使える。
<img src="https://qiita-image-store.s3.amazonaws.com/0/66178/287c4379-b679-a53e-b99e-941ee701b570.gif" alt="vim-+.gif"></p>
<h2 id="検索かけた状態でファイル開くhttpsvim-jporgvimdoc-jastartinghtml-"><a href="https://vim-jp.org/vimdoc-ja/starting.html#-+/">検索かけた状態でファイル開く</a></h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">vim +/ gorilla file
</code></pre></div><p><code>cgn</code>と一緒に使うと便利かも。
<img src="https://qiita-image-store.s3.amazonaws.com/0/66178/9727e041-a2f5-c801-46d8-370a3d700a80.gif" alt="vim-+:.gif"></p>
<h2 id="セッションを復帰するhttpsvim-jporgvimdoc-jastartinghtml-s"><a href="https://vim-jp.org/vimdoc-ja/starting.html#-S">セッションを復帰する</a></h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">vim -S session.vim
</code></pre></div><p>セッションについては<a href="https://qiita.com/gorilla0513/items/838138004f86b66d5668">こちら</a>の記事を参考に。
<img src="https://qiita-image-store.s3.amazonaws.com/0/66178/f1546fe4-7469-0eca-a633-b255523e5abe.gif" alt="vim-session.gif"></p>
<h2 id="読み取り専用状態でファイルを開くhttpsvim-jporgvimdoc-jastartinghtml-r"><a href="https://vim-jp.org/vimdoc-ja/starting.html#-R">読み取り専用状態でファイルを開く</a></h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">vim -R file
</code></pre></div><p>確認するだけなのにうっかり編集してしまわないようにする時に使うと便利かも。
<img src="https://qiita-image-store.s3.amazonaws.com/0/66178/429baf51-fcc3-235b-91b5-bb8eb430c438.gif" alt="vim-R.gif"></p>
<h2 id="exモードで起動httpsvim-jporgvimdoc-jastartinghtml-e"><a href="https://vim-jp.org/vimdoc-ja/starting.html#-e">Exモードで起動</a></h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">vim -e
</code></pre></div><p>Vimスクリプトの学習時に使える。
<img src="https://qiita-image-store.s3.amazonaws.com/0/66178/663d8530-80da-2fe4-64d5-80091ff7ceae.gif" alt="vim-e.gif"></p>
<h2 id="差分確認httpsvim-jporgvimdoc-jastartinghtml-d"><a href="https://vim-jp.org/vimdoc-ja/starting.html#-d">差分確認</a></h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">vim -d file1  file2
</code></pre></div><p>vimdiffでも同じことができる。
<img src="https://qiita-image-store.s3.amazonaws.com/0/66178/c832e5c8-a6a0-50dc-f2e3-fbabd4e65545.gif" alt="vim-diff.gif"></p>
<h2 id="バイナリ編集httpsqiitacomurakarinitems337a0433a41443731ad0"><a href="https://qiita.com/urakarin/items/337a0433a41443731ad0">バイナリ編集</a></h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># ↓でバイナリモードでファイルを開く</span>
vim -b gorilla.bin
<span class="c1"># 開いたあとに</span>
:%!xxd
</code></pre></div><p><img src="https://qiita-image-store.s3.amazonaws.com/0/66178/9402a9ab-6e8a-3c10-dcbb-ac39f47b9e97.gif" alt="vim-binary.gif"></p>
<h2 id="素のvimを起動httpsvim-jporgvimdoc-jastartinghtml--noplugin"><a href="https://vim-jp.org/vimdoc-ja/starting.html#--noplugin">素のvimを起動</a></h2>
<pre><code>vim -u NONE
</code></pre><p>vimでは<code>:e .</code>で標準のnetrwが起動しますが、,
素のvimだとそれが起動しないのgifでわかったと思います。
そして、暗黒パワーが消える。
<img src="https://qiita-image-store.s3.amazonaws.com/0/66178/a54af9ab-7500-1d48-39f1-1771dd0974bb.gif" alt="vim-none.gif"></p>
<h2 id="スワップファイルから復活httpsvim-jporgvimdoc-jastartinghtml-r"><a href="https://vim-jp.org/vimdoc-ja/starting.html#-r">スワップファイルから復活</a></h2>
<pre><code>vim -r gorilla.swp
</code></pre><p><img src="https://qiita-image-store.s3.amazonaws.com/0/66178/ef8c0903-a998-d82e-ffec-8bf281eeaa4b.gif" alt="vim-recover.gif"></p>
<h2 id="まとめ">まとめ</h2>
<p>Vimはよいぞ！
ではよいVimライフを〜</p>
]]></content></item><item><title>Vimのインサートモードでできること</title><link>https://skanehira.github.io/blog/posts/20190123-vim-insert/</link><pubDate>Wed, 23 Jan 2019 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20190123-vim-insert/</guid><description>こんにちは ゴリラです。 久しぶりの投稿になりました。 今年に入って自分のOSSの活動やらイベント登壇やらで、 あまり記事を書く時間とっていなかった</description><content type="html"><![CDATA[<p>こんにちは
ゴリラです。</p>
<p>久しぶりの投稿になりました。
今年に入って自分のOSSの活動やらイベント登壇やらで、
あまり記事を書く時間とっていなかったので久しぶりに書きました。</p>
<p>最近、vimのインサートモードでなにげにいろいろできることを知ったので、
それについて軽くまとめた記事になります。</p>
<p>知らないこと多かったので、自分は結構勉強になりました。
この記事で紹介した内容をだいたい知っている方は、多分すごいvimmerと思われます。</p>
<h2 id="ペーストhttpsvim-jporgvimdoc-jainserthtmli_ctrl-r"><a href="https://vim-jp.org/vimdoc-ja/insert.html#i_CTRL-R">ペースト</a></h2>
<p>ペーストする時はノーマルモードに戻ってからペーストすることが一般的（と思われる）ですが、
実はyankしたデータはレジスタに入っていて、
そのレジスタの内容をインサートモードでも挿入できます。</p>
<p><kbd>Ctrl</kbd> + <kbd>r</kbd>でレジスタ名が挿入するのを待ってくれます。
その状態で挿入したいレジスタ入力するだけでOKです。</p>
<p><img src="https://qiita-image-store.s3.amazonaws.com/0/66178/fcd22cb8-6811-ac14-6e20-6458172230e7.gif" alt="insert-paste.gif"></p>
<p>ちなみに、自動インデントの場合は、<kbd>Ctrl</kbd> + <kbd>r</kbd> &amp;&amp; <kbd>Ctrl</kbd> + <kbd>o</kbd>のあとにレジスタを入力すると自動インデントされないので、困った場合はこちらのオペレーションにしましょう。</p>
<h2 id="インデント調整httpsvim-jporgvimdoc-jainserthtmli_ctrl-t"><a href="https://vim-jp.org/vimdoc-ja/insert.html#i_CTRL-T">インデント調整</a></h2>
<p><kbd>Ctrl</kbd> + <kbd>t</kbd>でshiftwidth分インデントされます。
<kbd>Ctrl</kbd> + <kbd>d</kbd>でshiftwidth分インデント削除されます。</p>
<p><img src="https://qiita-image-store.s3.amazonaws.com/0/66178/2f58c1e1-5565-0857-eba3-8b5a4ecdd1b0.gif" alt="indent.gif"></p>
<h2 id="補完httpsvim-jporgvimdoc-jainserthtmlins-completion"><a href="https://vim-jp.org/vimdoc-ja/insert.html#ins-completion">補完</a></h2>
<p>vimは標準でいろんな補完が用意されています。</p>
<h3 id="ファイル補完">ファイル補完</h3>
<p><kbd>Ctrl</kbd> + <kbd>x</kbd> <kbd>Ctrl</kbd> + <kbd>f</kbd>でファイル一覧を選べます。
<img src="https://qiita-image-store.s3.amazonaws.com/0/66178/39f5ade7-8e87-af57-ef13-9590574cd828.gif" alt="file-completion.gif"></p>
<h3 id="オムニ補完">オムニ補完</h3>
<p><kbd>Ctrl</kbd> + <kbd>x</kbd> <kbd>Ctrl</kbd> + <kbd>o</kbd>でオムニ補完します。
<img src="https://qiita-image-store.s3.amazonaws.com/0/66178/d1e59ae6-71bb-1c7e-a5d7-b6e72928aaa0.gif" alt="omuni-completion.gif"></p>
<h3 id="単語補完">単語補完</h3>
<p><kbd>Ctrl</kbd> + <kbd>x</kbd> <kbd>Ctrl</kbd> + <kbd>n</kbd>で現在開いているファイルにある単語一覧を選べます。
<img src="https://qiita-image-store.s3.amazonaws.com/0/66178/1ee127fb-a311-00eb-a6d2-316510cc3796.gif" alt="line-completion.gif"></p>
<h2 id="文字挿入削除">文字挿入・削除</h2>
<h3 id="一文字削除">一文字削除</h3>
<p><kbd>Ctrl</kbd> + <kbd>h</kbd>で一文字削除します（backspace同様）
<img src="https://qiita-image-store.s3.amazonaws.com/0/66178/1e7582d6-5e0b-355d-c614-be3c5bbdd988.gif" alt="remove-char.gif"></p>
<h3 id="一単語削除">一単語削除</h3>
<p><kbd>Ctrl</kbd> + <kbd>w</kbd>で一単語を削除します。
<img src="https://qiita-image-store.s3.amazonaws.com/0/66178/16cb4bb6-7a51-9e19-2a5c-27d09ce586a7.gif" alt="remove-word.gif"></p>
<h3 id="カーソルより前をすべて削除">カーソルより前をすべて削除</h3>
<p><kbd>Ctrl</kbd> + <kbd>u</kbd>で現在のカーソルより前に入力した文字をすべて削除します。
<img src="https://qiita-image-store.s3.amazonaws.com/0/66178/f79625d9-a47d-93b3-110f-495997e96776.gif" alt="remove-all.gif"></p>
<h3 id="カーソルの一段上の文字をそのまま挿入">カーソルの一段上の文字をそのまま挿入</h3>
<p><kbd>Ctrl</kbd> + <kbd>y</kbd>で現在のカーソルの一段上の文字をそのまま挿入します。
<img src="https://qiita-image-store.s3.amazonaws.com/0/66178/80bc5c0f-c302-d154-e367-ebc317de1888.gif" alt="insert-up.gif"></p>
<h3 id="一度コマンド実行してインサートモードに戻る">一度コマンド実行して、インサートモードに戻る</h3>
<p><kbd>Ctrl</kbd> + <kbd>o</kbd>でコマンド（<code>yy</code>やら<code>dd</code>やら<code>:xxx</code>やら）を実行できて、完了後インサートモードに戻る。
<img src="https://qiita-image-store.s3.amazonaws.com/0/66178/c68379dd-5bc8-eaf4-8fd0-7b4db0c281f2.gif" alt="one-command.gif"></p>
<h2 id="まとめ">まとめ</h2>
<p>全部日本語ドキュメントに書いてあることですが、
gif付きでわかりやすい備忘録として残しておきました。</p>
<p><a href="https://vim-jp.org/vimdoc-ja/insert.html">https://vim-jp.org/vimdoc-ja/insert.html</a></p>
]]></content></item><item><title>Vimのセッション機能を使う</title><link>https://skanehira.github.io/blog/posts/20181215-vim-session/</link><pubDate>Sat, 15 Dec 2018 00:00:00 +0000</pubDate><guid>https://skanehira.github.io/blog/posts/20181215-vim-session/</guid><description>みなさん、vimにセッション機能があるのはご存じでしょうか？ 便利そうなので使ってみようと思っていますが、せっかくなのでVim scriptの勉</description><content type="html"><![CDATA[<p>みなさん、vimに<a href="https://vim-jp.org/vimdoc-ja/usr_21.html#21.4">セッション機能</a>があるのはご存じでしょうか？
便利そうなので使ってみようと思っていますが、せっかくなのでVim scriptの勉強も兼ねてコマンド作ってみました。</p>
<p>fzf.vimを使うとこんな感じになります。
<img src="https://qiita-image-store.s3.amazonaws.com/0/66178/21a1dc7b-44cc-0e9c-c88d-03d74abf9cbc.png" alt="image.png"></p>
<p>以下のコードをvimrcに貼ればそのまま使えると思います。</p>
<h2 id="2018-12-22-追記">[2018-12-22] 追記</h2>
<p>プラグイン化しました。
また、記事中のソース若干変更は入っています。
<a href="https://github.com/skanehira/vsession">https://github.com/skanehira/vsession</a></p>
<h2 id="セッションファイル保存先">セッションファイル保存先</h2>
<p><code>~/.vim/sessions/</code>配下にセッションファイルを保存します。
ディレクトリがなければ作るようにしています。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="c">&#34; session path</span><span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">s</span>:<span class="nx">session_path</span> <span class="p">=</span> <span class="nx">expand</span><span class="p">(</span><span class="s1">&#39;~/.vim/sessions&#39;</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">if</span> <span class="p">!</span><span class="nx">isdirectory</span><span class="p">(</span><span class="nx">s</span>:<span class="nx">session_path</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">mkdir</span><span class="p">(</span><span class="nx">s</span>:<span class="nx">session_path</span><span class="p">,</span> <span class="s2">&#34;p&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="k">endif</span><span class="err">
</span></code></pre></div><h2 id="セッションの保存">セッションの保存</h2>
<p><code>:SaveSession test1.vim</code>という感じで、セッションファイル名を指定して保存します。
同じファイル名を指定すると上書きされるのでご注意。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="c">&#34; save session</span><span class="err">
</span><span class="err"></span><span class="nx">command</span><span class="p">!</span> <span class="p">-</span><span class="nx">nargs</span><span class="p">=</span><span class="m">1</span> <span class="nx">SaveSession</span> <span class="nx">call</span> <span class="nx">s</span>:<span class="nx">saveSession</span><span class="p">(&lt;</span><span class="nx">f</span><span class="p">-</span><span class="nx">args</span><span class="p">&gt;)</span><span class="err">
</span><span class="err"></span><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">saveSession</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">execute</span> <span class="s1">&#39;silent mksession!&#39;</span> <span class="nx">s</span>:<span class="nx">session_path</span> . <span class="s1">&#39;/&#39;</span> . <span class="nx">a</span>:<span class="nx">file</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span></code></pre></div><h2 id="セッションの復元">セッションの復元</h2>
<p><code>:LoadSession ~/.vim/sessions/test1.vim</code>という感じで、セッションファイルのパスを指定して読み込みます。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="c">&#34; load session</span><span class="err">
</span><span class="err"></span><span class="nx">command</span><span class="p">!</span> <span class="p">-</span><span class="nx">nargs</span><span class="p">=</span><span class="m">1</span> <span class="nx">LoadSession</span> <span class="nx">call</span> <span class="nx">s</span>:<span class="nx">loadSession</span><span class="p">(&lt;</span><span class="nx">f</span><span class="p">-</span><span class="nx">args</span><span class="p">&gt;)</span><span class="err">
</span><span class="err"></span><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">loadSession</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">execute</span> <span class="s1">&#39;silent source&#39;</span> <span class="nx">a</span>:<span class="nx">file</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span></code></pre></div><p>fzf.vim版はこちらです。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="nx">command</span><span class="p">!</span> <span class="nx">FloadSession</span> <span class="nx">call</span> <span class="nx">fzf</span>#<span class="nx">run</span><span class="p">(</span>{<span class="err">
</span><span class="err"></span>\  <span class="s1">&#39;source&#39;</span>: <span class="nx">split</span><span class="p">(</span><span class="nx">glob</span><span class="p">(</span><span class="nx">s</span>:<span class="nx">session_path</span> . <span class="s2">&#34;/*&#34;</span><span class="p">),</span> <span class="s2">&#34;\n&#34;</span><span class="p">),</span><span class="err">
</span><span class="err"></span>\  <span class="s1">&#39;sink&#39;</span>:    <span class="k">function</span><span class="p">(</span><span class="s1">&#39;s:loadSession&#39;</span><span class="p">),</span><span class="err">
</span><span class="err"></span>\  <span class="s1">&#39;options&#39;</span>: <span class="s1">&#39;-m -x +s&#39;</span><span class="p">,</span><span class="err">
</span><span class="err"></span>\  <span class="s1">&#39;down&#39;</span>:    <span class="s1">&#39;40%&#39;</span>}<span class="p">)</span><span class="err">
</span></code></pre></div><h2 id="セッションの削除">セッションの削除</h2>
<p><code>:DeleteSession ~/.vim/sessions/test1.vim</code>という感じで、削除します。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="c">&#34; delete session</span><span class="err">
</span><span class="err"></span><span class="nx">command</span><span class="p">!</span> <span class="p">-</span><span class="nx">nargs</span><span class="p">=</span><span class="m">1</span> <span class="nx">DeleteSession</span> <span class="nx">call</span> <span class="nx">s</span>:<span class="nx">deleteSession</span><span class="p">(&lt;</span><span class="nx">f</span><span class="p">-</span><span class="nx">args</span><span class="p">&gt;)</span><span class="err">
</span><span class="err"></span><span class="k">function</span><span class="p">!</span> <span class="nx">s</span>:<span class="nx">deleteSession</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nx">call</span> <span class="nx">delete</span><span class="p">(</span><span class="nx">expand</span><span class="p">(</span><span class="nx">a</span>:<span class="nx">file</span><span class="p">))</span><span class="err">
</span><span class="err"></span><span class="k">endfunction</span><span class="err">
</span></code></pre></div><p>fzf.vim版はこちらです。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="nx">command</span><span class="p">!</span> <span class="nx">FdeleteSession</span> <span class="nx">call</span> <span class="nx">fzf</span>#<span class="nx">run</span><span class="p">(</span>{<span class="err">
</span><span class="err"></span>\  <span class="s1">&#39;source&#39;</span>: <span class="nx">split</span><span class="p">(</span><span class="nx">glob</span><span class="p">(</span><span class="nx">s</span>:<span class="nx">session_path</span> . <span class="s2">&#34;/*&#34;</span><span class="p">),</span> <span class="s2">&#34;\n&#34;</span><span class="p">),</span><span class="err">
</span><span class="err"></span>\  <span class="s1">&#39;sink&#39;</span>:    <span class="k">function</span><span class="p">(</span><span class="s1">&#39;s:deleteSession&#39;</span><span class="p">),</span><span class="err">
</span><span class="err"></span>\  <span class="s1">&#39;options&#39;</span>: <span class="s1">&#39;-m -x +s&#39;</span><span class="p">,</span><span class="err">
</span><span class="err"></span>\  <span class="s1">&#39;down&#39;</span>:    <span class="s1">&#39;40%&#39;</span>}<span class="p">)</span><span class="err">
</span></code></pre></div><h2 id="キーマッピング">キーマッピング</h2>
<p>こんな感じでマッピングしたら楽です。</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="nx">nnoremap</span> <span class="p">&lt;</span><span class="nx">Leader</span><span class="p">&gt;</span><span class="nx">se</span> :<span class="nx">SaveSession</span> <span class="err">
</span><span class="err"></span><span class="nx">nnoremap</span> <span class="p">&lt;</span><span class="nx">Leader</span><span class="p">&gt;</span><span class="nx">lse</span> :<span class="nx">FloadSession</span><span class="p">&lt;</span><span class="nx">CR</span><span class="p">&gt;</span><span class="err">
</span></code></pre></div><h2 id="参考記事">参考記事</h2>
<p><a href="https://thinca.hatenablog.com/entry/20100201/1265009821">https://thinca.hatenablog.com/entry/20100201/1265009821</a>
<a href="https://qiita.com/shinshin86/items/6e6cbdb77cb59b87d21f">https://qiita.com/shinshin86/items/6e6cbdb77cb59b87d21f</a>
<a href="http://nanasi.jp/articles/code/io/file-path.html">http://nanasi.jp/articles/code/io/file-path.html</a></p>
<h2 id="最後に">最後に</h2>
<p>初めてVim script書いたので、おかしなところがありましたら教えていただけると助かります。
ちなみに、vimのセッションプラグインはありました。</p>
<p>使っていないのですが、良下げなので興味ある方はどうぞー</p>
<p><a href="https://github.com/Shougo/unite-session">https://github.com/Shougo/unite-session</a>
<a href="https://github.com/xolox/vim-session">https://github.com/xolox/vim-session</a></p>
]]></content></item></channel></rss>