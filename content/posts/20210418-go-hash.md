---
title: "Goでハッシュ値計算時にメモリ消費量を抑える方法"
date: 2021-04-18
toc: true
tags:
  - Go
---

## 始めに
先日、Lambdaでファイルのチェックサムをしていたら、ファイルサイズが大きすぎてout of memoryを起こしたという事象に遭遇しました。
その原因と対策について、書いていきます。

### Goでのハッシュ値計算
Goでsha256などを使ってファイルをチェックサムをする時に、ファイルをバイト列にして`crypto`パッケージを使ってハッシュを計算します。
しかし、ファイルの中身をすべてメモリに展開すると、ファイルのサイズ分のメモリを消費してしまうという問題があります。

```go
b, err := ioutil.ReadFile("video.mp4")
if err != nil {
	// error handling
}

v := sha256.New().Sum(b)
```

そこで`io.Copy`を使ってメモリ消費を抑えてハッシュ値を計算できます。

```go
r, err := os.Open("video.mp4")
if err != nil {
	// error handling
}

hash := sha256.New()
if _, err := io.Copy(hash, r); err != nil {
	// error handling
}

v := hash.Sum(nil)
```

### ベンチマーク
`crypto/sha256`は`io.Writer`を実装しているのため、`io.Copy`を使って効率よくデータを受け取り計算できます。
実際どれくらいメモリ消費量を抑えられるか、次のコードでベンチマークを取ってみます。

`b.ResetTimer()`を使っているのは、純粋にハッシュ値計算に使うメモリ量の比較をしたいので`ioutil.ReadFile`で使ったメモリを含めないためです。
このコードがフェアかどうか、あまり自信がないので変だと思ったら指摘いただけると助かります。

```go
package main

import (
	"bytes"
	"crypto/sha256"
	"io"
	"io/ioutil"
	"testing"
)

func setup(b *testing.B) []byte {
	input, err := ioutil.ReadFile("xxx.log")
	if err != nil {
		b.Fatal(err)
	}

	return input
}

func BenchmarkHashBuffer(b *testing.B) {
	input := setup(b)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		hash := sha256.New()
		_ = hash.Sum(input)
	}

}

func BenchmarkHashStream(b *testing.B) {
	input := setup(b)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		hash := sha256.New()
		if _, err := io.Copy(hash, bytes.NewReader(input)); err != nil {
			b.Fatal(err)
		}
		_ = hash.Sum(nil)
	}
}
```

次がベンチマークの結果です。`1.2GB`のファイルのハッシュ値を算出するのに`io.Copy`を使った方がメモリ使用量を結構抑えらています。

```sh
MacbookPro13% go test -bench . -benchmem
goos: darwin
goarch: arm64
pkg: github.com/skanehira/test/hash
BenchmarkHashBuffer-8                 13         475862593 ns/op        1593622684 B/op        1 allocs/op
BenchmarkHashStream-8                  2         540349312 ns/op             208 B/op          3 allocs/op
PASS
ok      github.com/skanehira/test/hash       9.665s
```

### なぜ`io.Copy`でハッシュ値を計算できるか
ふわっとした理解ですので、間違ってたら指摘いただければと思います。

[こちら](https://www.air-h.jp/articles/emopro/%E3%80%90go%E3%80%91%E6%9A%97%E5%8F%B7%E5%8C%96%E3%82%84%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E5%8C%96%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E8%80%83%E3%81%88%E3%82%8B%E3%81%A4%E3%81%84%E3%81%A7%E3%81%AB/)の記事に詳しく書かれていますが、ハッシュ値計算時は入力を一気に変換するのではなく入力をメッセージブロックごとに分けて計算しています。
そのため、ファイルの中身を一気にメモリに展開する必要がないです。

`io.Copy`は以下のコード通り、デフォルト`32kb`のメモリを確保して、それを使ってデータを繰り返し`io.Writer`に渡していく様になっていますが、上記理由で問題なくハッシュを計算できます。

### まとめ
sha256以外にもmd5も同様に`io.Copy`が使えることは確認しています。ほかのハッシュ値計算はできるかは確認していないんですが、おそらく可能だと思います。
基本的に`io.Copy`を使ったほうが省メモリですので、可能な場合は使った方が良いと思います。
